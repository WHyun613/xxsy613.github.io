<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="整理自https:&#x2F;&#x2F;www.cnblogs.com&#x2F;wkfvawl&#x2F;p&#x2F;14407427.html仅私用 第一章 计算机系统概述 1.操作系统的目标和功能1.操作系统是计算机资源的管理者  处理机管理（进程控制、进程同步、进程通信、死锁处理、处理机调度） 存储器管理（提高内存利用率，内存的分配与回收、地址映射、内存保护与共享、内存扩充） 文件管理（计算机中的信息都是以文件的形式存在的） 设备管理">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统_大纲">
<meta property="og:url" content="http://xxsy613.github.io/2023/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="水云的博客">
<meta property="og:description" content="整理自https:&#x2F;&#x2F;www.cnblogs.com&#x2F;wkfvawl&#x2F;p&#x2F;14407427.html仅私用 第一章 计算机系统概述 1.操作系统的目标和功能1.操作系统是计算机资源的管理者  处理机管理（进程控制、进程同步、进程通信、死锁处理、处理机调度） 存储器管理（提高内存利用率，内存的分配与回收、地址映射、内存保护与共享、内存扩充） 文件管理（计算机中的信息都是以文件的形式存在的） 设备管理">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1358881/202101/1358881-20210131202554260-1557827476.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1358881/202101/1358881-20210131203424936-732097698.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1358881/202101/1358881-20210131203515309-1558716556.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1358881/202101/1358881-20210131203937554-856937188.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1358881/202102/1358881-20210216110019787-622445921.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1358881/202102/1358881-20210216110302082-1321686745.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1358881/202102/1358881-20210216112304409-947781658.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1358881/202102/1358881-20210216115945604-1204739333.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1358881/202102/1358881-20210216192459401-156747795.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1358881/202102/1358881-20210216200311860-1626798222.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1358881/202102/1358881-20210216200842314-313480643.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1358881/202102/1358881-20210216201310999-404151886.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1358881/202102/1358881-20210216201353793-845472878.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1358881/202102/1358881-20210216201414645-2101301826.png">
<meta property="article:published_time" content="2023-10-29T16:00:00.000Z">
<meta property="article:modified_time" content="2023-10-30T07:56:24.060Z">
<meta property="article:author" content="潇湘水云">
<meta property="article:tag" content="考研">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img2020.cnblogs.com/blog/1358881/202101/1358881-20210131202554260-1557827476.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>操作系统_大纲</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
      <link rel="alternate" href="/%5Bobject%20Object%5D" title="水云的博客" type="application/atom+xml" />
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.2.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2023/10/30/408%E8%8B%B1%E6%96%87%E7%BC%A9%E5%86%99%E5%85%A8%E8%A7%A3/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2023/10/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://xxsy613.github.io/2023/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://xxsy613.github.io/2023/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/&text=操作系统_大纲"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://xxsy613.github.io/2023/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/&title=操作系统_大纲"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://xxsy613.github.io/2023/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/&is_video=false&description=操作系统_大纲"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=操作系统_大纲&body=Check out this article: http://xxsy613.github.io/2023/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://xxsy613.github.io/2023/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/&title=操作系统_大纲"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://xxsy613.github.io/2023/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/&title=操作系统_大纲"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://xxsy613.github.io/2023/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/&title=操作系统_大纲"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://xxsy613.github.io/2023/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/&title=操作系统_大纲"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://xxsy613.github.io/2023/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/&name=操作系统_大纲&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://xxsy613.github.io/2023/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/&t=操作系统_大纲"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">第一章 计算机系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9B%AE%E6%A0%87%E5%92%8C%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.</span> <span class="toc-text">1.操作系统的目标和功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.</span> <span class="toc-text">2.操作系统的运行机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="toc-number">1.3.</span> <span class="toc-text">3.中断和异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.4.</span> <span class="toc-text">4.系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%A4%A7%E5%86%85%E6%A0%B8%E5%92%8C%E5%BE%AE%E5%86%85%E6%A0%B8"><span class="toc-number">1.5.</span> <span class="toc-text">5.大内核和微内核</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">第二章 进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">1.进程与线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">2.进程的通信方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%BF%9B%E7%A8%8B%E7%9A%845%E7%A7%8D%E7%8A%B6%E6%80%81%E5%8F%8A%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">3.进程的5种状态及转换过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">4.进程的调度算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%90%8C%E6%AD%A5%E5%92%8C%E4%BA%92%E6%96%A5"><span class="toc-number">2.5.</span> <span class="toc-text">5.同步和互斥</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">2.6.</span> <span class="toc-text">6.进程同步相关概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%AD%BB%E9%94%81"><span class="toc-number">2.7.</span> <span class="toc-text">7.死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E9%A5%A5%E9%A5%BF"><span class="toc-number">2.8.</span> <span class="toc-text">8.饥饿</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-number">2.9.</span> <span class="toc-text">9.银行家算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E6%AD%BB%E9%94%81%E5%AE%9A%E7%90%86"><span class="toc-number">2.10.</span> <span class="toc-text">10.死锁定理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">第三章 内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">3.1.</span> <span class="toc-text">1.存储器管理的功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B0%86%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E5%8F%98%E4%B8%BA%E5%8F%AF%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%89%A7%E8%A1%8C%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.2.</span> <span class="toc-text">2.将用户程序变为可在内存中执行的程序的步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">3.程序的链接方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A3%85%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">3.4.</span> <span class="toc-text">4.程序的装入方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF"><span class="toc-number">3.5.</span> <span class="toc-text">5.覆盖技术和交换技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%86%85%E5%AD%98%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">3.6.</span> <span class="toc-text">6.内存连续分配管理方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%92%8C%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">3.7.</span> <span class="toc-text">7.基本分页和请求分页内存管理方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">3.8.</span> <span class="toc-text">8.页面置换算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E9%A1%B5%E8%A1%A8%E5%92%8C%E5%BF%AB%E8%A1%A8"><span class="toc-number">3.9.</span> <span class="toc-text">9.页表和快表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">3.10.</span> <span class="toc-text">10.地址翻译的过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">第四章 文件管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.</span> <span class="toc-text">1.文件的基本操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">2.磁盘调度算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86"><span class="toc-number">4.3.</span> <span class="toc-text">第五章、输入输出管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-I-x2F-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">4.4.</span> <span class="toc-text">1.I&#x2F;O控制方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Spooling%E6%8A%80%E6%9C%AF"><span class="toc-number">4.4.1.</span> <span class="toc-text">5.Spooling技术</span></a></li></ol></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        操作系统_大纲
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">潇湘水云</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-10-29T16:00:00.000Z" itemprop="datePublished">2023-10-30</time>
        
        (Updated: <time datetime="2023-10-30T07:56:24.060Z" itemprop="dateModified">2023-10-30</time>)
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/%E8%80%83%E7%A0%94/" rel="tag">考研</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>整理自<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wkfvawl/p/14407427.html%E4%BB%85%E7%A7%81%E7%94%A8">https://www.cnblogs.com/wkfvawl/p/14407427.html仅私用</a></p>
<h1 id="第一章-计算机系统概述"><a href="#第一章-计算机系统概述" class="headerlink" title="第一章 计算机系统概述"></a>第一章 计算机系统概述</h1><p><img src="https://img2020.cnblogs.com/blog/1358881/202101/1358881-20210131202554260-1557827476.png" alt="img"></p>
<h2 id="1-操作系统的目标和功能"><a href="#1-操作系统的目标和功能" class="headerlink" title="1.操作系统的目标和功能"></a>1.操作系统的目标和功能</h2><p><strong>1.操作系统是计算机资源的管理者</strong></p>
<ul>
<li><strong>处理机管理</strong>（进程控制、进程同步、进程通信、死锁处理、处理机调度）</li>
<li><strong>存储器管理</strong>（提高内存利用率，内存的分配与回收、地址映射、内存保护与共享、内存扩充）</li>
<li><strong>文件管理</strong>（计算机中的信息都是以文件的形式存在的）</li>
<li><strong>设备管理</strong>（完成用户的I&#x2F;O请求，方便用户使用设备、并提高设备的利用率）</li>
</ul>
<p><strong>2.操作系统为用户提供使用计算机硬件系统的接口</strong></p>
<ul>
<li><strong>命令接口</strong>（用户通过控制台或终端输入操作命令，向系统提供各种服务要求）</li>
<li><strong>程序接口</strong>（由 系统调用 组成，用户在程序中使用这些系统调用来请求操作系统为其提供服务）</li>
<li><strong>图形接口</strong> 最常见的 图形用户界面GUI （最终还是通过调用程序接口实现的）</li>
</ul>
<p><strong>3.操作系统用作扩充机器</strong><br>没有任何软件支持的计算机称为<strong>裸机</strong>，实际呈现在用户面前的计算机系统是经过若干层软件改造的计算机。操作系统将裸机改造成功能更强、使用更方便的机器。我们将覆盖了软件的机器称为扩充机器或虚拟机。</p>
<h2 id="2-操作系统的运行机制"><a href="#2-操作系统的运行机制" class="headerlink" title="2.操作系统的运行机制"></a>2.操作系统的运行机制</h2><p><strong>1.内核程序和应用程序(内核态和用户态)</strong><br>在计算机系统中，通常CPU执行两种不同性质的程序：一种是操作系统内核程序；另一种是用户自编程序或系统外层的应用程序。内核程序是应用程序的”管理者”。“管理程序“可以执行一些特权指令，而”被管理程序“出于安全考虑不能执行这些指令。所谓特权指令，是指计算机中不允许用户直接使用的指令，如：I&#x2F;O指令、置中断指令，存取用于内存保护的寄存器，送程序状态字到程序状态字寄存器等指令。<br>操作系统在具体实现上划分了<strong>用户态（目态）</strong>和<strong>核心态（管态）</strong>，以严格区分两类程序。<br><strong>2.层次式结构</strong><br>操作系统的各项功能分别被设置在不同的层次上。一些与硬件关联较紧密的模块，诸如时钟管理、中断管理、设备驱动等处于最底层。其次是运行频率较高的程序，诸如进程管理、存储管理和设备管理等。 上面的这两部分内容构成了操作系统的内核，这部分内容的指令操作工作在核心态。<br><strong>3.内核</strong><br>内核是计算机上配置的底层软件，是计算机功能的延伸，包括以下4个方面的内容：<br>1）<strong>时钟管理</strong> 时钟的第一功能是计时，操作系统需要通过时钟管理，向用户提供标准的系统时间。其次，通过时钟中断的管理，可以实现进程的切换。在分时操作系统中，采用时间片轮转调度的实现；在实时系统中，按截至时间控制运行的实现；在批处理系统中，通过时钟管理来衡量一个作业的运行程度等。<br>2）<strong>中断机制</strong> 引入中断技术的初衷是提高多道程序运行环境中CPU的利用率，主要针对外部设备。后来逐步得到发展，形成了多种类型，成为操作系统各项操作的基础。如，键盘或鼠标信息的输入、进程的管理和调度、系统功能的调用、设备驱动、文件访问等。都依赖于中断机制。可以说，现代操作系统是靠中断驱动的软件。中断机制中，只有一小部分功能属于内核，负责保护和恢复中断现场的信息，转移控制权到相关的处理程序。这样可以减少中断的处理时间，提高系统的并行处理能力。<br>3）<strong>原语</strong> 操作系统底层是一些可被调用的公用小程序，它们各自完成一个规定的操作，其特点是：</p>
<ul>
<li>它们处于操作系统的最底层，是最接近硬件的部分。</li>
<li>这些程序的运行具有原子性，其操作只能一气呵成</li>
<li>这些程序的运行时间都较短，而且调用频繁。</li>
</ul>
<p>定义原语的直接方法是关闭中断，让它的所有动作不可分割地进行完再打开中断。<br>4）<strong>系统控制的数据结构及处理</strong> 系统中用来登记状态信息的数据结构很多，比如：作业控制块、进程控制块、设备控制块、各类链表等。为了实现有效的管理，系统需要一些基本的操作，常见的操作有以下三种：</p>
<ul>
<li><strong>进程管理</strong>：进程状态管理、进程调度和分配、创建和撤销进程控制块等。</li>
<li><strong>存储器管理</strong>：存储器的空间分配和回收、内存信息保护程序、代码对换程序等。</li>
<li><strong>设备管理</strong>：缓冲区管理、设备分配和回收等。</li>
</ul>
<h2 id="3-中断和异常"><a href="#3-中断和异常" class="headerlink" title="3.中断和异常"></a>3.中断和异常</h2><p><strong>1.中断的引入——为了支持CPU和设备之间的并行操作</strong></p>
<p>中断也称外中断，指来自CPU执行指令以外的事件的发生，如设备发出的I&#x2F;O结束中断、时钟中断<br>等。这一类中断通常是与当前执行的指令无关的事件。<br><strong>2.异常的引入——表示CPU执行指令本身时出现的问题</strong><br>异常也称内中断、例外或陷入，指源自CPU执行指令内部的事件，如程序的非法操作码、地址越界、算术溢出、缺页异常等。对异常的处理一般要依赖与当前程序的运行现场，不能被屏蔽。<br><strong>3.中断和异常的联系与区别</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1358881/202101/1358881-20210131203424936-732097698.png" alt="img"></p>
<p><strong>4.中断执行的流程</strong></p>
<p><strong><img src="https://img2020.cnblogs.com/blog/1358881/202101/1358881-20210131203515309-1558716556.png" alt="img"></strong></p>
<p>以上是多重中断的流程，其中，1~3步是由硬件（中断隐指令）完成的；4-9步是由中断服务程序<br>完成的。</p>
<h2 id="4-系统调用"><a href="#4-系统调用" class="headerlink" title="4.系统调用"></a>4.系统调用</h2><p>计算机系统的各种硬件资源是有限，为了更好的管理这些资源，进程是不允许直接操作的，所有对这些资源的访问都必须有操作系统控制。也就是说操作系统是使用这些资源的唯一入口，而这个入口就是操作系统提供的系统调用。一般地，系统调用都是通过中断实现的，比如，linux下中断号0x80就是进行系统调用的。<br>操作系统为用户态进程与硬件设备进行交互提供了一组接口——系统调用:1.把用户从底层的硬件编程中解放了出来;2.极大地提高了系统的安全性使用户程序具有可移植性；用户程序与具体硬件已经被抽象接口所替代。<br>系统调用流程图如下</p>
<p><img src="https://img2020.cnblogs.com/blog/1358881/202101/1358881-20210131203937554-856937188.png" alt="img"></p>
<h2 id="5-大内核和微内核"><a href="#5-大内核和微内核" class="headerlink" title="5.大内核和微内核"></a>5.大内核和微内核</h2><p><strong>1.大内核</strong><br>大内核是将操作系统功能作为一个紧密结合的整体放到内核。由于各模块共享信息，因此有很高的性能。<br><strong>2.微内核</strong><br>由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。<br>在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。</p>
<p>因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。</p>
<p><img src="https://img2020.cnblogs.com/blog/1358881/202102/1358881-20210216110019787-622445921.png" alt="img"></p>
<h1 id="第二章-进程管理"><a href="#第二章-进程管理" class="headerlink" title="第二章 进程管理"></a>第二章 进程管理</h1><p><img src="https://img2020.cnblogs.com/blog/1358881/202102/1358881-20210216110302082-1321686745.png" alt="img"></p>
<h2 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1.进程与线程"></a>1.进程与线程</h2><p><strong>1.进程的概念与定义</strong><br>在多道程序环境下，允许多个进程并发执行，此时他们将失去封闭性，并具有间断性及不可再现性的特征。为此引入了进程的概念，以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性。<strong>进程是程序的运行过程，是系统进行资源分配和调度的一个独立单位。</strong></p>
<p><strong>2.线程的概念和定义</strong><br>早期，在OS中能拥有资源和独立运行的基本单位是进程，然而随着计算机技术的发展，进程出现了很多弊端，一是由于进程是资源拥有者，创建、撤消与切换存在较大的时空开销，因此需要引入轻型进程；二是由于对称多处理机（SMP）出现，可以满足多个运行单位，而多个进程并行开销过大。<strong>线程是操作系统能够进行运算调度的最小单位。</strong>它被包含在进程之中，是进程中的实际运作单位。<strong>一条线程指的是进程中一个单一顺序的控制流，每条线程执行不同的任务。</strong></p>
<p><strong>3.进程和线程的区别</strong></p>
<ul>
<li>进程（Process）是系统进行资源分配和调度的基本单位，线程（Thread）是CPU调度和分派的基本单位；</li>
<li>线程依赖于进程而存在，一个进程至少有一个线程；</li>
<li>进程有自己的独立地址空间，线程共享所属进程的地址空间；</li>
<li>进程是拥有系统资源的一个独立单位，而线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，和其他线程共享本进程的相关资源如内存、I&#x2F;O、cpu等；</li>
<li>在进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作，可见，进程切换的开销远大于线程切换的开销；</li>
<li>线程之间的通信更方便，同一进程下的线程共享全局变量等数据，而进程之间的通信需要以进程间通信(IPC)的方式进行；</li>
<li>多线程程序只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其它进程造成影响，因为进程有自己的独立地址空间，因此多进程更加健壮</li>
</ul>
<p><strong>4.进程和程序的区别</strong></p>
<ul>
<li>程序是永存的；进程是暂时的，是程序在数据集上的一次执行，有创建有撤销，存在是暂时的；</li>
<li>程序是静态的观念，进程是动态的观念；</li>
<li>进程具有并发性，而程序没有；</li>
<li>进程是竞争计算机资源的基本单位，程序不是。</li>
<li>进程和程序不是一一对应的： 一个程序可对应多个进程即多个进程可执行同一程序； 一个进程可以执行一个或几个程序</li>
</ul>
<h2 id="2-进程的通信方式"><a href="#2-进程的通信方式" class="headerlink" title="2.进程的通信方式"></a>2.进程的通信方式</h2><p><strong>1.共享内存</strong><br>顾名思义，共享内存就是两个进程同时共享一块内存，然后在这块内存上的数据可以共同修改和读取，达到通信的目的。<br><strong>2.无名管道</strong><br>无名管道是半双工的通信方式；并且只能在具有亲缘关系的进程之间使用（亲缘关系是指进程间的父子关系，兄弟关系等），具有亲缘关系的进程在创建时同时拥有一个无名管道的句柄，可以进行读写；无名管道不存在磁盘节点，只存在与内存中用完即销毁。<br><strong>3.命名管道</strong><br>命名管道也是半双工的通信方式；可以在不具有亲缘关系的进程间通信；有名管道存在磁盘节点，有对应的FIFO文件，凡是可以访问该路径的文件的进程均可以进行通信。<br><strong>4.消息队列</strong><br>消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。<br><strong>5.套接字</strong><br>套接字是网络编程的api，通过套接字可以不同的机器间的进程进行通信，常用于客户端进程和服务器进程的通信。<br><strong>6.信号</strong><br>信号是Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。一个键盘中断或者一个错误条件（比如进程试图访问它的虚拟内存中不存在的位置等）都有可能产生一个信号。Shell也使用信号向它的子进程发送作业控制信号。</p>
<h2 id="3-进程的5种状态及转换过程"><a href="#3-进程的5种状态及转换过程" class="headerlink" title="3.进程的5种状态及转换过程"></a>3.进程的5种状态及转换过程</h2><p><img src="https://img2020.cnblogs.com/blog/1358881/202102/1358881-20210216112304409-947781658.png" alt="img"></p>
<h2 id="4-进程的调度算法"><a href="#4-进程的调度算法" class="headerlink" title="4.进程的调度算法"></a>4.进程的调度算法</h2><p><strong>1.先来先服务 first-come first-serverd（FCFS）</strong><br>按照请求的顺序进行调度。非抢占式，开销小，无饥饿问题，响应时间不确定（可能很慢）；对短进程不利，对IO密集型进程不利。<br><strong>2.最短作业优先 shortest job first（SJF）</strong><br>按估计运行时间最短的顺序进行调度。非抢占式，吞吐量高，开销可能较大，可能导致饥饿问题；对短进程提供好的响应时间，对长进程不利<br><strong>3.优先级调度算法</strong><br>为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。<br><strong>4.时间片轮转</strong><br>将所有就绪进程按 FCFS 的原则排成一个队列，用完时间片的进程排到队列最后。抢占式（时间片用完时），开销小，无饥饿问题，为短进程提供好的响应时间；若时间片小，进程切换频繁，吞吐量低；若时间片太长，实时性得不到保证。<br><strong>5.最高响应比优先</strong><br>响应比 &#x3D; 1+ 等待时间&#x2F;处理时间。同时考虑了等待时间的长短和估计需要的执行时间长短，很好的平衡了长短进程。非抢占，吞吐量高，开销可能较大，提供好的响应时间，无饥饿问题。<br><strong>6.多级反馈队列调度算法</strong><br>设置多个就绪队列1、2、3…，优先级递减，时间片递增。只有等到优先级更高的队列为空时才会调度当前队列中的进程。如果进程用完了当前队列的时间片还未执行完，则会被移到下一队列。抢占式（时间片用完时），开销可能较大，对IO型进程有利，可能会出现饥饿问题。</p>
<h2 id="5-同步和互斥"><a href="#5-同步和互斥" class="headerlink" title="5.同步和互斥"></a>5.同步和互斥</h2><p><strong>1.同步</strong><br>多个进程因为合作而使得进程的执行有一定的先后顺序。比如某个进程需要另一个进程提供的消息，获得消息之前进入阻塞态；<br><strong>2.互斥</strong><br>多个进程在同一时刻只有一个进程能进入临界区<br><strong>3.同步机制的4个准则</strong></p>
<ul>
<li>空闲让进：当无进程处于临界区，可允许一个请求进入临界区的进程立即进入自己的临界区</li>
<li>忙则等待：当已有进程进入自己的临界区，所有企图进入临界区的进程必须等待</li>
<li>有限等待：对要求访问临界资源的进程，应保证该进程能在有限时间内进入自己的临界区</li>
<li>让权等待：当进程不能进入自己的临界区，应释放处理机</li>
</ul>
<h2 id="6-进程同步相关概念"><a href="#6-进程同步相关概念" class="headerlink" title="6.进程同步相关概念"></a>6.进程同步相关概念</h2><p>为什么需要进程同步：进程有时候会和其他进程共享一些资源，比如内存、数据库等。当多个进程同时读写同一份共享资源的时候，可能会发生冲突。因此需要进程的同步，多个进程按顺序访问资源。<br><strong>互斥量 Mutex：</strong>互斥量是内核对象，只有拥有互斥对象的线程才有访问互斥资源的权限。因为互斥对象只有一个，所以可以保证互斥资源不会被多个线程同时访问；当前拥有互斥对象的线程处理完任务后必须将互斥对象交出，以便其他线程访问该资源；<br><strong>信号量 Semaphore：</strong>信号量是内核对象，它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。信号量对象保存了最大资源计数和当前可用资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就减1，只要当前可用资源计数大于0，就可以发出信号量信号，如果为0，则将线程放入一个队列中等待。线程处理完共享资源后，应在离开的同时通过 ReleaseSemaphore 函数将当前可用资源数加1。如果信号量的取值只能为0或1，那么信号量就成为了互斥量；<br><strong>事件 Event：</strong>允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。事件分为手动重置事件和自动重置事件。手动重置事件被设置为激发状态后，会唤醒所有等待的线程，而且一直保持为激发状态，直到程序重新把它设置为未激发状态。自动重置事件被设置为激发状态后，会唤醒一个等待中的线程，然后自动恢复为未激发状态。<br><strong>临界区 Critical Section：</strong>指的是访问资源的那段代码，任意时刻只允许一个线程对临界资源进行访问。拥有临界区对象的线程可以访问该临界资源，其它试图访问该资源的线程将被挂起，直到临界区对象被释放。</p>
<h2 id="7-死锁"><a href="#7-死锁" class="headerlink" title="7.死锁"></a>7.死锁</h2><p><strong>1.死锁的定义</strong><br>是指两个或两个以上的进程在执行过程中，<strong>因争夺资源而造成的一种互相等待的现象</strong>，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。<br><strong>2.死锁原因</strong></p>
<ul>
<li>系统资源不足（对不可剥夺资源的竞争）</li>
<li>进程推进顺序不当（P1拥有A申请B，P2拥有B申请A）</li>
</ul>
<p><strong>3.产生死锁的必要条件</strong></p>
<ul>
<li>互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。</li>
<li>请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li>
<li>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放</li>
<li>环路等待条件：指在发生死锁时，必然存在一个进程资源的环形链。</li>
</ul>
<p><strong>4.处理死锁的基本方法</strong></p>
<ul>
<li><strong>预防死锁：</strong>这是一种较简单和直观的事先预防的方法。方法是通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或者几个，来预防发生死锁。预防死锁是一种较易实现的方法，已被广泛使用。但是由于所施加的限制条件往往太严格，可能会导致系统资源利用率和系统吞吐量降低。</li>
<li><strong>避免死锁：</strong>该方法同样是属于事先预防的策略，但它并不须事先采取各种限制措施去破坏产生死锁的的四个必要条件，而是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。</li>
<li><strong>检测死锁：</strong>这种方法并不须事先采取任何限制性措施，也不必检查系统是否已经进入不安全区，此方法允许系统在运行过程中发生死锁。但可通过系统所设置的检测机构，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源，然后采取适当措施，从系统中将已发生的死锁清除掉。</li>
<li><strong>解除死锁：</strong>这是与检测死锁相配套的一种措施。当检测到系统中已发生死锁时，须将进程从死锁状态中解脱出来。常用的实施方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。</li>
</ul>
<h2 id="8-饥饿"><a href="#8-饥饿" class="headerlink" title="8.饥饿"></a>8.饥饿</h2><p>等待时间给进程推进和响应带来明显影响时成为进程饥饿。<br>饥饿并不代表系统已经死锁，但至少有一个程序的执行被无限期地推迟。<br><strong>与死锁差别：</strong></p>
<ul>
<li>进入饥饿的进程可以只有一个，但是死锁必须大于等于两个；</li>
<li>处于饥饿状态的进程可以是一个就绪进程，但是死锁状态的进程必定是阻塞进程。</li>
</ul>
<h2 id="9-银行家算法"><a href="#9-银行家算法" class="headerlink" title="9.银行家算法"></a>9.银行家算法</h2><p>主要思想是避免系统进入不安全状态，在每次进行资源分配时，它首先检查系统是否有足够的资源满足要求，如果有，则先试行分配，并对分配后的新状态进行安全性检查。如果新状态安全，则正式分配上述资源，否则拒绝分配上述资源。这样就保证系统始终处于安全状态，从而避免死锁现象的发生。</p>
<h2 id="10-死锁定理"><a href="#10-死锁定理" class="headerlink" title="10.死锁定理"></a>10.死锁定理</h2><p>如果资源分配图是可以完全简化的（能消去所有的边），则没有死锁</p>
<h1 id="第三章-内存管理"><a href="#第三章-内存管理" class="headerlink" title="第三章 内存管理"></a>第三章 内存管理</h1><p><img src="https://img2020.cnblogs.com/blog/1358881/202102/1358881-20210216115945604-1204739333.png" alt="img"></p>
<h2 id="1-存储器管理的功能"><a href="#1-存储器管理的功能" class="headerlink" title="1.存储器管理的功能"></a>1.存储器管理的功能</h2><p>存储管理的主要任务是为多道程序的运行提供良好的环境，方便用户使用存储器，提高存储器的利用率以及从逻辑上扩充存储器，故应具有以下功能：</p>
<ul>
<li>内存的分配和回收：实施内存的分配，回收系统或用户释放的内存空间。</li>
<li>地址变换：提供地址变换功能，将逻辑地址转换成物理地址。</li>
<li>扩充内存：借助于虚拟存储技术活其他自动覆盖技术，为用户提供比内存空间大的地址空间，从逻辑上扩充内存。</li>
<li>存储保护：保证进入内存的各道作业都在自己的存储空间内运行，互不干扰。</li>
</ul>
<h2 id="2-将用户程序变为可在内存中执行的程序的步骤"><a href="#2-将用户程序变为可在内存中执行的程序的步骤" class="headerlink" title="2.将用户程序变为可在内存中执行的程序的步骤"></a>2.将用户程序变为可在内存中执行的程序的步骤</h2><ul>
<li>编译：由编译程序将用户源代码编译成若干目标模块</li>
<li>汇编：产生二进制目标文件</li>
<li>链接：产生可执行文件，由链接程序将编译后形成的一组目标模块及所需的库函数链接在一起，形成一个完整的装入模块，形成逻辑地址</li>
<li>装入：将逻辑地址转换为物理地址，由装入程序将装入模块装入内存中运行。</li>
</ul>
<p><img src="https://img2020.cnblogs.com/blog/1358881/202102/1358881-20210216192459401-156747795.png" alt="img"></p>
<h2 id="3-程序的链接方式"><a href="#3-程序的链接方式" class="headerlink" title="3.程序的链接方式"></a>3.程序的链接方式</h2><ul>
<li>静态链接：在程序运行之前，先把各个目标模块及所需库链接为一个完整的可执行程序，以后不再拆开。</li>
<li>装入时动态链接：将应用程序编译后所得到的一组目标模块在装入内存时采用***边装入边链接***的链接方式。</li>
<li>运行时动态链接：知道程序运行过程中需要一些模块时，才对这些模块进行链接。</li>
</ul>
<h2 id="4-程序的装入方式"><a href="#4-程序的装入方式" class="headerlink" title="4.程序的装入方式"></a>4.程序的装入方式</h2><p>凡是分区固定的都会产生内部碎片，分区不固定的会产生外部碎片</p>
<table>
<thead>
<tr>
<th>装入方式</th>
<th>所属步骤</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>静态装入</td>
<td>编制阶段计算好物理地址</td>
<td></td>
</tr>
<tr>
<td>可重定位装入</td>
<td>装入时把逻辑地址转为物理地址，不可改变</td>
<td></td>
</tr>
<tr>
<td>动态重定位装入</td>
<td>执行时再决定装入的地址并装入，装入后可能会换出</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><strong>绝对装入</strong>：在编译时就知道程序将要驻留在内存的物理地址，编译程序产生含有物理地址的目标代码，不适合多道程序设计。</li>
<li><strong>可重定位装入</strong>：根据内存当前情况，将装入模块装入到内存的适当位置，地址变换通常在装入时一次完成，之后不再改变，也称静态重定位。当操作系统为程序分配一个以某地址为起始地址的连续主存区域后，重定位时将程序中指令或操作数的逻辑地址加上这个起始地址就得到了物理地址。</li>
<li><strong>动态运行装入</strong>：允许程序运行时在内存中移动位置，把装入模块装入到内存后的所有地址都是相对地址，在程序执行过程中每当访问到相应指令或数据时，才将要 访问的程序或数据的相对地址转换为物理地址。动态重定位的实现要依靠硬件地址变换机构。</li>
</ul>
<h2 id="5-覆盖技术和交换技术"><a href="#5-覆盖技术和交换技术" class="headerlink" title="5.覆盖技术和交换技术"></a>5.覆盖技术和交换技术</h2><p><strong>1.覆盖技术：</strong><br>把一个大的程序划分为一系列覆盖，每个覆盖是一个相对独立的程序单位，把程序执行时并不要求同时装入内存的覆盖组成一组，成为覆盖段，这个覆盖段分配到同一个存储区域，这个存储区域成为覆盖区，它与覆盖段一一对应。覆盖段的大小由覆盖段中最大的覆盖来确定。（为了解决内存容量太小的问题，打破了必须将一个程序全部信息装入内存后才能运行的限制）<br><strong>2.交换技术：</strong><br>把暂时不用的某个程序及数据部分从内存移到外存中去，以便腾出必要的内存空间；或者把指定的程序或数据从外存读到相应的内存中，并将控制权交给他，让其在系统上运行的一种内存扩充技术。处理器的中级调度就是采用交换技术。<br><strong>3.区别：</strong></p>
<ul>
<li>与覆盖技术相比，交换技术不要求程序员给出的 程序段之间的覆盖结构；</li>
<li>交换技术主要在进程和作业之间进行，覆盖技术主要在同一个进程或作业中进行；交换技术主要在进程和作业之间进行，覆盖技术主要在同一个进程或作业中进行；</li>
<li>覆盖技术只能覆盖于覆盖程序段无关的程序段，交换进程由换出和换入两个过程组成。覆盖技术只能覆盖于覆盖程序段无关的程序段，交换进程由换出和换入两个过程组成。</li>
</ul>
<h2 id="6-内存连续分配管理方式"><a href="#6-内存连续分配管理方式" class="headerlink" title="6.内存连续分配管理方式"></a>6.内存连续分配管理方式</h2><p><strong>1.单一连续分配</strong><br>内存在此方式下分为系统区和用户区，系统区仅提供给操作系统使用，通常在低地址部分；用户区是为用户提供的、除系统区之外的内存空间。这种方式无需进行内存保护。<br>这种方式的优点是简单、无外部碎片，可以釆用覆盖技术，不需要额外的技术支持。缺点是只能用于单用户、单任务的操作系统中，有内部碎片，存储器的利用率极低。<br><strong>2.固定分区分配</strong><br>固定分区分配是最简单的一种多道程序存储管理方式，它将用户内存空间划分为若干个固定大小的区域，每个分区只装入一道作业。当有空闲分区时，便可以再从外存的后备作业队列中,选择适当大小的作业装入该分区，如此循环。固定分区分配在划分分区时，有两种不同的方法。<br>(1) 分区大小相等：用于利用一台计算机去控制多个相同对象的场合，缺乏灵活性。<br>(2) 分区大小不等：划分为含有多个较小的分区、适量的中等分区及少量的大分区。<br><strong>3.动态分区分配</strong><br>动态分区分配又称为可变分区分配，是一种动态划分内存的分区方法。这种分区方法不预先将内存划分，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统中分区的大小和数目是可变的。<br><strong>4.动态分区分配算法</strong><br>在进程装入或换入主存时，如果内存中有多个足够大的空闲块，操作系统必须确定分配哪个内存块给进程使用，这就是动态分区的分配策略，考虑以下几种算法：</p>
<ul>
<li>首次适应(First Fit)算法：空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。</li>
<li>最佳适应(Best Fit)算法：空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区。</li>
<li>最坏适应(Worst Fit)算法：又称最大适应(Largest Fit)算法，空闲分区以容量递减的次序链接。找到第一个能满足要求的空闲分区，也就是挑选出最大的分区。</li>
<li>邻近适应(Next Fit)算法：又称循环首次适应算法，由首次适应算法演变而成。不同之处是分配内存时从上次查找结束的位置开始继续查找。</li>
</ul>
<h2 id="7-基本分页和请求分页内存管理方式"><a href="#7-基本分页和请求分页内存管理方式" class="headerlink" title="7.基本分页和请求分页内存管理方式"></a>7.基本分页和请求分页内存管理方式</h2><ul>
<li><p>在系统中设置一个页表寄存器，它存放着页表在内存中的始址和长度。在进程未执行时，页表的始址和页表长度存放在本进程的PCB中，当调度到某进程时，才将这两个数据装入页表寄存器中。每个进程有一张属于自己的页表</p>
</li>
<li><table>
<thead>
<tr>
<th>名称</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>页，页面</td>
<td>将用户进程的地址空间分成与页框大小相等的区域，划分逻辑空间</td>
</tr>
<tr>
<td>页框，页帧，物理块，内存块，物理页面</td>
<td>将内存空间划分为大小相等的区域，划分物理空间</td>
</tr>
<tr>
<td>页号</td>
<td>页的编号</td>
</tr>
<tr>
<td>页内偏移量</td>
<td>页内地址</td>
</tr>
<tr>
<td>页面大小</td>
<td>指一个页面占有多大的存储空间，决定页内偏移量</td>
</tr>
<tr>
<td>页表大小</td>
<td>页表在内存中占用的大小</td>
</tr>
<tr>
<td>页表长度，页面长度</td>
<td>表示页表中有多少页表项，用来检测页号是否越界</td>
</tr>
<tr>
<td>页表项长度</td>
<td>表示每个页表项占多大的存储空间</td>
</tr>
<tr>
<td>块号</td>
<td>每页在内存中的物理块号</td>
</tr>
</tbody></table>
</li>
</ul>
<p><strong>分段，分页管理的区别</strong></p>
<ul>
<li><p>页是信息的<u>物理单位</u>。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管 理上的需要，完全是系统行为，对用户是不可见的。</p>
<p>段是信息的<u>逻辑单位</u>。分页的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻 辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。 页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。</p>
</li>
<li><p>分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。</p>
<p>分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。</p>
</li>
<li><p>分段比分页更容易实现信息的共享和保护。不能被修改的代码称为纯代码或可重入代码（不属于临 界资源)，这样的代码是可以共享的。可修改的代码是不能共享的</p>
</li>
<li><p>访问一个逻辑地址需要几次访存？</p>
<p>分页（单级页表）：第一次访存一一查内存中的页表，第二次访存一一访问目标内存单元。总共两次 访存</p>
<p>分段：第一次访存一一查内存中的段表，第二次访存一一访问目标内存单元。总共两次访存</p>
<p>与分页系统类似，分段系统中也可以引入决表机构，将近期访问过的段表项放到快表中，这样可以 少一次访问，加快地址变换速度。</p>
</li>
</ul>
<h2 id="8-页面置换算法"><a href="#8-页面置换算法" class="headerlink" title="8.页面置换算法"></a>8.页面置换算法</h2><ul>
<li><strong>最佳（OPT）置换算法：</strong>从主存中移出永远不再需要的页面；如无这样的页面存在，则选择最长时间不需要访问的页面。于所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。 即被淘汰页面是以后永不使用或最长时间内不再访问的页面。</li>
<li><strong>先进先出（FIFO）置换算法：</strong>是最简单的页面置换算法。这种算法的基本思想是：当需要淘汰一个页面时，总是选择驻留主存时间最长的页面进行淘汰，即先进入主存的页面先淘汰。其理由是：最早调入主存的页面不再被使用的可能性最大。 即优先淘汰最早进入内存的页面。（往前看）</li>
<li><strong>最近最久未使用（LRU）算法：</strong>这种算法的基本思想是：利用局部性原理，根据一个作业在执行过程中过去的页面访问历史来推测未来的行为。它认为过去一段时间里不曾被访问过的页面，在最近的将来可能也不会再被访问。所以，这种算法的实质是：当需要淘汰一个页面时，总是选择在最近一段时间内最久不用的页面予以淘汰。 即淘汰最近最长时间未访问过的页面。（往前看）</li>
<li><strong>时钟(CLOCK)置换算法：</strong>LRU算法的性能接近于OPT,但是实现起来比较困难，且开销大；FIFO算法实现简单，但性能差。所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是CLOCK算法的变体。简单的CLOCK算法是给每一帧关联一个附加位，称为使用位。当某一页首次装入主存时，该帧的使用位设置为1;当该页随后再被访问到时，它的使用位也被置为1。对于页替换算法，用于替换的候选帧集合看做一个循环缓冲区，并且有一个指针与之相关联。当某一页被替换时，该指针被设置成指向缓冲区中的下一帧。当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧。每当遇到一个使用位为1的帧时，操作系统就将该位重新置为0；如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换；如果所有帧的使用位均为1,则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。由于该算法循环地检查各页面的情况，故称为CLOCK算法，又称为最近未用(Not RecentlyUsed, NRU)算法。<ul>
<li>(u&#x3D;0, m&#x3D;0) 没有使用也没有修改，被逐出的优先级最高；</li>
<li>(u&#x3D;1, m&#x3D;0) 使用过，但是没有修改过，优先级第二；</li>
<li>(u&#x3D;0, m&#x3D;1) 没有使用过，但是修改过，优先级第三；</li>
<li>(u&#x3D;1, m&#x3D;1) 使用过也修改过，优先级第四。</li>
</ul>
</li>
</ul>
<h2 id="9-页表和快表"><a href="#9-页表和快表" class="headerlink" title="9.页表和快表"></a>9.页表和快表</h2><p>页表指出<strong>逻辑地址中的页号与所占主存块号的对应关系</strong>。</p>
<p>作用：页式存储管理在用动态重定位方式装入作业时，要利用页表做地址转换工作。<strong>快表就是存放在高速缓冲存储器的部分页表。它起页表相同的作用。</strong>由于采用页表做地址转换，读写内存数据时CPU要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p>
<h2 id="10-地址翻译的过程"><a href="#10-地址翻译的过程" class="headerlink" title="10.地址翻译的过程"></a>10.地址翻译的过程</h2><p>TLB-&gt;页表（TLB不命中）-&gt;Cache-&gt;主存（Cache不命中）-&gt;外存</p>
<h1 id="第四章-文件管理"><a href="#第四章-文件管理" class="headerlink" title="第四章 文件管理"></a>第四章 文件管理</h1><p><img src="https://img2020.cnblogs.com/blog/1358881/202102/1358881-20210216200311860-1626798222.png" alt="img"></p>
<h2 id="1-文件的基本操作"><a href="#1-文件的基本操作" class="headerlink" title="1.文件的基本操作"></a>1.文件的基本操作</h2><p>文件属于抽象数据类型。为了恰当地定义文件，就需要考虑有关文件的操作。操作系统提供系统调用，它对文件进行创建、写、读、定位和截断。<br><strong>①创建文件：</strong>创建文件有两个必要步骤，一是在文件系统中为文件找到空间；二是在目录中为新文件创建条目，该条目记录文件名称、在文件系统中的位置及其他可能信息。<br><strong>②写文件：</strong>为了写文件，执行一个系统调用，指明文件名称和要写入文件的内容。对于给定文件名称，系统搜索目录以查找文件位置。系统必须为该文件维护一个写位置的指针。每当发生写操作，便更新写指针。<br><strong>③读文件：</strong>为了读文件，执行一个系统调用，指明文件名称和要读入文件块的内存位置。同样，需要搜索目录以找到相关目录项，系统维护一个读位置的指针。每当发生读操作时，更新读指针。一个进程通常只对一个文件读或写，所以当前操作位置可作为每个进程当前文件位置指针。<br>由于读和写操作都使用同一指针，节省了空间也降低了系统复杂度。<br><strong>④文件重定位（文件寻址）：</strong>按某条件搜索目录，将当前文件位置设为给定值，并且不会读、写文件。<br><strong>⑤删除文件：</strong>先从目录中找到要删除文件的目录项，使之成为空项，然后回收该文件所占用的存储空间。<br><strong>⑥截断文件：</strong>允许文件所有属性不变，并删除文件内容，即将其长度设为0并释放其空间。<br>这6个基本操作可以组合执行其他文件操作。例如，一个文件的复制，可以创建新文件、 从旧文件读出并写入到新文件。</p>
<h2 id="2-磁盘调度算法"><a href="#2-磁盘调度算法" class="headerlink" title="2.磁盘调度算法"></a>2.磁盘调度算法</h2><ul>
<li><strong>1、先来先服务算法（FCFS）First Come First Service：</strong>这是一种比较简单的磁盘调度算法。它根据进程请求访问磁盘的先后次序进行调度。此算法的优点是公平、简单，且每个进程的请求都能依次得到处理，不会出现某一进程的请求长期得不到满足的情况。此算法由于未对寻道进行优化，在对磁盘的访问请求比较多的情况下，此算法将降低设备服务的吞吐量，致使平均寻道时间可能较长，但各进程得到服务的响应时间的变化幅度较小。</li>
<li><strong>2、最短寻道时间优先算法（SSTF） Shortest Seek Time First：</strong>该算法选择这样的进程，其要求访问的磁道与当前磁头所在的磁道距离最近，以使每次的寻道时间最短，该算法可以得到比较好的吞吐量，但却不能保证平均寻道时间最短。其缺点是对用户的服务请求的响应机会不是均等的，因而导致响应时间的变化幅度很大。在服务请求很多的情况下，对内外边缘磁道的请求将会无限期的被延迟，有些请求的响应时间将不可预期。</li>
<li><strong>3、扫描算法（SCAN）电梯调度：</strong>扫描算法不仅考虑到欲访问的磁道与当前磁道的距离，更优先考虑的是磁头的当前移动方向。例如，当磁头正在自里向外移动时，扫描算法所选择的下一个访问对象应是其欲访问的磁道既在当前磁道之外，又是距离最近的。这样自里向外地访问，直到再无更外的磁道需要访问才将磁臂换向，自外向里移动。这时，同样也是每次选择这样的进程来调度，即其要访问的磁道，在当前磁道之内，从而避免了饥饿现象的出现。由于这种算法中磁头移动的规律颇似电梯的运行，故又称为电梯调度算法。此算法基本上克服了最短寻道时间优先算法的服务集中于中间磁道和响应时间变化比较大的缺点，而具有最短寻道时间优先算法的优点即吞吐量较大，平均响应时间较小，但由于是摆动式的扫描方法，两侧磁道被访问的频率仍低于中间磁道。</li>
<li><strong>4、循环扫描算法（CSCAN）：</strong>循环扫描算法是对扫描算法的改进。如果对磁道的访问请求是均匀分布的，当磁头到达磁盘的一端，并反向运动时落在磁头之后的访问请求相对较少。这是由于这些磁道刚被处理，而磁盘另一端的请求密度相当高，且这些访问请求等待的时间较长，为了解决这种情况，循环扫描算法规定磁头单向移动。例如，只自里向外移动，当磁头移到最外的被访问磁道时，磁头立即返回到最里的欲访磁道，即将最小磁道号紧接着最大磁道号构成循环，进行扫描。</li>
</ul>
<h2 id="第五章、输入输出管理"><a href="#第五章、输入输出管理" class="headerlink" title="第五章、输入输出管理"></a>第五章、输入输出管理</h2><p><img src="https://img2020.cnblogs.com/blog/1358881/202102/1358881-20210216200842314-313480643.png" alt="img"></p>
<h2 id="1-I-x2F-O控制方式"><a href="#1-I-x2F-O控制方式" class="headerlink" title="1.I&#x2F;O控制方式"></a>1.I&#x2F;O控制方式</h2><p><strong>1.程序 I&#x2F;O 方式</strong><br>早期的计算机系统中， 没有中断系统，所以CPU和I&#x2F;O设备进行通信，传输数据时CPU速度远快于I&#x2F;O设备，于是CPU需要不断测试I&#x2F;O设备，看其是否完成了传输。</p>
<p><img src="https://img2020.cnblogs.com/blog/1358881/202102/1358881-20210216201310999-404151886.png" alt="img"><br><strong>2.中断驱动方式</strong><br>当某进程要启动某个 I&#x2F;O 设备工作时，便由 CPU 向相应的设备控制器发出一条 I&#x2F;O 命令，然后立即返回继续执行原来的任务。仅当输完一个数据时，才需 CPU 花费极短的时间去做些中断处理。</p>
<p>I&#x2F;O软件一般分为四个层次：用户层，与设备无关的软件层（系统调用的处理程序），设备驱动程序，以及中断处理程序。当用户使用设备时，首先在用户程序发起一次系统调用，操作系统的内核接到该调用请求后请求调用处理程序进行处理，再转到相应的设备驱动程序，当设备准备好或所需的数据到达后设备硬件发出中断，将数据按上述调用顺序逆向回传到用户程序中。</p>
<p>用户程序——系统调用处理程序——设备驱动程序——中断处理程序</p>
<p><img src="https://img2020.cnblogs.com/blog/1358881/202102/1358881-20210216201353793-845472878.png" alt="img"><br><strong>3.DMA方式（直接存储器访问）</strong><br>通过在I&#x2F;O设备和内存之间<strong>开启一个可以直接传输数据的通路</strong>，采用DMA控制器来控制一个数据块的传输，CPU只需在一个数据块传输开始阶段设置好传输所需的控制信息，并在传输结束阶段做进一步处理。</p>
<p><img src="https://img2020.cnblogs.com/blog/1358881/202102/1358881-20210216201414645-2101301826.png" alt="img"><br><strong>4.I&#x2F;O通道控制方式</strong><br>虽然DMA方式比起中断方式来已经显著地减少了CPU的干预，即已由以字（节）为单位的干预减少到以数据块为单位的干预。但CPU每发出一条I&#x2F;O指令，也只能去读&#x2F;写一个连续的数据块。而当我们需要一次去读多个数据块且将它们分别传送到不同的内存区域，或者相反时，则需由CPU分别发出多条I&#x2F;O指令及进行多次中断处理才能完成。</p>
<ul>
<li>通道控制方式与DMA控制方式类似，也是一种以内存为中心，实现设备与内存直接交换数据的控制方式。</li>
<li>与DMA控制方式相比，通道方式所需要的CPU干预更少，而且可以做到一个通道控制多台设 备，从而进一步减轻了CPU负担。</li>
<li>通道本质上是一个简单的处理器，专门负责输入、输出控制，具有执行I&#x2F;O指令的能力，并通过执行通道I&#x2F;O程序来控制I&#x2F;O操作。</li>
<li>通道的指令系统比较简单，一般只有数据传送指令、设备控制指令等。</li>
</ul>
<h3 id="5-Spooling技术"><a href="#5-Spooling技术" class="headerlink" title="5.Spooling技术"></a>5.Spooling技术</h3><p>虚拟性是OS的四大特性之一。如果说可以通过多道程序技术将一台物理CPU虚拟为多台逻辑CPU，从而允许多个用户共享一台主机，那么，<strong>通过SPOOling技术便可将一台物理I&#x2F;O设备虚拟为多台逻辑I&#x2F;O设备，同样允许多个用户共享一台物理I&#x2F;O设备。</strong><br>SPOOLing技术是对脱机输入、输出系统的模拟。相应地，SPOOLing系统必须建立在具有多道程序功能的操作系统上，而且还应有高速随机外存的支持，这通常是采用磁盘存储技术。<br>SPOOLing系统主要有以下三部分：</p>
<ul>
<li>输入井和输出井。这是在磁盘上开辟的两个大存储空间。输入井是模拟脱机输入时的磁盘设备，用于暂存I&#x2F;Q设备输入的数据；输出井是模拟脱机输出时的磁盘，用于暂存用户程序的输出数据。</li>
<li>输入缓冲区和输出缓冲区。为了缓和和CPU和磁盘之间速度不匹配的矛盾，在内存中要开辟两个缓冲区；输入缓冲区和输出缓冲区。输入缓冲区用于暂存由输入设备送来的数据，以后再传送到输入井。输出缓冲区用与暂存从输出井送来的数据，以后在传送给输出设备。</li>
<li>输入进程SPi 和输入进程SP0。这里利用两个进程来模拟脱机I&#x2F;O时的外围控制机。其中，进程SPi模拟脱机输入时的外围控制机，将用户要求的数据从输入机通过输入缓冲区再送到输入井，当CPU需要输入数据时，直接从输入井读入内存；进程SP0模拟脱机输出时的外围控制机，把用户要求输出的数据从先内存送到输出井，待输出设备空闲时，在将输出井中的数据经过输出缓冲区送到输出设备上。</li>
</ul>
<p>SPOOLing技术的特点：</p>
<ul>
<li>提高了I&#x2F;O速度。从对低速I&#x2F;O设备进行的I&#x2F;O操作变为对输入井或输出井的操作，如同脱机操作一样，提高了I&#x2F;O速度，缓和了CPU与低速I&#x2F;O设备速度不匹配的矛盾。</li>
<li>将独占设备改造为共享设备。因为在SPOOLing系统的系统中，实际上并没为任何进程分配设备，而知识在输入井或输出井中为进程分配一个存储区和建立一张I&#x2F;O请求表。这样，便把独占设备改造为共享设备。</li>
<li>实现了虚拟设备功能。多个进程同时使用一独享设备，而对每一进程而言，都认为自己独占这一设备，从而实现了设备的虚拟分配。不过，该设备是逻辑上的设备。</li>
</ul>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>加载评论需要在浏览器启用 JavaScript 脚本支持。</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">第一章 计算机系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9B%AE%E6%A0%87%E5%92%8C%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.</span> <span class="toc-text">1.操作系统的目标和功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.</span> <span class="toc-text">2.操作系统的运行机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="toc-number">1.3.</span> <span class="toc-text">3.中断和异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.4.</span> <span class="toc-text">4.系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%A4%A7%E5%86%85%E6%A0%B8%E5%92%8C%E5%BE%AE%E5%86%85%E6%A0%B8"><span class="toc-number">1.5.</span> <span class="toc-text">5.大内核和微内核</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">第二章 进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">1.进程与线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">2.进程的通信方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%BF%9B%E7%A8%8B%E7%9A%845%E7%A7%8D%E7%8A%B6%E6%80%81%E5%8F%8A%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">3.进程的5种状态及转换过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">4.进程的调度算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%90%8C%E6%AD%A5%E5%92%8C%E4%BA%92%E6%96%A5"><span class="toc-number">2.5.</span> <span class="toc-text">5.同步和互斥</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">2.6.</span> <span class="toc-text">6.进程同步相关概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%AD%BB%E9%94%81"><span class="toc-number">2.7.</span> <span class="toc-text">7.死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E9%A5%A5%E9%A5%BF"><span class="toc-number">2.8.</span> <span class="toc-text">8.饥饿</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-number">2.9.</span> <span class="toc-text">9.银行家算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E6%AD%BB%E9%94%81%E5%AE%9A%E7%90%86"><span class="toc-number">2.10.</span> <span class="toc-text">10.死锁定理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">第三章 内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">3.1.</span> <span class="toc-text">1.存储器管理的功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B0%86%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E5%8F%98%E4%B8%BA%E5%8F%AF%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%89%A7%E8%A1%8C%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.2.</span> <span class="toc-text">2.将用户程序变为可在内存中执行的程序的步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">3.程序的链接方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A3%85%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">3.4.</span> <span class="toc-text">4.程序的装入方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF"><span class="toc-number">3.5.</span> <span class="toc-text">5.覆盖技术和交换技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%86%85%E5%AD%98%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">3.6.</span> <span class="toc-text">6.内存连续分配管理方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%92%8C%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">3.7.</span> <span class="toc-text">7.基本分页和请求分页内存管理方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">3.8.</span> <span class="toc-text">8.页面置换算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E9%A1%B5%E8%A1%A8%E5%92%8C%E5%BF%AB%E8%A1%A8"><span class="toc-number">3.9.</span> <span class="toc-text">9.页表和快表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">3.10.</span> <span class="toc-text">10.地址翻译的过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">第四章 文件管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.</span> <span class="toc-text">1.文件的基本操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">2.磁盘调度算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86"><span class="toc-number">4.3.</span> <span class="toc-text">第五章、输入输出管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-I-x2F-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">4.4.</span> <span class="toc-text">1.I&#x2F;O控制方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Spooling%E6%8A%80%E6%9C%AF"><span class="toc-number">4.4.1.</span> <span class="toc-text">5.Spooling技术</span></a></li></ol></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://xxsy613.github.io/2023/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://xxsy613.github.io/2023/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/&text=操作系统_大纲"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://xxsy613.github.io/2023/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/&title=操作系统_大纲"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://xxsy613.github.io/2023/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/&is_video=false&description=操作系统_大纲"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=操作系统_大纲&body=Check out this article: http://xxsy613.github.io/2023/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://xxsy613.github.io/2023/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/&title=操作系统_大纲"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://xxsy613.github.io/2023/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/&title=操作系统_大纲"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://xxsy613.github.io/2023/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/&title=操作系统_大纲"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://xxsy613.github.io/2023/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/&title=操作系统_大纲"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://xxsy613.github.io/2023/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/&name=操作系统_大纲&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://xxsy613.github.io/2023/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/&t=操作系统_大纲"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2022-2023
    潇湘水云
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'xxsy';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>

<!-- utterances Comments -->

</body>
</html>
