<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>水云的博客</title>
  
  <subtitle>计算机在读小白</subtitle>
  <link href="http://xxsy613.github.io/atom.xml" rel="self"/>
  
  <link href="http://xxsy613.github.io/"/>
  <updated>2023-10-30T07:43:23.801Z</updated>
  <id>http://xxsy613.github.io/</id>
  
  <author>
    <name>潇湘水云</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://xxsy613.github.io/2023/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://xxsy613.github.io/2023/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/</id>
    <published>2023-10-30T07:03:11.019Z</published>
    <updated>2023-10-30T07:43:23.801Z</updated>
    
    <content type="html"><![CDATA[<p>整理自<a href="https://www.cnblogs.com/wkfvawl/p/13207411.html)%EF%BC%8C%E4%BB%85%E7%A7%81%E7%94%A8">https://www.cnblogs.com/wkfvawl/p/13207411.html)，仅私用</a></p><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h3><p>数据通信</p><p>资源共享</p><p>分布式处理</p><p>提高可靠性</p><p>负载均衡</p><p>计算机网络采用的两类通信方式：客户-服务器方式（C&#x2F;S）和对等连接方式（P2P）</p><p>电路交换特点：</p><p>通信前要先建立连接，通信完毕后释放连接。一定要有三个阶段：建立连接、通信、释放连接。</p><p>通信过程中，通信双方自始至终占用着所使用的物理信道。</p><p>分组交换特点：</p><p>分解交换采用存储转发技术，把报文划分为几个分组后再进行传送，没有建立连接和释放连接阶段。</p><p>报文交换特点</p><p>报文交换也采用存储转发技术，但报文交换不再把报文分隔为更小的分组，而是把整个报文在网络的结点中存储下来，然后再转发出去。</p><h3 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h3><p><strong>按分布范围分类</strong></p><p>广域网（WAN）</p><p>城域网（MAN）</p><p>局域网(LAN)</p><p>个人区域网(PAN)</p><p><strong>按网络的使用者分类</strong></p><p>公用网（public network）</p><p>专用网（private network）</p><p><strong>按交换技术分类</strong></p><p>电路交换网络</p><p>报文交换网络</p><p>分组交换网络</p><h3 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h3><p>1、速率</p><p>速率是计算机网络中最重要的一个性能指标，指的是数据的传送速率，它也称为数据率 (data rate) 或比特率 (bit rate)。<br>速率的单位是 bit&#x2F;s，或 kbit&#x2F;s、Mbit&#x2F;s、 Gbit&#x2F;s等。<br>速率往往是指额定速率或标称速率，非实际运行速率。  </p><p>2、带宽</p><p>在计算机网络中，带宽用来表示网络中某通道传送数据的能力。表示在单位时间内网络中的某信道所能通过的“最高数据率”。单位是 bit&#x2F;s，即 “比特每秒”。   </p><p>3、吞吐量</p><p>吞吐量 (throughput) 表示在单位时间内通过某个网络（或信道、接口）的数据量。<br>吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。<br>吞吐量受网络的带宽或网络的额定速率的限制。  </p><p>4、时延</p><p>时延 (delay 或 latency) 是指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。<br>有时也称为延迟或迟延。<br>网络中的时延由以下几个不同的部分组成：</p><p>发送时延<br>也称为传输时延。<br>发送数据时，数据帧从结点进入到传输媒体所需要的时间。<br>也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。<br><img src="https://img2020.cnblogs.com/blog/1358881/202006/1358881-20200629124250455-701484165.png" alt="img"></p><p>传播时延<br>电磁波在信道中需要传播一定的距离而花费的时间。<br>发送时延与传播时延有本质上的不同。<br>信号发送速率和信号在信道上的传播速率是完全不同的概念。<br><img src="https://img2020.cnblogs.com/blog/1358881/202006/1358881-20200629124318800-75451875.png" alt="img"></p><p>处理时延<br>主机或路由器在收到分组时，为处理分组（例如分析首部、提取数据、差错检验或查找路由）所花费的时间。</p><p>排队时延<br>分组在路由器输入输出队列中排队等待处理所经历的时延。<br>排队时延的长短往往取决于网络中当时的通信量。</p><h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><h4 id="网络协议主要的三个要素"><a href="#网络协议主要的三个要素" class="headerlink" title="网络协议主要的三个要素"></a>网络协议主要的三个要素</h4><p>1）、语法</p><p>即数据与控制信息的结构或格式</p><p>2）、语义</p><p>即需要发出何种控制信息，完成何种动作以及做出何种相应</p><p>3）、同步</p><p>即事件实现顺序的详细说明</p><h4 id="协议和服务关系"><a href="#协议和服务关系" class="headerlink" title="协议和服务关系"></a>协议和服务关系</h4><p>1、协议的实现保证了能够向上一层提供服务。本层的服务用户只能看见服务而无法看见下面的协议。下面的协议对上面的服务用户是透明的。<br>2、协议是“水平的”，即协议是控制两个对等实体进行通信的规则。但服务是“垂直的”，即服务是由下层通过层间接口向上层提供的。</p><p><strong>网络结构分层好处</strong></p><p>各层之间是独立的。灵活性好。结构上可分割开。易于实现和维护。能促进标准化工作。<br><strong>网络分层缺点</strong></p><p>降低效率。有些功能会在不同的层次中重复出现，因而产生了额外开销。</p><p>3、具有五层协议的体系结构<br>OSI 的七层协议体系结构的概念清楚，理论也较完整，但它既复杂又不实用。<br>TCP&#x2F;IP 是四层体系结构：应用层、运输层、网际层和网络接口层。<br>但最下面的网络接口层并没有具体内容。<br>因此往往采取折中的办法，即综合 OSI 和 TCP&#x2F;IP 的优点，采用一种只有五层协议的体系结构 。<br><img src="https://img2020.cnblogs.com/blog/1358881/202006/1358881-20200629110234036-827625287.png" alt="img"></p><p> 五层协议：应用层、运输层、网络层、数据链路层、物理层。</p><p>运输层最重要的协议是TCP和UDP协议，而网络层最重要的协议是IP协议。</p><h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p>1-10</p><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200702001407610-450869135.png" alt="img"></p><p> <img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200702001444970-1188050341.png" alt="img"></p><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200702001511176-919239232.png" alt="img"></p><p> <img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200702001554430-1613078558.png" alt="img"></p><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200702001633220-1636594621.png" alt="img"></p><h2 id="二、物理层"><a href="#二、物理层" class="headerlink" title="二、物理层"></a>二、物理层</h2><h3 id="通信的三种基本方式"><a href="#通信的三种基本方式" class="headerlink" title="通信的三种基本方式"></a><strong>通信的三种基本方式</strong></h3><p>单向通信：又称单工通信，即一个方向的通信没有反方向。如无线广播或有线电视广播。</p><p>双向交替通信：又称半双工通信，即通信双方都可以发送信息，但不能同时发送（当然也就不能同时接受）。步话机，早期集线器。</p><p>双向同时通信：又称全双工通信，即通信的双方都可以同时发送和接受信息。</p><h3 id="物理层特点"><a href="#物理层特点" class="headerlink" title="物理层特点"></a>物理层特点</h3><p>物理层要解决的问题，物理层的主要特点？</p><p>物理层要解决的主要问题：<br>物理层考虑的是怎样才能连接各种计算机的传输媒体上传输数据比特流，而不是具体的传输媒体。物理层要尽可能地屏蔽掉物理设备和传输媒体，通信手段的不同，使数据链路层感觉不到这些差异，只考虑完成本层的协议和服务。<br>物理层的主要特点：</p><p>机械特性</p><p>电气特性</p><p>功能特性</p><p>过程特性</p><h3 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h3><p>可分为两大类</p><p>导引型传输媒体（双绞线、同轴电缆、光纤）</p><p>非导引型传输媒体（无线、微波、卫星通信）</p><h3 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h3><p>为什么使用信道复用技术？常用的信道复用技术有哪些？</p><p>为了通过共享信道、最大限度提高信道利用率。频分、时分、码分、波分。</p><h3 id="码分复用CDM"><a href="#码分复用CDM" class="headerlink" title="码分复用CDM"></a>码分复用CDM</h3><p><strong>码分多址CDMA</strong></p><p>令向量 S 表示站 S 的码片向量，令 T 表示其他任何站的码片向量。<br>两个不同站的码片序列正交，就是向量 S 和T 的规格化内积 (inner product) 等于 0：<br><strong><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200702090531291-1744170181.png" alt="img"></strong></p><p>任何一个码片向量和该码片向量自己的规格化内积都是 1 。<br>一个码片向量和该码片反码的向量的规格化内积值是 –1。</p><p>2-16<br><strong><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200702090626475-87551512.png" alt="img"></strong></p><h3 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h3><h4 id="ADSL技术"><a href="#ADSL技术" class="headerlink" title="ADSL技术"></a>ADSL技术</h4><p>非对称数字用户线ADSL</p><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200702003744785-1981994510.png" alt="img"></p><h4 id="光纤同轴混合网HFC"><a href="#光纤同轴混合网HFC" class="headerlink" title="光纤同轴混合网HFC"></a>光纤同轴混合网HFC</h4><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200702090852911-1016849588.png" alt="img"></p><h3 id="试比较ADSL、HFC以及FTTx接入技术的优缺点？"><a href="#试比较ADSL、HFC以及FTTx接入技术的优缺点？" class="headerlink" title="试比较ADSL、HFC以及FTTx接入技术的优缺点？"></a>试比较ADSL、HFC以及FTTx接入技术的优缺点？</h3><p>答：使用ADSL技术最大的好处就是可以利用现有电话网中的用户线，不需要重新布线。成本低，易实现。缺点就是对用户线的质量有较高的要求，如果用户住宅距离电话交换局较远，或线路的噪声较大，那么宽带接入的速率就会适当地降低。</p><p>HFC网的最大的优点具有很宽的频带，并且能够利用已经有相当大的覆盖面的有线电视网。缺点是必须对现有的单向传输的有线电缆进行改造，变为可双向通信的电缆。FTTx（光纤到……）光纤接入是解决宽带接入最理想的方案，可提供最好的带宽和质量、但现阶段线路和工程成本太大。</p><h3 id="奈氏准则和香农公式"><a href="#奈氏准则和香农公式" class="headerlink" title="奈氏准则和香农公式"></a>奈氏准则和香农公式</h3><p>比特&#x2F;s和码元&#x2F;s的关系</p><p>比特&#x2F;s是信息传输速率的单位码元传输速率也称为调制速率、波形速率或符号速率。一个码元不一定对应于一个比特。在二进制编码时一个码元对应一个比特，根据编码的不同，一个码元可以对应于几个比特，但也可以是几个码元对应于一个比特。</p><p>从概念上讲，限制码元在信道上的传输速率的因素有以下两个：<br><strong>信道能够通过的频率范围</strong><br><strong>信噪比</strong></p><p>1924 年，奈奎斯特 (Nyquist) 就推导出了著名的奈氏准则。他给出了在假定的理想条件下，为了避免码间串扰，<strong>码元的传输速率的上限值</strong>。<br>奈氏准则给出了码元传输速率的限制，但并没有对信息传输速率给出限制。</p><p>信噪比就是信号的平均功率和噪声的平均功率之比。常记为S&#x2F;N，并用分贝 (dB) 作为度量单位。即：<br><strong>信噪比(dB) &#x3D; 10 log10(S&#x2F;N ) (dB)</strong><br>例如，当S&#x2F;N&#x3D;10时，信噪比为10dB，而当S&#x2F;N&#x3D;1000时，信噪比为30dB。</p><p>信噪比是否可以任意提高？</p><p>在实际的传输环境中，信噪比不可能做到任意大。一方面，我们的信号功率是受限的（经济问题、器件问题、材料的绝缘问题等等），而任何电子设备的噪声也不能做到任意小</p><p>（任何电子设备都有其固有噪声），因此在实际传输环境中，信噪比不可能做到任意大。</p><p>1984年，香农 (Shannon) 用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的<strong>极限、无差错</strong>的信息传输速率（香农公式）。<br>信道的极限信息传输速率 C 可表达为：<br>     <strong>C &#x3D; W log2(1+S&#x2F;N)  (bit&#x2F;s)</strong><br>其中：W 为信道的带宽（以 Hz 为单位）；<br>   S 为信道内所传信号的平均功率；<br>   N 为信道内部的高斯噪声功率。</p><p>香农公式表明</p><p><strong>信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。</strong><br><strong>只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。</strong><br>若信道带宽 W 或信噪比 S&#x2F;N 没有上限（当然实际信道不可能是这样的），则信道的极限信息传输速率 C 也就没有上限。<br>实际信道上能够达到的信息传输速率要比香农的极限传输速率低不少</p><p>2-07</p><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200702084946171-1558523706.png" alt="img"></p><p> 2-09<img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200702085707019-864492942.png" alt="img"></p><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200702085826625-424728247.png" alt="img"></p><h2 id="三、数据链路层"><a href="#三、数据链路层" class="headerlink" title="三、数据链路层"></a>三、数据链路层</h2><p>数据链路(即逻辑链路)与链路(即物理链路)有何区别? “电路接通了”与”数据链路接通了”的区别何在?        </p><p><strong>链路（即物理链路）</strong>是从一个结点到相邻结点的一段物理线路，<strong>数据链路</strong>则是在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）。</p><p>“电路接通了”表示链路两端的结点交换机已经开机，物理连接已经能够传送比特流了，但是，数据传输并不可靠，在物理连接基础上，再建立数据链路连接，才是“数据链路接通了”，此后，由于数据链路连接具有检测、确认和重传功能，才使不太可靠的物理链路变成可靠的数据链路，进行可靠的数据传输。当数据链路断开连接时，物理电路连接不一定跟着断开连接。</p><p>数据链路层使用的信道主要有一下两种类型</p><p>（1）点对点信道</p><p>（2）广播信道</p><h3 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h3><p>数据链路层传送的协议数据单位是帧，三个基本问题是封装成帧、透明传输和差错检查</p><h3 id="循环冗余校验CRC"><a href="#循环冗余校验CRC" class="headerlink" title="循环冗余校验CRC"></a>循环冗余校验CRC</h3><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200702143009191-2030801121.png" alt="img"></p><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200702144922699-1808636625.png" alt="img"></p><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200702144958597-327866762.png" alt="img"></p><h3 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h3><p><strong>PPP协议特点</strong></p><p>简单 —— 这是首要的要求。<br>封装成帧 —— 必须规定特殊的字符作为帧定界符。<br>透明性 —— 必须保证数据传输的透明性。<br>多种网络层协议 —— 能够在同一条物理链路上同时支持多种网络层协议。<br>多种类型链路 —— 能够在多种类型的链路上运行。<br>差错检测 —— 能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。</p><p>PPP协议不使用帧编号，因为帧的编号是为了出错时可以有效地重传，而PPP并不需要实现可靠传输。</p><p>PPP适用于线路质量并不太差的情况下。如果通信线路太差，传输就会频频出错。但PPP又没有编号和确认机制，这样就必须靠上层的协议才能保证数据传输的正确无误。这样就使数据的传输效率降低。</p><h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><p>局域网的主要特点是什么？为什么局域网采用广播通信方式而广域网不采用呢？</p><p>局域网最主要的特点是：网络为一个单位所拥有，且地理范围和站点数目均有限。在局域网刚刚出现时，局域网比广域网具有更高的数据率，更低的时延和更小的误码率。但随着光纤技术在广域网中普遍使用，现在广域网也具有很高的数据率和很低的误码率。</p><p>局域网的地理范围较小，且为一个单位所拥有，采用广播通信方式十分简单方便。但广域网地理范围很大，如果采用广播通信方式势必造成通信资源的极大浪费，因此广域网不采用广播通信方式。</p><h3 id="网络适配器"><a href="#网络适配器" class="headerlink" title="网络适配器"></a>网络适配器</h3><p>网络适配器的作用是什么?网络适配器工作在哪一层?</p><p>适配器（即网卡）来实现数据链路层和物理层这两层的协议的硬件和软件网络适配器工作在TCP&#x2F;IP协议中的网络接口层（OSI中的数据链路层和物理层）</p><h3 id="以太网交换机"><a href="#以太网交换机" class="headerlink" title="以太网交换机"></a>以太网交换机</h3><p>自学习功能</p><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200702153519552-1498648832.png" alt="img"></p><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200702154609841-1747593580.png" alt="img"></p><p> 3-30</p><p>某学院的以太网交换机有三个接口分别和学院三个系的以太网相连，另外三个接口分别和电子邮件服务器、万维网服务器以及一个连接互联网的路由器相连。图中的ABC都是100Mbit&#x2F;s以太网交换机。假定所有的链路的速率都是100Mbit&#x2F;s，并且图中的9台主机中的任何一个都可以和任何一个服务器或主机通信。试计算这9台主机和两个服务器产生的总的吞吐量的最大值。为什么？<br>答：这里的9台主机和两个服务器都工作时的总吞吐量是900+200&#x3D;1100Mbit&#x2F;s。三个系各有一台主机分别访问两个服务器和通过路由器上网。其他主机在系内通信。</p><p>3-31假定所有的链路的速率都是100Mbit&#x2F;s，但三个系的以太网交换机都换成100Mbit&#x2F;s的集线器。试计算这9台主机和两个服务器产生的总的吞吐量的最大值。为什么？<br>答：这里的每个系是一个碰撞域，其最大吞吐量为100 Mbit&#x2F;s，总吞吐量是300+200&#x3D;500 Mbit&#x2F;s。</p><p>3-32假定所有的链路的速率都是100Mbit&#x2F;s，但所有的以太网交换机都换成100Mbit&#x2F;s的集线器。试计算这9台主机和两个服务器产生的总的吞吐量的最大值。为什么？<br>答：现在整个系统是一个碰撞域，因此其最大吞吐量为100 Mbit&#x2F;s。</p><p>3-34</p><p>有两台主机A和B接在800m长的电缆线的两端，并在t&#x3D;0时各自向对方发送一个帧，长度为1500bit（包括首部和前同步码）。假定在A和B之间有4个转发器，在转发帧时会产生20比特的时延。设传输速率为100 Mbit&#x2F;s，而CSMA&#x2F;CD的退避时间是随机数r倍的争用期，争用期为512bit，在发生第一次碰撞后，在退避时A选择r&#x3D;0而B选择r&#x3D;1。忽略发生碰撞后的人为干扰信号和帧间最小间隔。<br>（1）设信号的传播速率是2×108m&#x2F;s。试计算从A到B（包括4个转发器）的传播时延。<br>（2）在什么时间（以秒为单位）B完全收到了A发送的帧？<br>（3）现在假定只有A发送帧，帧长仍为1500bit，但4个转发器都用交换机来代替。交换机在进行存储转发时还要产生额外的20bit的处理时延。在什么时间B完全收到了A发送的帧？</p><p>答：</p><p>（1）从A到B（包括4个转发器）的传播时延<br>&#x3D;800m&#x2F;（2×108m&#x2F;s)+4×20bit&#x2F;（100×106bit&#x2F;s)&#x3D;4.8µs<br>（2）</p><p>在t&#x3D;2.4us时，电缆中间发生碰撞<br>在t&#x3D;4.8µs时，A和B都检测出碰撞。A立即停止发送数据并等待一个端到端的传播时间4.8us,然后A退避零个争用期故直接发送数据，当A最后一个数据到达B时总共花费4.8us(AB检测到碰撞)+4.8us（等待信道清空）+1500&#x2F;(100<em>10^6)（传输帧的时间）+4.8us（传输时延）&#x3D;29.4us<br>（3）数据到达交换机要进行存储转发，即每个交换机发送一次数据，加上初始端的发送一共发送了五次数据，即发送时延为5</em>1500&#x2F;(100*10^6)&#x3D;75us 加上4.8us的传播时延，所以79.8us后B才能完全受到A发送的帧</p><h2 id="四、网络层"><a href="#四、网络层" class="headerlink" title="四、网络层"></a>四、网络层</h2><p>网络层提供的两种服务</p><p>1、面向连接服务（或虚电路服务）</p><p>2、无连接服务（或数据报服务）</p><h2 id><a href="#" class="headerlink" title></a><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200702190919708-1367801805.png" alt="img"></h2><p>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，也就是说，所传送的分组可能出错、丢失、重复和失序（即不按序到达终点）</p><h3 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h3><p>网际协议IP：使用IP协议就可以把互连以后的计算机网络看成是一个虚拟互连网络，使参与互连的性能各异的网络从用户看起来好像是一个统一的网络。网际协议IP是TCP&#x2F;IP体系中两个最主要的协议之一，与IP协议配套使用的还有四个协议。</p><p>地址解析协议ARP：用来把一个机器（主机或路由器）的IP地址转换为相应的物理地址（或硬件地址）</p><p>逆地址解析协议RARP：和ARP相反，用来把一个机器（主机或路由器）的物理地址（或硬件地址）转换为相应的IP地址。</p><p>网际控制报文协议ICMP：用来使主机或路由器报告差错情况或提供有关异常情况的报告，这样就可以更有效地转发IP数据报和提高交付成功的机会。</p><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200702191744270-1575916622.png" alt="img"></p><p>A类地址：网络字段号为1字节，最前面的1位是0</p><p>B类地址：网络字段号为2字节，最前面的2位是10</p><p>C类地址：网络字段号为3字节，最前面的3位是110</p><p>D类地址：用于多播，最前面的4位是1110</p><p>E类地址：保留今后使用，最前面的4位是1111</p><p>IP地址特点：</p><p>（1）每一个IP地址都由网络号和主机号两部分组成。从这个意义上说，IP地址是一种分等级的地址结构。</p><p>（2）实际上IP地址是一种标记一个主机（或路由器）和一条链路的接口。换言之，IP地址并不仅仅指明一个主机，还指明了主机所连接到的网络。</p><p>（3）按照互联网的观点，一个网络是指具有相同网络号net-id的主机的机会，因此，用转发器或网桥连接起来的若干个局域网仍为一个网络，因为这些局域网具有同样的网络号。具有不同网络号的局域网必须使用路由器进行互连。</p><p>（4）在IP地址中，所有分配到网络号的网络（不管是范围很小的局域网，还是可能覆盖很大地理范围的广域网）都是平等的。</p><h4 id="IP地址与硬件地址（MAC地址）的区别"><a href="#IP地址与硬件地址（MAC地址）的区别" class="headerlink" title="IP地址与硬件地址（MAC地址）的区别"></a>IP地址与硬件地址（MAC地址）的区别</h4><p>物理地址是数据链路层和物理层使用的地址，而IP地址是网络层和以上各层使用的地址，是一种逻辑地址。</p><h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200702225344805-891037092.png" alt="img"></p><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200702225356160-526332028.png" alt="img"></p><p> <img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200702225418971-895391902.png" alt="img"></p><p> <strong>默认子网掩码中1的位置和IP地址中的网络号字段net-id正好对应</strong></p><p><strong>注意：根据之前的RFC 950文档子网号不能全为1或0，但随着无分类域间路由选择CIDR的广泛使用，现在全1和全0的子网号也可以使用了。</strong></p><p><strong>4-09</strong></p><p>（1）子网掩码为255.255.255.0代表什么意思？<br>答：有三种含义：<br>其一是一个A类网的子网掩码，对于A类网络的IP地址，前8位表示网络号，后24位表示主机号，使用子网掩码255.255.255.0表示前8位为网络号，中间16位用于子网段的划分，最后8位为主机号。<br>第二种情况为一个B类网，对于B类网络的IP地址，前16位表示网络号，后16位表示主机号，使用子网掩码255.255.255.0表示前16位为网络号，中间8位用于子网段的划分，最后8位为主机号。<br>第三种情况为一个C类网，这个子网掩码为C类网的默认子网掩码。</p><p>（2）一网络的现在掩码为255.255.255.248，问该网络能够连接多少个主机？<br>答：255.255.255.248即11111111.11111111.11111111.11111000。</p><p>掩码位数29，每一个子网上的主机为(2^3)&#x3D;8台<br>理论上该网络能够连接8个主机，但是扣除全1和全0的情况后，该网络实际上能够连接6个主机。</p><p>（3）一A类网络和一B网络的子网号subnet-id分别为16个1和8个1，问这两个子网掩码有何不同？<br>答：A类网络：11111111 11111111  11111111  00000000<br>给定子网号（16位“1”）则子网掩码为255.255.255.0<br>B类网络：11111111  11111111 11111111  00000000<br>给定子网号（8位“1”）则子网掩码为255.255.255.0<br>可见这两个网络的子网掩码一样，但它们的子网数目不同。</p><p>（4）一个B类地址的子网掩码是255.255.240.0。试问在其中每一个子网上的主机数最多是多少？<br>答：IP地址的第3个字节是（240）10&#x3D;（128+64+32+16）10&#x3D;（11110000）2<br>B类地址的子网掩码是：11111111.11111111.11110000.00000000<br>主机号的位数为4+8&#x3D;12，因此，最大主机数为：2^12-2&#x3D;4096-2&#x3D;4094个。</p><p>（5）一A类网络的子网掩码为255.255.0.255；它是否为一个有效的子网掩码？<br>答：A类网络的子网掩码为11111111 11111111 00000000 11111111<br>他是一个有效的子网掩码，但不推荐这样使用，因为子网中的1不是连续的。</p><p>（6）某个IP地址的十六进制表示C2.2F.14.81，试将其转化为点分十进制的形式。这个地址是哪一类IP地址？<br>答： C2  2F 14 81&#x3D;(12<em>16+2).(2</em>16+15).(16+4).(8*16+1)&#x3D;194.47.20.129<br>  C2 2F 14 81&#x3D;11000010.00101111.00010100.10000001<br>  前3位是110，所以这个地址是C类地址。</p><p>（7）C类网络使用子网掩码有无实际意义？为什么？<br>答：有实际意义。C类子网IP地址的32位中，前24位用于确定网络号，后8位用于确定主机号。如果划分子网，可以选择后8位中的高位，这样做可以进一步划分网络，并且不增加路由表的内容，但是代价是主机数量减少。</p><p><strong>4-20</strong><br>设某路由器建立了如下路由表：<br>目的网络      子网掩码       下一跳<br>128.96.39.0    255.255.255.128   接口m0<br>128.96.39.128  255.255.255.128   接口m1<br>128.96.40.0    255.255.255.128    R2<br>192.4.153.0    255.255.255.192    R3<br>*（默认）         ——        R4</p><p> 现共收到5个分组，其目的地址分别为：<br>（1）128.96.39.10<br>（2）128.96.40.12<br>（3）128.96.40.151<br>（4）192.4.153.17<br>（5）192.4.153.90<br>试分别计算其下一跳。</p><p>答：（1）分组的目的站IP地址为：128.96.39.10。先与子网掩码255.255.255.128相与，得128.96.39.0，可见该分组经接口m0转发。<br>    （2）分组的目的IP地址为：128.96.40.12。<br>① 与子网掩码255.255.255.128相与得128.96.40.0，不等于128.96.39.0。<br>② 与子网掩码255.255.255.128相与得128.96.40.0，经查路由表可知，该项分组经R2转发。<br>    （3）分组的目的IP地址为：128.96.40.151，与子网掩码255.255.255.128相与后得128.96.40.128，与子网掩码255.255.255.192相与后得128.96.40.128，经查路由表知，该分组转发选择默认路由，经R4转发。<br>    （4）分组的目的IP地址为：192.4.153.17。与子网掩码255.255.255.128相与后得192.4.153.0。与子网掩码255.255.255.192相与后得192.4.153.0，经查路由表知，该分组经R3转发。<br>    （5）分组的目的IP地址为：192.4.153.90，与子网掩码255.255.255.128相与后得192.4.153.0。与子网掩码255.255.255.192相与后得192.4.153.0，经查路由表知，该分组转发选择默认路由，经R4转发。</p><h3 id="网络前缀"><a href="#网络前缀" class="headerlink" title="网络前缀"></a>网络前缀</h3><p>CIDR 把网络前缀都相同的连续的 IP 地址组成“CIDR 地址块”。<br>128.14.32.0&#x2F;20 表示的地址块共有 212 个地址（因为斜线后面的 20 是网络前缀的位数，所以这个地址的主机号是 12 位）。<br>这个地址块的起始地址是 128.14.32.0。<br>在不需要指出地址块的起始地址时，也可将这样的地址块简称为“&#x2F;20 地址块”。<br>128.14.32.0&#x2F;20 地址块的最小地址：128.14.32.0<br>128.14.32.0&#x2F;20 地址块的最大地址：128.14.47.255<br>全 0 和全 1 的主机号地址一般不使用。</p><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200702235129154-997978455.png" alt="img"></p><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200702235207164-746924289.png" alt="img"></p><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200702235255369-94686622.png" alt="img"></p><h3 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h3><p>路由器收到相邻路由器（其地址为 X）的一个 RIP 报文：<br>(1) 先修改此 RIP 报文中的所有项目：把“下一跳”字段中的地址都改为 X，并把所有的“距离”字段的值加 1。<br>(2) 对修改后的 RIP 报文中的每一个项目，重复以下步骤：<br>   若项目中的目的网络不在路由表中，则把该项目加到路由表中。<br>     否则<br>       若下一跳字段给出的路由器地址是同样的，则把收到的项目替换原路由表中的项目。<br>        否则<br>          若收到项目中的距离小于路由表中的距离，则进行更新，<br>     否则，什么也不做。<br>(3) 若 3 分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达路由器，即将距离置为 16（表示不可达）。<br>(4) 返回。</p><p><strong>4-41</strong></p><p> 假定网络中的路由器B的路由表有如下的项目（这三列分别表示“目的网络”、“距离”和“下一跳路由器”）<br>         N1    7    A<br>         N2    2    B<br>         N6    8    F<br>         N8    4    E<br>         N9    4    F<br>现在B收到从C发来的路由信息（这两列分别表示“目的网络”“距离”）：<br>         N2    4<br>         N3    8<br>         N6    4<br>         N8    3<br>         N9    5<br>试求出路由器B更新后的路由表（详细说明每一个步骤）。<br> 答：先把收到的路由信息中的“距离”加1：<br>         N2    5<br>         N3    9<br>         N6    5<br>         N8    4<br>         N9    6<br> 路由器B更新后的路由表如下：<br>         N1    7     A　　　　无新信息，不改变<br>         N2    5    C　　　　相同的下一跳，更新<br>         N3    9    C　　　　新的项目，添加进来<br>         N6    5    C　　　　不同的下一跳，距离更短，更新<br>         N8    4    E　　　　不同的下一跳，距离一样，不改变<br>         N9    4    F　　　　不同的下一跳，距离更大，不改变</p><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>从IPV4过渡到IPV6的方法有哪些？</p><p>答：由于现在整个互联网上使用IPV4的路由器数量太大，向IPV6过渡只能采用逐步演进的办法，同时，还必须使新安装的IPV6系统能够向后兼容。</p><p>下面介绍两种向IPV6过渡的策略，即使用<strong>双协议栈</strong>和<strong>隧道技术</strong>。<br>双协议栈是指在完全过渡到IPV6之前，使一部分主机装有两个协议栈，因此双协议栈主机既能够和IPV6的系统通信，又能够和IPV4的系统通信。<br>隧道技术的要点是在IPV6数据报要进入IPV4网络时，把IPV6数据报封装成为IPV4数据报。然后，IPV6数据报就在IPV4网络的隧道中传输。当IPV4数据报离开IPV4网络中的隧道时再把数据部分交给主机的IPV6协议栈。</p><h2 id="五、运输层"><a href="#五、运输层" class="headerlink" title="五、运输层"></a>五、运输层</h2><h3 id="进程之间的通信"><a href="#进程之间的通信" class="headerlink" title="进程之间的通信"></a>进程之间的通信</h3><p>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。</p><p><strong>从网络层来说，通信的两端是两台主机。</strong>IP数据报的首部明确标志了这两台主机的IP地址。但“两个主机之间的通信”这种说法还不够清楚。这是因为，真正进行通信的实体是在主机中的进程，是这个主机中的一个进程和另一个主机中的一个进程在交换数据（即通信）。因此严格来说，<strong>两个主机进行通信就是两个主机中的应用进程相互通信</strong>。IP协议虽然能把分组送到目的主机，但是这个分组还停留在主机的网络层而没有交付给主机的应用进程。<strong>从运输层的角度看，通信的真正端点并不是主机而是主机的进程。</strong>也就是说，端到端的通信时应用进程之间的通信。因此，运输层是必不可少的。</p><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200703150042491-589716540.png" alt="img"></p><p> 所以运输层的通信和网络层的通信有很大的区别。<strong>网络层提供主机之间的逻辑通信，而运输层则提供应用进程之间的逻辑通信。</strong></p><p>运输层还有复用、分用的功能，还要对收到的报文进行差错检查。</p><p><strong>运输层向高层用户屏蔽了下面网络核心的细节（如网络拓扑、所采用的路由选择协议等）</strong>，它使应用进程看见的就好像是在两个运输层实体之间有一条端到端的逻辑通信信道。<strong>当运输层采用面向连接的TCP协议时，尽管下面的网络是不可靠的</strong>，但这种逻辑通信信道就相当于一条全双工的可靠信道。但当运输层采用无连接的UDP协议时，这种逻辑通信信道仍然是一条不可靠信道。</p><p>当应用程序使用面向连接的TCP和无连接的IP时，这种传输是面向连接的还是无连接的？</p><p>这要在不同层次来看。在运输层是面向连接的，而网络层则是无连接的。</p><h3 id="运输层的两个主要协议"><a href="#运输层的两个主要协议" class="headerlink" title="运输层的两个主要协议"></a>运输层的两个主要协议</h3><p>（1）用户数据报协议UDP（User Datagram Protocol）无连接</p><p> (2) 传输控制协议TCP（Transmission Control Protocol）面向连接</p><p>TCP 传送的数据单位协议是 TCP 报文段(segment)。<br>UDP 传送的数据单位协议是 UDP 报文或用户数据报。</p><p>运输层的 UDP 用户数据报与网际层的IP数据报有很大区别。<br>（1）IP 数据报要经过互连网中许多路由器的存储转发。<br>（2）UDP 用户数据报是在运输层的端到端抽象的逻辑信道中传送的。<br>TCP 报文段是在运输层抽象的端到端逻辑信道中传送，这种信道是可靠的全双工信道。但这样的信道却不知道究竟经过了哪些路由器，而这些路由器也根本不知道上面的运输层是否建立了 TCP 连接。</p><h4 id="UDP的特点"><a href="#UDP的特点" class="headerlink" title="UDP的特点"></a><strong>UDP的特点</strong></h4><p>UDP 是无连接的，发送数据之前不需要建立连接，，因此减少了开销和发送数据之前的时延。<br>UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。<br>UDP 是面向报文的。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。UDP 一次交付一个完整的报文。<br>UDP 没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。很适合多媒体通信的要求。<br>UDP 支持一对一、一对多、多对一和多对多的交互通信。<br>UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。</p><h4 id="TCP的特点"><a href="#TCP的特点" class="headerlink" title="TCP的特点"></a>TCP的特点</h4><p>TCP 是面向连接的运输层协议。<br>每一条 TCP 连接只能有两个端点 (endpoint)，每一条 TCP 连接只能是点对点的（一对一）。<br>TCP 提供可靠交付的服务。<br>TCP 提供全双工通信。<br>面向字节流<br>TCP 中的“流”(stream) 指的是流入或流出进程的字节序列。<br>“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块，但 TCP 把应用程序交下来的数据看成仅仅是一连串无结构的字节流。</p><h3 id="运输层的端口"><a href="#运输层的端口" class="headerlink" title="运输层的端口"></a>运输层的端口</h3><p>端口是用来标志进程的。端口也就是协议端口号。<br>在协议栈层间的抽象的协议端口是软件端口。<br>路由器或交换机上的端口是硬件端口。<br>硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与运输实体进行层间交互的一种地址。<br>不同的系统，具体实现端口的方法可以是不同的。<br>端口用一个 16 位端口号进行标志，允许有65,535个不同的端口号。<br><strong>端口号只具有本地意义，即端口号只是为了标志本计算机应用层中的各进程</strong>。在互联网中，不同计算机的相同端口号是没有联系的。</p><h4 id="两大类三种接口"><a href="#两大类三种接口" class="headerlink" title="两大类三种接口"></a>两大类三种接口</h4><p>服务器端使用的端口号<br><strong>熟知端口</strong>，数值一般为 0 ~ 1023。<br><strong>登记端口</strong>号，数值为 1024 ~ 49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。<br>客户端使用的端口号<br>又称为<strong>短暂端口</strong>号，数值为 49152 ~ 65535，留给客户进程选择暂时使用。<br>当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。</p><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200703153203351-845331713.png" alt="img"></p><h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3><p>“停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。<br>全双工通信的双方既是发送方也是接收方。<br>为了讨论问题的方便，我们仅考虑 A 发送数据，而 B 接收数据并发送确认。因此 A 叫做发送方，而 B 叫做接收方。<br><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200703154543332-1483426297.png" alt="img"></p><p> <img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200703154627427-1962186887.png" alt="img"></p><h3 id="TCP传输"><a href="#TCP传输" class="headerlink" title="TCP传输"></a>TCP传输</h3><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200703160455630-2006895588.png" alt="img"></p><p>MSS (Maximum Segment Size)是 TCP 报文段中的数据字段的最大长度。数据字段加上 TCP 首部才等于整个的 TCP 报文段。所以，MSS是“TCP 报文段长度减去 TCP 首部长度”。</p><p><strong>5-22</strong><br><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200703160135905-1062989375.png" alt="img"></p><p><strong>5-23</strong></p><p><strong><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200703162824140-1320751445.png" alt="img"></strong></p><p><strong>5-28</strong></p><p><strong><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200703162008890-1307184401.png" alt="img"></strong></p><h3 id="超时重传的时间选择"><a href="#超时重传的时间选择" class="headerlink" title="超时重传的时间选择"></a>超时重传的时间选择</h3><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200703164152135-1331313556.png" alt="img"></p><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200703164208850-1192155934.png" alt="img"></p><h3 id="TCP拥塞控制方法"><a href="#TCP拥塞控制方法" class="headerlink" title="TCP拥塞控制方法"></a>TCP拥塞控制方法</h3><p>为了进行拥塞控制，TCP的发送方要维持一个拥塞窗口cwnd的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p><p>拥塞控制采用的四种算法即慢开始、拥塞避免、快重传和快恢复。</p><p><a href="https://www.cnblogs.com/wkfvawl/p/12813103.html">https://www.cnblogs.com/wkfvawl/p/12813103.html</a></p><p><img src="https://img2020.cnblogs.com/blog/1358881/202005/1358881-20200501125540179-859319045.png" alt="img"></p><p> <img src="https://img2020.cnblogs.com/blog/1358881/202005/1358881-20200501125558931-344550758.png" alt="img"><img src="https://img2020.cnblogs.com/blog/1358881/202005/1358881-20200501125619970-295178592.png" alt="img"></p><p> <img src="https://img2020.cnblogs.com/blog/1358881/202005/1358881-20200501125642284-1311713911.png" alt="img"></p><h3 id="流量控制和拥塞控制区别"><a href="#流量控制和拥塞控制区别" class="headerlink" title="流量控制和拥塞控制区别"></a>流量控制和拥塞控制区别</h3><p>拥塞控制</p><p>防止过多的数据注入到网络中，使网络中的路由器或链路不致过载；<br>是一个全局性的过程，涉及到与降低网络传输性能有关的所有因素。</p><p>流量控制</p><p>抑制发送端发送数据的速率，以使接收端来得及接收；<br>是点对点通信量的控制，是端到端的问题；<br><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200703174724272-1070962384.png" alt="img"></p><h2 id="六、应用层"><a href="#六、应用层" class="headerlink" title="六、应用层"></a>六、应用层</h2><h3 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h3><p>域名系统的主要功能是什么？域名系统中的本地域名服务器、根域名服务器、顶级域名服务器以及权限域名权服务器有何区别？<br>答:域名系统DNS的主要功能：将域名解析为主机能识别的IP地址。在域名系统中使用了层次结构的许多域名服务器。域名服务器分为根域名服务器、顶级域名服务器、权限域名服务器和本地域名服务器。<br>根域名服务器是最高层次的域名服务器，也是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和 IP 地址。<br>不管是哪一个本地域名服务器，若要对互联网上任何一个域名进行解析，只要自己无法解析，就首先求助于根域名服务器。<br>在互联网上共有 13 个不同 IP 地址的根域名服务器，它们的名字是用一个英文字母命名，从 a 一直到 m（前 13 个字母）。</p><p>顶级域名服务器（即 TLD 服务器）负责管理在该顶级域名服务器注册的所有二级域名。<br>当收到 DNS 查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当找的域名服务器的 IP 地址）。</p><p>权限域名服务器负责一个区的域名服务器。<br>当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，下一步应当找哪一个权限域名服务器。</p><p>本地域名服务器对域名系统非常重要。<br>当一个主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。<br>每一个互联网服务提供者 ISP，或一个大学，甚至一个大学里的系，都可以拥有一个本地域名服务器，<br>这种域名服务器有时也称为默认域名服务器。</p><h4 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h4><p>主机向本地域名服务器的查询一般都是采用递归查询。如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向其他根域名服务器继续发出查询请求报文。<br>本地域名服务器向根域名服务器的查询通常是采用迭代查询。当根域名服务器收到本地域名服务器的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地域名服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地域名服务器进行后续的查询。</p><h3 id="文件传输协议"><a href="#文件传输协议" class="headerlink" title="文件传输协议"></a>文件传输协议</h3><h4 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h4><p>文件传送协议 FTP (File Transfer Protocol) 是互联网上使用得最广泛的文件传送协议。<br>FTP 提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限。<br>FTP 屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件。<br>文件传送协议 FTP 只提供文件传送的一些基本的服务，它<strong>使用 TCP 可靠的运输服务</strong>。<br>FTP 的主要功能是减少或消除在不同操作系统下处理文件的不兼容性。<br><strong>FTP 使用客户服务器方式。一个 FTP 服务器进程可同时为多个客户进程提供服务。FTP 的服务器进程由两大部分组成：一个主进程，负责接受新的请求；另外有若干个从属进程，负责处理单个请求。</strong></p><p>主进程的工作步骤如下：</p><p>打开熟知端口（端口号为 21），使客户进程能够连接上。<br>等待客户进程发出连接请求。<br>启动从属进程来处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程。<br>回到等待状态，继续接受其他客户进程发来的请求。主进程与从属进程的处理是并发地进行。</p><p><strong>服务器端有两个从属进程：控制进程和数据传送进程。在客户端除了控制进程和数据传输 进程外，还有一个用户界面进程来和用户接口。</strong></p><p>控制连接在整个会话期间一直保持打开，FTP 客户发出的传送请求通过控制连接发送给服务器端的控制进程，但控制连接不用来传送文件。<br>实际用于传输文件的是“数据连接”。服务器端的控制进程在接收到 FTP 客户发送来的文件传输请求后就创建“数据传送进程”和“数据连接”，用来连接客户端和服务器端的数据传送进程。<br>数据传送进程实际完成文件的传送，在传送完毕后关闭“数据传送连接”并结束运行。</p><h4 id="简单文件传送协议TFTP"><a href="#简单文件传送协议TFTP" class="headerlink" title="简单文件传送协议TFTP"></a>简单文件传送协议TFTP</h4><p>TFTP (Trivial File Transfer Protocol) 是一个很小且易于实现的文件传送协议。<br>TFTP 使用客户服务器方式和使用 UDP 数据报，因此 TFTP 需要有自己的差错改正措施。<br>TFTP 只支持文件传输而不支持交互。<br>TFTP 没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。</p><h3 id="超文本传输协议HTTP"><a href="#超文本传输协议HTTP" class="headerlink" title="超文本传输协议HTTP"></a>超文本传输协议HTTP</h3><p>HTTP的特点</p><p>HTTP 使用了面向连接的 TCP 作为运输层协议，保证了数据的可靠传输。<br>HTTP 协议本身也是无连接的，虽然它使用了面向连接的 TCP 向上提供的服务。<br>HTTP 是面向事务的客户服务器协议。<br>HTTP 1.0 协议是无状态的 (stateless)。<br><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200703195034584-1639825880.png" alt="img"></p><p>请求一个万维网文档所需的时间是该文档的传输时间(与文档大小成正比)加上两倍往返时间RTT(一个RTT用于连接TCP连接，另一个RTT用于请求和接收万维网文档）。TCP建立连接的三报文握手的第三个报文段中的数据，就是客户对万维网文档的请求报文)。</p><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200703195304022-1656147917.png" alt="img"></p><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200703200433457-2000393391.png" alt="img"></p><h3 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h3><p>电子邮件系统的三个主要构成部件：用户代理、邮件服务器，以及邮件发送协议（如SMTP）和邮件读取协议（如POP3）</p><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200703201334487-294671001.png" alt="img"></p><p><strong>用户代理 UA 就是用户与电子邮件系统的接口，是电子邮件客户端软件。</strong><br>用户代理的功能：撰写、显示、处理和通信。<br>邮件服务器的功能是发送和接收邮件，同时还要向发信人报告邮件传送的情况（已交付、被拒绝、丢失等）。<br>邮件服务器按照客户 - 服务器方式工作。邮件服务器需要使用发送和读取两个不同的协议。<br>如果没有用户代理UA，那么对于要用电子邮件的用户来说就很不方便。因为上面所说的UA的功能，就要由用户自己编程来实现。</p><p>邮件发送和读取使用不同的协议协议。<br><strong>简单邮件发送协议 SMTP</strong>：用于在用户代理向邮件服务器或邮件服务器之间发送邮件。<br><strong>邮局协议 POP3</strong>：用于用户代理从邮件服务器读取邮件。</p><p>现在常用的<strong>邮件读取协议</strong>有两个，即<strong>邮局协议POP3</strong>和<strong>网际报文存取协议IMAP（Internet Message Access Protocol）</strong></p><p>POP3 使用客户–服务器方式。<br>POP3 基于TCP实现客户与服务器的通信。<br>POP3 支持用户鉴别。<br>POP3 服务器删除被用户读取了的邮件。</p><p>IMAP 使用客户–服务器方式。<br>IMAP 基于TCP实现客户与服务器的通信。<br>IMAP是一个联机协议。</p><p><strong>IMAP协议特点</strong><br>连接后只下载邮件首部（部分下载）。<br>用户直接在IMAP服务器上创建和管理文件夹。<br>用户可以搜索邮件内容。<br>用户可以在不同的地方使用不同的计算机随时上网阅读和处理自己的邮件。<br>允许收信人只读取邮件中的某一个部分。<br>缺点：要想查阅邮件，必须先联网。<br><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200703203033082-799549088.png" alt="img"></p><h3 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h3><p>互联网广泛使用的动态主机配置协议 DHCP (Dynamic Host Configuration Protocol) 提供了即插即用连网 (plug-and-play networking) 的机制。</p><p>提供了即插即用联网机制。<br>这种机制允许一台计算机加入新的网络和获取 IP 地址，而不用手工配置。<br>DHCP给运行服务器软件、且位置固定的计算机指派一个永久地址，给运行客户端软件的计算机分配一个临时地址。<br>当一台计算机第一次运行引导程序时，ROM中并没有该计算机的IP地址、子网掩码，或某个域名服务器的IP地址的任何一个。</p><h3 id="简单网络管理协议SNMP"><a href="#简单网络管理协议SNMP" class="headerlink" title="简单网络管理协议SNMP"></a>简单网络管理协议SNMP</h3><p>简单网络管理协议SNMP (Simple Network Management Protocol) 中的管理程序和代理程序按客户–服务器方式工作。<br>管理程序运行 SNMP 客户程序，向某个代理程序发出请求（或命令），代理程序运行 SNMP 服务器程序，返回响应（或执行某个动作）。<br>在网管系统中，往往是一个（或少数几个）客户程序与很多的服务器程序进行交互。</p><p>SNMP使用无连接的UDP（要发送数据时不需要有链接建立过程，数据发送完毕后，也不需要链接释放过程），因此在网络上传送SNMP报文的开销较小，但UDP是不保证可靠交付的，有丢失的可能。好在SNMP使用周期性地发送探询报文段的方法，来对网络资源进行实时监视，如果丢失一个探寻报文，则经过一段时间后，会再发送一个，这样就比TCP要快速许多。</p><h3 id="P2P应用"><a href="#P2P应用" class="headerlink" title="P2P应用"></a>P2P应用</h3><p><strong><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200703205231726-984598743.png" alt="img"></strong></p><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200703205446593-2076589440.png" alt="img"></p><h2 id="七、网络安全"><a href="#七、网络安全" class="headerlink" title="七、网络安全"></a>七、网络安全</h2><h3 id="安全性威胁"><a href="#安全性威胁" class="headerlink" title="安全性威胁"></a>安全性威胁</h3><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200704094323962-754277586.png" alt="img"></p><h4 id="被动攻击"><a href="#被动攻击" class="headerlink" title="被动攻击"></a>被动攻击</h4><p><strong>指攻击者从网络上窃听他人的通信内容。通常把这类攻击称为截获。</strong><br>在被动攻击中，攻击者只是观察和分析某一个<strong>协议数据单元 PDU</strong>，以便了解所交换的数据的某种性质。但不干扰信息流。<br>这种被动攻击又称为流量分析 (traffic analysis)。</p><h4 id="主动攻击"><a href="#主动攻击" class="headerlink" title="主动攻击"></a>主动攻击</h4><p>主要有：<br>篡改——故意篡改网络上传送的报文。这种攻击方式有时也称为更改报文流。<br><strong>恶意程序——种类繁多，对网络安全威胁较大的主要包括：计算机病毒、计算机蠕虫、特洛伊木马、逻辑炸弹、后门入侵、流氓软件等。</strong><br><strong>拒绝服务——指攻击者向互联网上的某个服务器不停地发送大量分组，使该服务器无法提供正常服务，甚至完全瘫痪。</strong></p><p>对于主动攻击，可以采取适当措施加以检测。<br>对于被动攻击，通常却是检测不出来的。<br>根据这些特点，可得出计算机网络通信安全的目标：</p><ul><li>防止分析出报文内容和流量分析。</li><li>防止恶意程序。</li><li>检测更改报文流和拒绝服务。</li></ul><p><strong>对付被动攻击可采用各种数据加密技术。</strong><br><strong>对付主动攻击则需将加密技术与适当的鉴别技术相结合。</strong></p><p>重放攻击：指攻击者对某个连接中通过PDU进行各种处理。如有选择地更改、删除、延迟这些PDU(当然也包括记录和复制它们)，还可在稍后的时间将以前录下的PDU插入这个连接。</p><p>访问控制：对接入网络的权限加以控制，并规定每个用户的接入权限</p><p>流量分析：攻击者通过观察PDU的协议控制信息部分，了解正在通信的协议实体的地址和身份，研究PDU的长度和传输频度，以便了解所交换的数据的某种性质。</p><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200704110612378-972547982.png" alt="img"></p><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200704110639841-553117893.png" alt="img"></p><h3 id="两类密码体制"><a href="#两类密码体制" class="headerlink" title="两类密码体制"></a>两类密码体制</h3><h4 id="对称秘钥密码体制"><a href="#对称秘钥密码体制" class="headerlink" title="对称秘钥密码体制"></a>对称秘钥密码体制</h4><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200704101013940-1336667622.png" alt="img"></p><p>所谓常规密钥密码体制，即加密密钥与解密密钥是相同的密码体制。<br>这种加密系统又称为对称密钥系统。<br>数据加密标准DES属于对称秘钥密码体制。</p><p>DES的保密性仅取决于对密钥的保密，而算法是公开的。</p><h4 id="公钥密码体制"><a href="#公钥密码体制" class="headerlink" title="公钥密码体制"></a>公钥密码体制</h4><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200704101537909-431066933.png" alt="img"></p><p>公钥密码体制（又称为公开密钥密码体制）使用不同的加密密钥与解密密钥，是一种“由已知加密密钥推导出解密密钥在计算上是不可行的”密码体制。<br><strong>在公钥密码体制中，加密密钥 PK（public key，即公钥）是向公众公开的，而解密密钥 SK（secret key，即私钥或秘钥）则是需要保密的。</strong><br><strong>加密算法 E 和解密算法 D 也都是公开的。</strong><br>虽然私钥 SK 是由公钥 PK 决定的，但却不能根据 PK 计算出 SK。</p><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200704101318550-640186946.png" alt="img"></p><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200704101328309-1230143711.png" alt="img"></p><p>公开密钥和对称秘钥在使用通信信道方面有很大的不同。在使用对称密钥时，由于双方使用同样的密钥，因此在通信信道上可以进行<strong>一对一的双向保密通信</strong>，每一方既可用此密钥加密明文，并发送给对方，也可接收密文，用同一密钥对密文解密。这种保密通信仅限于持有此密钥的双方（如再有第三方就不保密了）。<br>在使用公开密钥时，在通信信道上可以是<strong>多对一的单向保密通信</strong>。</p><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>用于证明真实性。<br>数字签名必须保证以下三点：</p><ul><li>报文鉴别——接收者能够核实发送者对报文的签名（证明来源）；</li><li>报文的完整性——发送者事后不能抵赖对报文的签名（防否认）；</li><li>不可否认——接收者不能伪造对报文的签名（防伪造）。</li></ul><p>现在已有多种实现各种数字签名的方法。但<strong>采用公钥算法更容易实现</strong>。</p><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200704103532777-1821420794.png" alt="img"></p><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200704103628989-1761558511.png" alt="img"></p><p>公钥私钥关系：<br><strong>私钥签名，公钥验证；公钥加密，私钥解密</strong></p><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200704110149796-184741345.png" alt="img"></p><h3 id="网络层安全协议"><a href="#网络层安全协议" class="headerlink" title="网络层安全协议"></a>网络层安全协议</h3><p><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200704111820328-1257525782.png" alt="img"></p><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p><strong>防火墙</strong>是由软件、硬件构成的系统，<strong>是一种特殊编程的路由器，用来在两个网络之间实施访问控制策略</strong>。<br>访问控制策略是由<strong>使用防火墙的单位自行制订</strong>的，为的是可以最适合本单位的需要。<br><strong>防火墙内的网络称为“可信的网络”(trusted network)，而将外部的互联网称为“不可信的网络”(untrusted network)。</strong><br>防火墙可用来解决内联网和外联网的安全问题。<br><img src="https://img2020.cnblogs.com/blog/1358881/202007/1358881-20200704222644912-45825911.png" alt="img"></p><p> <strong>防火墙的功能有两个：阻止和允许。</strong><br>“阻止”就是阻止某种类型的通信量通过防火墙（从外部网络到内部网络，或反过来）。<br>“允许”的功能与“阻止”恰好相反。<br>防火墙必须能够识别各种类型的通信量。不过在大多数情况下防火墙的主要功能是“阻止”。</p><p>防火墙技术分为：</p><p><strong>网络级防火墙</strong>，用来防止整个网络出现外来非法入侵（属于这类的有分组过滤和授权服务器）</p><p><strong>应用级防火墙</strong>，用来进行访问控制（用应用网关或代理服务器来区分各种应用）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;整理自&lt;a href=&quot;https://www.cnblogs.com/wkfvawl/p/13207411.html)%EF%BC%8C%E4%BB%85%E7%A7%81%E7%94%A8&quot;&gt;https://www.cnblogs.com/wkfvawl/p/13207</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://xxsy613.github.io/2023/10/26/408%E7%9C%9F%E9%A2%98%E5%8D%B7%E5%BD%92%E6%A1%A3/"/>
    <id>http://xxsy613.github.io/2023/10/26/408%E7%9C%9F%E9%A2%98%E5%8D%B7%E5%BD%92%E6%A1%A3/</id>
    <published>2023-10-26T11:24:57.781Z</published>
    <updated>2023-10-30T07:31:31.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2009"><a href="#2009" class="headerlink" title="2009"></a>2009</h1><p>得分：102</p><h2 id="巩固"><a href="#巩固" class="headerlink" title="巩固"></a>巩固</h2><p>完全二叉树√</p><p>树，二叉树，森林的转换√</p><p>浮点数的加减√</p><p>Cache的映射</p><p>指令系统</p><p>内存管理</p><p>文件管理</p><p>外存</p><p>奈奎斯特和香农定理√</p><p>数据链路层，介质访问控制√</p><p>TCP拥塞窗口√</p><p>应用层的文件系统√</p><p>网络层的IP分组</p><h2 id="重学"><a href="#重学" class="headerlink" title="重学"></a>重学</h2><p>无向连通图 √</p><p>排序√</p><h1 id="2010"><a href="#2010" class="headerlink" title="2010"></a>2010</h1><p>得分：85</p><h2 id="巩固-1"><a href="#巩固-1" class="headerlink" title="巩固"></a>巩固</h2><p>线索二叉树√</p><p>平衡二叉树的插入和删除√</p><p>树的各种计算方法√</p><p>哈夫曼树√</p><p>连通图√</p><p>RAM和ROM辨析√</p><p>指令流水线</p><p>进程与线程√</p><p>动态分区策略</p><p>ICMP</p><p>Cache</p><h2 id="重学-1"><a href="#重学-1" class="headerlink" title="重学"></a>重学</h2><p>查找√</p><p>中断服务程序</p><p>DRAM√</p><p>信号量与各种算法</p><p>分页分段存储策略</p><p>文件索引√</p><p>域名服务器</p><p>散列表√</p><p>磁盘管理√</p><h1 id="2011"><a href="#2011" class="headerlink" title="2011"></a>2011</h1><p>得分：94</p><h2 id="巩固-2"><a href="#巩固-2" class="headerlink" title="巩固"></a>巩固</h2><p>线性存储结构的知识点深化</p><p>树，二叉树，森林的转换</p><p>中断屏蔽</p><p>主存缓冲区，单缓冲，双缓冲</p><p>物理地址和虚拟地址访问cache时的划分以及Cache内容</p><p>文件系统的进一步精度和总结</p><h2 id="重学-2"><a href="#重学-2" class="headerlink" title="重学"></a>重学</h2><p>堆排序</p><p>指令流水线</p><p>PV操作及相关算法</p><p>HTTP协议，应用层协议</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2009&quot;&gt;&lt;a href=&quot;#2009&quot; class=&quot;headerlink&quot; title=&quot;2009&quot;&gt;&lt;/a&gt;2009&lt;/h1&gt;&lt;p&gt;得分：102&lt;/p&gt;
&lt;h2 id=&quot;巩固&quot;&gt;&lt;a href=&quot;#巩固&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://xxsy613.github.io/2023/10/23/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    <id>http://xxsy613.github.io/2023/10/23/%E6%A6%82%E7%8E%87%E8%AE%BA/</id>
    <published>2023-10-23T08:36:00.278Z</published>
    <updated>2023-10-30T07:42:04.324Z</updated>
    
    <content type="html"><![CDATA[<p><u>整理自方浩概率论强化课内容</u></p><h1 id="一-随机事件和概率"><a href="#一-随机事件和概率" class="headerlink" title="一 随机事件和概率"></a>一 随机事件和概率</h1><h3 id="事件的运算规律"><a href="#事件的运算规律" class="headerlink" title="事件的运算规律"></a>事件的运算规律</h3><p>分配率：$A\cap (B\cup C)&#x3D;(A\cap B)\cup(A\cap C)$<br>              $A\cup (B\cap C)&#x3D;(A\cup B)\cup(A\cap C)$ </p><p>德摩根率</p><h1 id="二-随机变量及其分布"><a href="#二-随机变量及其分布" class="headerlink" title="二 随机变量及其分布"></a>二 随机变量及其分布</h1><p><strong>分布函数</strong></p><p>重要性质：</p><ul><li>随机变量X趋近于0时函数为0，趋近于无穷时函数为1</li><li>单调不减</li><li>右连续</li><li>随机变量X的区间为左闭右开</li><li>$P&#x3D;\lbrace x\leq x_0\rbrace&#x3D;F(x_0)$   $P&#x3D;\lbrace x&lt; x_0\rbrace&#x3D;F(x_0-0)$</li></ul><p>解题方法：一找关键点，二区间为左闭右开，三记住分布函数的累积性</p><p><strong>求随机变量的分布律</strong>：表示离散性，可用分布律的性质</p><p>所有求分布律的题记得列出随机变量的范围k</p><p><strong>几何分布：</strong>成功率为p，一共进行k次实验，在成功一次之前需要失败k-1次，所以分布率为$p(1-p)^{k-1}$，期望为$E&#x3D;\frac{1}{p}$<br>几何分布从0开始，二项分布从1开始</p><p>期望为$\frac{1}{p}$，方差为$\frac{1-p}{p^2}$</p><p><strong>泊松分布：</strong>$\frac{\lambda^k}{k!}e^{-\lambda},k&#x3D;0,1,2…$，容易跟无穷级数求和相结合</p><p>期望为$\lambda$，方差为$\lambda$</p><p><strong>概率密度：</strong>表示$F(k)$具有连续性，满足概率密度的各种性质</p><p><strong>概率分布（分布律）与概率密度：</strong>分布律是离散型分布函数中的，概率密度是连续型分布函数中的，两种都是为了求分布函数<br>$$<br>概率分布求分布函数：F(x)&#x3D;\sum_{x_k\leq x}p_k\<br>概率密度求分布函数：F(x)&#x3D;\int^x_{-\infty}f(t)dt<br>$$<br><strong>指数分布：</strong><br>$$<br>f(x)&#x3D;\lambda e^{-\lambda x},x&gt;0\<br>F(x)&#x3D;1-e^{-\lambda x},x&gt;0\<br>F(x)&#x3D;0,x\leq0<br>$$<br>有 无记忆性：$P\lbrace X&gt;t+s|X&gt;s\rbrace&#x3D;P\lbrace X&gt;t\rbrace$</p><p><strong>正态分布：</strong><br>$$<br>F(x)&#x3D;\frac{1}{\sqrt{2\pi}\sigma}e^{\frac{(x-\mu)^2}{2\sigma^2}},X\sim N(\mu,\sigma^2)\<br>\Phi(x)&#x3D;\frac{1}{\sqrt{2\pi}}e^{\frac{x^2}{2}},X\sim N(0,1)\<br>F(x)&#x3D;\Phi(\frac{x-\mu}{\sigma})<br>$$<br>期望为$\mu$，方差为$\sigma^2$</p><h1 id="三-多维随机变量及其分布"><a href="#三-多维随机变量及其分布" class="headerlink" title="三 多维随机变量及其分布"></a>三 多维随机变量及其分布</h1><h2 id="1-联合分布"><a href="#1-联合分布" class="headerlink" title="1 联合分布"></a>1 联合分布</h2><p>$F(x,y)&#x3D;P(X\leq x,Y\leq y)$</p><p>结合图像</p><p><strong>联合密度：</strong>$f(x,y)$</p><p><strong>边缘密度：</strong>$f_x(x)$</p><p><strong>条件密度：</strong>$f_{y|x}(y|x)$</p><h2 id="2-离散-x2F-连续"><a href="#2-离散-x2F-连续" class="headerlink" title="2 离散&#x2F;连续"></a>2 离散&#x2F;连续</h2><h3 id="2-1-离散"><a href="#2-1-离散" class="headerlink" title="2.1 离散"></a>2.1 离散</h3><p>构建联合联合分布表，得到边缘分布（表中一行或者一列的数值和）和条件分布（表中每一项的值）</p><h3 id="2-2-连续"><a href="#2-2-连续" class="headerlink" title="2.2 连续"></a>2.2 连续</h3><p>计算边缘密度和条件密度</p><h3 id="2-3-独立性"><a href="#2-3-独立性" class="headerlink" title="2.3 独立性"></a>2.3 独立性</h3><p>一般不独立，需要举反例</p><h2 id="3-二维正态"><a href="#3-二维正态" class="headerlink" title="3 二维正态"></a>3 二维正态</h2><p>独立性，边缘分布，降维打击</p><p>（配方，除系数，添因子）×2</p><h2 id="4-Z-x3D-g-x-y"><a href="#4-Z-x3D-g-x-y" class="headerlink" title="4 $Z&#x3D;g(x,y)$"></a>4 $Z&#x3D;g(x,y)$</h2><p>离散跟离散：列举</p><p>离散跟连续：定义，找关键点</p><p>连续跟连续：卷积公式，找关键点</p><h1 id="四-随机变量的数字特征"><a href="#四-随机变量的数字特征" class="headerlink" title="四 随机变量的数字特征"></a>四 随机变量的数字特征</h1><h2 id="1-期望，方差"><a href="#1-期望，方差" class="headerlink" title="1 期望，方差"></a>1 期望，方差</h2><p>根据性质来求，尽量减少计算量</p><p><strong>离散型的期望：</strong><br>$$<br>E(X)&#x3D;\sum_{k&#x3D;1}^\infty x_kp_k<br>$$<br><strong>连续型的期望：</strong><br>$$<br>E(x)&#x3D;\int_{-\infty}^{+\infty}x f(x)dx\<br>E(g(x))&#x3D;\int_{-\infty}^{+\infty}g(x )f(x)dx—概率具有稳定性<br>$$<br>先有方差再有期望，方差由期望定义</p><p><strong>曹冲称象：</strong>将随机变量的取值先增后减，或者先减后加，构造成常见的分布进而求常见分布的期望方差</p><p><strong>常见随机变量的分布，期望和方差，需要记牢</strong></p><h2 id="2-协方差，相关系数"><a href="#2-协方差，相关系数" class="headerlink" title="2 协方差，相关系数"></a>2 协方差，相关系数</h2><p>主要看性质</p><p><strong>协方差：</strong><br>$$<br>Cov(X,Y)&#x3D;E(XY)-E(X)E(Y)\<br>D(X+Y)&#x3D;D(X)+D(Y)+2Cov(X,Y)\<br>Cov(X_1+X_2,Y_1+Y_2)自由组合<br>$$<br><strong>相关系数ρ</strong><br>$$<br>|\rho|&#x3D;1等价于P\lbrace Y&#x3D;aX+b\rbrace&#x3D;1<br>$$</p><h2 id="3-独立与不相关"><a href="#3-独立与不相关" class="headerlink" title="3 独立与不相关"></a>3 独立与不相关</h2><ul><li>独立是概率分布，不相关是数字特征</li><li>独立则不相关，不相关不一定独立</li><li>用不相关推不独立时，举反例</li><li>用不相关推独立时，计算</li><li>在二维正态下，独立与不相关可互推</li></ul><h1 id="五-大数定律和中心极限定理"><a href="#五-大数定律和中心极限定理" class="headerlink" title="五 大数定律和中心极限定理"></a>五 大数定律和中心极限定理</h1><h2 id="1-切比雪夫不等式"><a href="#1-切比雪夫不等式" class="headerlink" title="1 切比雪夫不等式"></a>1 切比雪夫不等式</h2><p>X偏离期望越多，几率越小<br>$$<br>P\lbrace|X-E(X)|\geq\epsilon\rbrace\leq \frac{D(X)}{\epsilon^2}<br>$$<br>求概率上界</p><h2 id="2-大数定律"><a href="#2-大数定律" class="headerlink" title="2 大数定律"></a>2 大数定律</h2><p>随机变量的均值，依概率收敛于期望</p><p><strong>切比雪夫大数定律：</strong>独立且<strong>不同分布</strong>，方差有上界$D(X_i)\leq M$，则随机变量依概率收敛于$\frac{1}{n}\sum_{i&#x3D;1}^nE(X_i)$</p><p><strong>辛钦大数定理：</strong>独立且<strong>同分布</strong>，$E(X_i)$存在，则随机变量依概率收敛于$E(X)$<br>$$<br>\frac{X_1+X_2+…+X_n}{n}依概率收敛于E\frac{X_1+X_2+…+X_n}{n}<br>$$</p><h2 id="3-一个中心极限"><a href="#3-一个中心极限" class="headerlink" title="3 一个中心极限"></a>3 一个中心极限</h2><p>求$n\to\infty$时的概率</p><p>随机变量之和近似于正态分布<br>$$<br>\lim_{n\to\infty}P\lbrace\frac{\sum_{i&#x3D;1}^n x_i-n\mu}{\sqrt{n\sigma^2}}\leq a\rbrace&#x3D;\Phi(a)<br>$$</p><h1 id="六-数理统计的基本概念"><a href="#六-数理统计的基本概念" class="headerlink" title="六 数理统计的基本概念"></a>六 数理统计的基本概念</h1><h2 id="1-统计量"><a href="#1-统计量" class="headerlink" title="1 统计量"></a>1 统计量</h2><p>$$<br>\overline X:E(\overline X)&#x3D;E(X),D(\overline X)&#x3D;\frac{D(X)}{n}\<br>S^2:ES^2&#x3D;\sigma^2,正态:\frac{(n-1)S^2}{\sigma^2}\sim \chi^2(n-1)<br>$$</p><h2 id="2-三大分布"><a href="#2-三大分布" class="headerlink" title="2 三大分布"></a>2 三大分布</h2><table><thead><tr><th>分布</th><th>形式</th><th>自由度</th><th>特性</th></tr></thead><tbody><tr><td>$\chi^2(n)$</td><td>$X_1^2+X_2^2+…X_n^2$</td><td>$n&#x3D;平方个数$</td><td>$E(\chi^2(n))&#x3D;n\ D(\chi^2(n))&#x3D;2n$</td></tr><tr><td>$t(n)$</td><td>$\frac{X}{\sqrt{Y_1^2+…Y_n^2&#x2F;n}}$</td><td>$n&#x3D;括号内平方个数$</td><td>偶函数对称</td></tr><tr><td>$F(m,n)$</td><td>$\frac{X_1^2+…X_n^2&#x2F;m}{Y_1^2+…Y_n^2&#x2F;n}$</td><td>$m&#x3D;分子中平方个数\n&#x3D;分母中平方个数$</td><td>$\frac{1}{F(m,n)}\sim F(n,m)$</td></tr></tbody></table><h2 id="3-正态总体"><a href="#3-正态总体" class="headerlink" title="3 正态总体"></a>3 正态总体</h2><p>$$<br>\frac{\overline X-\mu}{S&#x2F;\sqrt{n}}\sim t(n-1)\<br>\frac{\overline X-\mu}{\sigma&#x2F;\sqrt n}\sim N(0,1)\<br>\frac{(n-1)S^2}{\sigma^2}\sim \chi^2(n-1)<br>$$</p><h1 id="七-参数估计"><a href="#七-参数估计" class="headerlink" title="七 参数估计"></a>七 参数估计</h1><h2 id="1-矩估计"><a href="#1-矩估计" class="headerlink" title="1 矩估计"></a>1 矩估计</h2><p>令$E(X)&#x3D;\bar X$，得到$\hat\theta,\bar X$的等式</p><h2 id="2-最大似然估计"><a href="#2-最大似然估计" class="headerlink" title="2 最大似然估计"></a>2 最大似然估计</h2><ol><li><p>求似然函数$L&#x3D;\prod_{i&#x3D;1}^{n}f(x_i,\theta)$</p></li><li><p>取对数求导$\frac{d\ln L}{d\theta}$</p></li><li><p>若求导有解，即最大估计量为$\hat\theta$</p><p>若无解，则根据单调性来判断最大值</p></li></ol><h2 id="3-求-E-hat-theta-D-hat-theta"><a href="#3-求-E-hat-theta-D-hat-theta" class="headerlink" title="3 求$E(\hat\theta),D(\hat\theta)$"></a>3 求$E(\hat\theta),D(\hat\theta)$</h2><p>性质，定义</p><h1 id="八-假设检验"><a href="#八-假设检验" class="headerlink" title="八 假设检验"></a>八 假设检验</h1><h2 id="1-懒"><a href="#1-懒" class="headerlink" title="1 懒"></a>1 懒</h2><p>![image-20231029122929826](&#x2F;Users&#x2F;moon&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20231029122929826.png)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;u&gt;整理自方浩概率论强化课内容&lt;/u&gt;&lt;/p&gt;
&lt;h1 id=&quot;一-随机事件和概率&quot;&gt;&lt;a href=&quot;#一-随机事件和概率&quot; class=&quot;headerlink&quot; title=&quot;一 随机事件和概率&quot;&gt;&lt;/a&gt;一 随机事件和概率&lt;/h1&gt;&lt;h3 id=&quot;事件的运算规律&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://xxsy613.github.io/2023/10/18/408%E8%8B%B1%E6%96%87%E7%BC%A9%E5%86%99%E5%85%A8%E8%A7%A3/"/>
    <id>http://xxsy613.github.io/2023/10/18/408%E8%8B%B1%E6%96%87%E7%BC%A9%E5%86%99%E5%85%A8%E8%A7%A3/</id>
    <published>2023-10-18T10:30:25.174Z</published>
    <updated>2023-10-29T12:25:11.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p><strong>RTTRound Trip Time</strong>发送数据到接受到接收端的确认，经历的时延</p><p><strong>OSIOpen System Interconnection Model</strong>计算机网络体系结构，物理层，数据链路层，网络层，传输层，会话层，表示层，应用层</p><p><strong>TCP&#x2F;IP Protocol Suite</strong> 计算机网路体系结构，网络接口层，网际层，传输层，应用层</p><p><strong>SAPService Access Point</strong>服务访问点，同一系统中相邻两层的实体交换信息的逻辑接口，用于区分不同的服务类型，表示上层为下层提供服务的点</p><p><strong>PDUProtocol Data Unit</strong>协议数据单元，对等层次之间传送的数据包称为该层的协议数据单元（帧、分组、报文）PDU &#x3D; PCI + SDU</p><p><strong>SDUSegment Data Unit</strong>服务数据单元，同一系统内，层与层之间交换的数据包称为服务数据单元</p><p><strong>PCIProtocol Control Information</strong>协议控制信息，控制协议操作的信息</p><p><strong>RZReturn To Zero</strong>归零编码把时钟信号用归零的方式编码在了数据内，称为“自同步”信号</p><p><strong>NRZNon Return To Zero</strong>非归零编码，需要时钟信号线，即外同步（以下四种都可以自同步）</p><p><strong>NRZINon Return To Zero Reversal</strong>反向非归零编码，既能传输时钟信号，又不损失系统带宽</p><p><strong>ASKAmplitude Shift Keying</strong>幅移键控，通过改变载波信号的振幅来表示数字信号1和0，载波的频率和相位不发生改变</p><p>**FSKFrequency Shift Keying**频移键控，通过改变载波信号的频率来表示数字信号1和0，载波的振幅和相位不发生改变</p><p><strong>PSKPhase Shift Keying</strong>相移键控 ，通过改变载波信号的相位来表示数字信号1和0，载波的振幅和频率不发生改变，又分为绝对调相和相对调相</p><p><strong>QAMQuadracture Amplitude Modulation</strong>正交振幅调制 ，频率相同下，将ASK和PSK结合，形成叠加信号</p><p><strong>MTUMaximum Transmission Unit</strong>最大传输单元</p><p>**CRCCyclic Redundancy Code**循环冗余码</p><p><strong>FCSFrame Check (Checking) Sequence</strong>帧检验序列</p><p><strong>ARQAutomatic Repeat reQuest</strong>自动重传请求，通过接收方请求发送方重传出错的数据来回复出错的帧，是通信中用于处理信道所带来查错的方法之一</p><p><strong>SWStay-and-Wait</strong>停止等待协议，流量控制的方法，每次只允许发送一帧，然后等待接收方的确认帧</p><p><strong>GBNGo-Back-N</strong>后退N帧协议，可以连续发送帧，但是接收方只允许按顺序接受帧</p><p><strong>SRSelective Repeat</strong>选择重传协议，设法只重传出现差错的数据帧，发送窗口和接收窗口为$2^{n-1}$个</p><p><strong>FDMFrequency Division Mutiplexing</strong>频分多路复用，将多路基带信号调制到不同频率载波上，再叠加形成一个复合信号(相邻信道需要隔离频道，防止干扰)</p><p><strong>TDMTime Division Mutiplexing</strong>时分多路复用，是将一条物理信道按时间分成若干时间片，轮流地分配给多个信号使用</p><p><strong>WDMWave Division Multiplexing</strong>波分多路复用在一根光纤中传输多种不同波长(频率)的光信号，由于波长(频率)不同，各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来</p><p><strong>CDM(CDMA)Code Division Multiple Access</strong>码分多路复用，每一个用户可以在同样的时间使用同样的频带进行通信，共享时间空间</p><p><strong>ALOHAAddictive Link On-line HAwaii system</strong>分为纯ALOHA和时隙ALOHA，前者是自由发送数据帧，后者只能在每个时隙开始时发送帧，不听就发</p><p><strong>CSMACarrier Sence Multiple Access</strong>载波监听多路访问，分为1-坚持CSMA，非坚持CSMA，p-坚持CSMA，先听再发</p><p><strong>CSMA&#x2F;CDCarrier Sence Multiple Access&#x2F;Collision Detection</strong>载波监听多路访问&#x2F;碰撞检测，应用于有线连接的局域网，先听再发，边听边发，冲突停发，随机重发</p><p><strong>CSMA&#x2F;CACarrier Sence Multiple Access&#x2F;Collision Avoidence</strong>载波监听多路访问&#x2F;碰撞避免，应用于无线连接的局域网</p><p><strong>IFSInter Frame Space</strong>帧间间隔，所有的站点必须在持续检测到信道空闲一段指定时间后才能发送帧</p><p><strong>SIFSShort Inter Frame Space</strong>短帧间间隔，短</p><p><strong>PIFSPoint Inter Frame Space</strong>点协调间隔，中</p><p><strong>DIFSDistributed Inter Frame Space</strong>分布式协调间隔，长</p><p><strong>RTSRequest To Send</strong>请求发送控制帧</p><p><strong>CTSClear To Send</strong>允许发送控制帧</p><p><strong>LANLocal Area Network</strong>局域网</p><p><strong>VLANVirtual Local Area Network</strong>虚拟局域网</p><p><strong>LLCLogic Link Control Layer</strong>逻辑链路控制子层，向网络层提供无确认无连接、面向连接、带确认无连接、高速传送4种不同的连接服务类型</p><p><strong>MACMedium Access Control</strong>介质访问控制子层，向上层屏蔽对物理层访问的各种差异，提供对物理层的统一访问接又，主要功能包括:组帧和拆卸帧、比特传输差错控制、透明传输，用来决定广播信道中信道分配的协议属于数据链路层的一个子层</p><p><strong>MACMedium Access Control</strong>介质访问控制地址，MAC地址是对网络上各接又的唯一标识，而不是对网络上各设备的唯一标识</p><p><strong>PPPPoint to Point Protocol</strong>点对点连接协议，广域网数据链路层协议</p><p><strong>LCPLink Control Protocol</strong>链路控制协议 LCP，用于建立、配置以及测试数据链路的连接(物理)</p><p><strong>NCPNetwork Control Protocol</strong>一套网络控制协议NCPs其中的每一个协议支持不同的网络层协议(逻辑)</p><p><strong>SDNSoftware Define Network</strong>软件定义网络，南向接口北向接口</p><p><strong>IPV4Internet Protocol Version 4</strong></p><p><strong>IPV6Internet Protocol Version 6</strong></p><p><strong>MFMore Fragment</strong>为1时表示后面还有分片</p><p><strong>DF</strong><strong>Don’t Fragment</strong>为1时不允许分片，为0时允许分片</p><p><strong>NATNetwork Address Translation</strong>网络地址转换</p><p><strong>CIDRClassless Inter-Domain Routing</strong>无分类域间路由选择，IP地址的划分方法</p><p><strong>ARPAddress Resolution Protocol</strong>地址解析协议，完成IP地址到MAC地址的映射，工作在网络层</p><p><strong>DHCPDynamic Host Configuration Protocol</strong>动态主机配置协议，用于给主机动态的分配IP地址，应用层协议，基于UDP</p><p><strong>ICMPInternet Control Message Protocol</strong>网际控制报文协议，让主机或路由器报告差错和异常情况，给IP数据报加上一个ICMP首部变为ICMP报文，网络层协议</p><p><strong>PINGPacket Internet Groper</strong>分组网间探测，ICMP的应用，用来测试两主机之间的连通性，工作在应用层</p><p>**ASAutonomous System**自治系统，单一技术管理下的路由器合集</p><p><strong>IGPInterior Gateway Protocol</strong>内部网关协议，在自治系统内部使用的路由选择协议</p><p>​<strong>RIPRouting Information Protocol</strong>路由选择信息协议，IGP协议，分布式的基于距离向量的路由选择协议，应用层协议基于UDP</p><p>​<strong>OSPFOpen Shortest Path First</strong>开放最短路径协议，IGP协议，分布式链路状态路由算法，网络层协议基于IP</p><p><strong>EGPExternal Gateway Protocol</strong>外部网关协议，在两个不同的自治系统之间使用的路由选择协议</p><p>​<strong>BGPBorder Gateway Protocol</strong>边界网关协议，EGP协议，是不同自治系统的路由器之间交换信息的协议，应用层协议基于TCP</p><p><strong>IGMPInternet Group Management Protocol</strong>因特网组管理协议</p><p><strong>UDPUser Datagram Protocol</strong>UDP数据报协议，传输层协议，提供复用，分用和差错检测，无连接不可靠</p><p><strong>TCPTransmission Control Protocol</strong>传输控制协议，提供有连接可靠的服务，让传输可靠有序无丢失不重复</p><p><strong>URGUrgent</strong>紧急位，TCP数据报的标识位，当值为1时表示该数据报为紧急数据，设为最高优先级</p><p><strong>ACKACKnowledgment</strong>确认位，当值为1时确认号字段才有效</p><p><strong>PSHPush</strong>推送位，接受方收到值为1的报文段，应尽快交付给应用进程，与URG效果相同</p><p><strong>RSTReset</strong>复位位，当值为1时，表示TCP连接出现严重差错，必须释放连接</p><p><strong>SYNSynchronous</strong>同步位，当值为1时，表示这是一个连接请求或连接接受报文</p><p><strong>FINFinish</strong>终止位，当值为1时，表示发送方数据发送完毕，要求释放连接</p><p><strong>rwndReceive Window</strong>接收窗口，负责点到点的流量控制</p><p><strong>cwndCrowd Window</strong>拥塞窗口，负责全局性的拥塞控制</p><p><strong>C&#x2F;SClient&#x2F;Service</strong>客户服务器模型，应用层</p><p><strong>P2PPeer To Peer</strong>点对点模型，应用层</p><p><strong>DNSDomain Name System</strong>域名系统，把网址转换为IP地址，使用无连接的UDP数据报，所属应用层</p><p><strong>FTPFile Transfer Protocol</strong>文件传输协议，使用TCP的可靠服务</p><p><strong>UAUser Agent</strong>用户代理，电子邮件的组成结构</p><p><strong>SMTP</strong><strong>Simple Mail Transfer Protocol</strong>邮件发送协议，用于用户代理向邮件服务器发送邮件或在邮件服务器之间发送邮件</p><p><strong>POP3</strong><strong>Post Office Protocol - Version 3</strong>邮件读取协议，用于用户代理从邮件服务器读取邮件，只下载邮件，不做同步</p><p><strong>IMAP</strong><strong>Internet Message Access Protocol</strong>因特网消息访问协议，跟POP3相同作用，下载并同步所有信息，两台电脑上的邮件系统会完全相同</p><p><strong>MIMEMultipurpose Internet Mail Extensions</strong>多用途网络邮件扩充，定义了传送非ASCII码的规则，优化了SMTP</p><p><strong>WWWWorld Wide Web</strong>万维网，一个分布式，联机式的信息存储空间</p><p><strong>URLUniform Resource Locator</strong>统一资源定位符，使每一资源在万维网范围内有唯一标识符</p><p><strong>HTTP</strong>**HyperText Transfer Protocol**超文本传输协议，应用层协议，使用TCP，CS</p><p><strong>HTMLHyperText Markup Language</strong>超文本标记语言，前端语言</p><h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><p>MAR</p><p>MDR</p><p>ALU</p><p>ACC</p><p>IX</p><p>BR</p><p>PSW</p><p>PC</p><p>IR</p><p>CU</p><p>GPRs</p><p>CPI</p><p>MIPS</p><p>RAM</p><p>ROM</p><p>Cache</p><p>SRAMStatic Random </p><p>DRAM</p><p>MROM</p><p>PROM</p><p>EPROM</p><p>SSD</p><p>TLB</p><p>ISA</p><p>EA</p><p>BR</p><p>PC</p><p>IX</p><p>CISC</p><p>RISC</p><p>CM</p><p>CMDR</p><p>CMAR</p><p>SISD</p><p>SIMD</p><p>MIMD</p><p>SMP</p><p>UMA</p><p>NUMA</p><p>DMA</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>KMP串的模式匹配</p><p>BFS广度优先搜索</p><p>DFS深度优先搜索</p><p>MST</p><p>Prim算法</p><p>Kruskal</p><p>Dijkstra</p><p>Floyd</p><p>DAG</p><p>AOV</p><p>ACL</p><p>ASL</p><p>BST</p><p>AVL树</p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p><strong>先来先服务 first-come first-serverd（FCFS）</strong></p><p><strong>最短作业优先 shortest job first（SJF）</strong></p><p><strong>最佳（OPT）置换算法：</strong>从主存中移出永远不再需要的页面；如无这样的页面存在，则选择最长时间不需要访问的页面。于所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。 即被淘汰页面是以后永不使用或最长时间内不再访问的页面。</p><p><strong>先进先出（FIFO）置换算法：</strong>是最简单的页面置换算法。这种算法的基本思想是：当需要淘汰一个页面时，总是选择驻留主存时间最长的页面进行淘汰，即先进入主存的页面先淘汰。其理由是：最早调入主存的页面不再被使用的可能性最大。 即优先淘汰最早进入内存的页面。（往前看）</p><p><strong>最近最久未使用（LRU）算法：</strong>这种算法的基本思想是：利用局部性原理，根据一个作业在执行过程中过去的页面访问历史来推测未来的行为。它认为过去一段时间里不曾被访问过的页面，在最近的将来可能也不会再被访问。所以，这种算法的实质是：当需要淘汰一个页面时，总是选择在最近一段时间内最久不用的页面予以淘汰。 即淘汰最近最长时间未访问过的页面。（往前看）</p><p><strong>时钟(CLOCK)置换算法：</strong></p><p><strong>FCBFile Control Block</strong>文件控制块</p><p><strong>FATFile Allocation Table</strong>文件分配表</p><p>**MBRMaster Boot Record**主引导记录</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机网络&quot;&gt;&lt;a href=&quot;#计算机网络&quot; class=&quot;headerlink&quot; title=&quot;计算机网络&quot;&gt;&lt;/a&gt;计算机网络&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;RTT	Round Trip Time&lt;/strong&gt;	发送数据到接受到接收端的确认，经历的时延	</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://xxsy613.github.io/2023/10/16/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    <id>http://xxsy613.github.io/2023/10/16/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</id>
    <published>2023-10-16T00:58:23.026Z</published>
    <updated>2023-10-30T07:41:07.890Z</updated>
    
    <content type="html"><![CDATA[<p><u>整理自张宇线代九讲</u></p><h1 id="一-行列式"><a href="#一-行列式" class="headerlink" title="一 行列式"></a>一 行列式</h1><h2 id="1-行列式性质"><a href="#1-行列式性质" class="headerlink" title="1 行列式性质"></a>1 行列式性质</h2><ul><li>行列转置值不变</li><li>行列式的单行可拆性</li><li>两行互换加负号</li><li>倍乘，某行的公因数k可提出</li><li>倍加，某行的k倍加至另一行，值不变</li></ul><p>$$<br>|A|\neq 0\to A满秩\to r(A)&#x3D;r([A|B])&#x3D;n\to方程组有唯一解<br>$$</p><h2 id="2-行列式计算方法"><a href="#2-行列式计算方法" class="headerlink" title="2 行列式计算方法"></a>2 行列式计算方法</h2><h3 id="2-1-具体型"><a href="#2-1-具体型" class="headerlink" title="2.1 具体型"></a>2.1 具体型</h3><ul><li><p>余子式，代数余子式，按行按列展开</p></li><li><p>对角线</p><p>主对角线</p><p>副对角线<br>$$<br>(-1)^{\frac{n(n-1)}{2}}<br>$$</p></li><li><p>拉普拉斯（对角线的分块形式）<br>$$<br>(-1)^{mn},m和n为子矩阵的阶数<br>$$</p></li><li><p>范德蒙<br>$$<br>\begin{vmatrix}<br>  1 &amp; 1 &amp; 1 \<br>  x_1 &amp; x_2 &amp; x_3 \<br>  . &amp;.&amp;.\<br>  x_1^{n-1} &amp; x_2^{n-1} &amp; x_3^{n-1} \<br>\end{vmatrix}&#x3D;\prod_{1&lt;i&lt;j&lt;n}^n(x_j-x_i)<br>$$</p></li></ul><p>简单处理：<br>①按零元素多的行或列展开；<br>②用行列式的性质对差别最小的“对应位置元素”进行处理，尽可能多地化出零元素，再按此行或列展开；<br>③对于行和或列和相等的情形，将所有列加到第1列或将所有行加到第1行，提出公因式，再用②</p><p><strong>递推法（高阶——低阶）</strong></p><p><strong>归纳法（低阶——高阶）</strong></p><h3 id="2-2-抽象型"><a href="#2-2-抽象型" class="headerlink" title="2.2 抽象型"></a>2.2 抽象型</h3><p><strong>用行列式性质</strong></p><p><strong>用矩阵知识</strong></p><p>矩阵的值为多项式的特征值连乘</p><p><strong>用相似理论</strong></p><ul><li><p>$$<br>|A|&#x3D;\prod_{i&#x3D;1}^n\lambda_i<br>$$</p></li><li><p>$$<br>|PAP^{-1}|&#x3D;|B|,A相似于B,|A|&#x3D;|B|<br>$$</p></li></ul><p><strong>用特征值</strong><br>$$<br>设A为3阶矩阵，A可逆，其特征值为\lambda_1,\lambda_2,\lambda_3,A^*&#x3D;|A|A^{-1}&#x3D;\lambda_1\lambda_2\lambda_3A^{-1}\<br>A^<em>的特征值为\lambda_1^</em>&#x3D;\lambda_2\lambda_3,\lambda_2^*&#x3D;\lambda_1\lambda_3,\lambda_3^*&#x3D;\lambda_1\lambda_2<br>$$</p><h1 id="第二章-矩阵"><a href="#第二章-矩阵" class="headerlink" title="第二章 矩阵"></a>第二章 矩阵</h1><h2 id="1-题型及解题方法"><a href="#1-题型及解题方法" class="headerlink" title="1 题型及解题方法"></a>1 题型及解题方法</h2><h3 id="1-1-求A-n"><a href="#1-1-求A-n" class="headerlink" title="1.1 求A^n"></a>1.1 求A^n</h3><ul><li><p>A为方阵，且r(A)&#x3D;1<br>$$<br>A^n&#x3D;(tr(A))^{n-1}·A<br>$$</p></li><li><p>试算A^2，A^3，找规律<br>$$<br>若A^2&#x3D;kA,则A^n&#x3D;k^{n-1}A\<br>若A^2&#x3D;kE,则A^{2n}&#x3D;k^nE,A^{2n+1}&#x3D;k^nA<br>$$</p></li><li><p>A分解成B+C<br>$$<br>若A&#x3D;B+C,且BC&#x3D;CB\<br>A^n&#x3D;(B+C)^n&#x3D;B^n+nB^{n-1}C+\frac{n(n-1)}{2!}B^{n-2}C^2+…+C^n\<br>&#x3D;\sum_{n&#x3D;0}^kC_k^n·B^{k-n}·C^n<br>\若B&#x3D;E,则A^n&#x3D;E+nC+\frac{n(n-1)}{2!}C^2+…+C^n\<br>若BC&#x3D;CB&#x3D;0,则 A^n&#x3D;B^n+C^n<br>$$</p></li><li><p>用初等矩阵的知识求P_1^m A P_2^n<br>$$<br>若P_1,P_2均为初等矩阵,m,n为正整数,\则P_1^mAP_2^n表示先对A作了与P_1相同的初等行变换,且<br>重复m次\再对P_1^mA作了与P_2相同的初等列变换,且重复n次。<br>$$</p></li><li><p>用相似理论求A^n<br>$$<br>若A相似于B,即P^{-1}AP&#x3D;B,则A&#x3D;PBP^{-1},A^n&#x3D;PB^nP^{-1}<br>$$</p></li></ul><h3 id="1-2-关于A-，A-1，与初等矩阵"><a href="#1-2-关于A-，A-1，与初等矩阵" class="headerlink" title="1.2 关于A*，A^-1，与初等矩阵"></a>1.2 关于A*，A^-1，与初等矩阵</h3><p>矩阵A B相乘等于C，C的行向量由右边的行向量表示，AB的列向量由左边的列向量表示</p><p><strong>A</strong>*<br>$$<br>AA^*&#x3D;|A|E\<br>|A|^*&#x3D;|A|^{n-1}\<br>(A^*)^T&#x3D;(A^T)^<em>\<br>(kA)^</em>&#x3D;k^{n-1}A^<em>\<br>A^{-1}&#x3D;\frac{1}{|A|}A^</em>\<br>A^*&#x3D;|A|A^{-1}\<br>(A^*)^{-1}&#x3D;\frac{1}{|A|}A&#x3D;(A^{-1})^<em>\<br>(A^</em>)^*&#x3D;|A|^{n-2}A\<br>|(A^*)^*|&#x3D;|A|^{(n-1)^2}\<br>(AB)^*&#x3D;B^<em>A^</em><br>$$</p><p>$A^{-1}$</p><p>2阶矩阵求逆： 主对角元素更换，副对角元素变号，再除以行列式</p><p><em>n阶矩阵可逆的充要条件</em></p><ul><li>|A|不等于0</li><li>r(A)&#x3D;n</li><li>A与单位矩阵等价</li><li>0不是矩阵A的特征值（如果特征值有0则秩就不为n了）</li><li>非零矩阵</li></ul><p><em>矩阵A与B等价的充要条件</em>：PAQ&#x3D;B，PQ互逆<br>$$<br>(kA)^{-1}&#x3D;\frac{1}{k}A^{-1}<br>$$</p><p>$A^T$</p><p>$$A^TA&#x3D;||A||^2$$</p><p><strong>初等矩阵</strong><br>$$<br>E_i^{-1}(k)&#x3D;E_i(\frac{1}{k})\<br>E_{ij}^{-1}(k)&#x3D;E_{ij}(-k)\<br>E_{ij}^{-1}&#x3D;E_{ij}<br>$$</p><h3 id="1-3-分块矩阵"><a href="#1-3-分块矩阵" class="headerlink" title="1.3 分块矩阵"></a>1.3 分块矩阵</h3><p>分块矩阵求逆：主对角取逆，副对角换位取逆，左乘同行，右乘同列，添负号<br>$$<br>已知A&#x3D;\begin{bmatrix}<br>B&amp;O\D&amp;C<br>\end{bmatrix}其中B是r阶可逆矩阵,C是s阶可逆矩阵,且A可逆,则\<br>A^{-1}&#x3D;\begin{bmatrix}<br>B^{-1}&amp;O\-C^{-1}DB^{-1}&amp;C^{-1}<br>\end{bmatrix}<br>$$</p><h3 id="1-4-矩阵方程"><a href="#1-4-矩阵方程" class="headerlink" title="1.4 矩阵方程"></a>1.4 矩阵方程</h3><p>含有未知矩阵的方程</p><h3 id="1-5-矩阵的秩"><a href="#1-5-矩阵的秩" class="headerlink" title="1.5 矩阵的秩"></a>1.5 矩阵的秩</h3><p>$$<br>设A为m×n的矩阵,则\0\leq r(A)\leq min(m,n)\r(kA)&#x3D;r(A)\矩阵初等变换后秩不变,在左边乘上列满秩的矩阵秩不变,在右边乘上行满秩的矩阵秩不变\\若r(AB)&lt;r(A),B为n阶矩阵,则r(B)&lt;n,不满秩\<br>设A是m×n矩阵，B是n×s矩阵，则r(AB)≤min(r_A,r_B)秩越乘越小\<br>$$</p><p><strong>分块阵的秩</strong></p><p>线性无关的向量的个数<br>$$<br>设A是m×n矩阵，B是s×t矩阵，则r(\begin{bmatrix}<br>A&amp;O\O&amp;B<br>\end{bmatrix})&#x3D;r(\begin{bmatrix}<br>O&amp;A\B&amp;O<br>\end{bmatrix}) &#x3D;r(A)+r(B)\<br>设A,B,C均是n阶方阵,则r(A)+r(B)≤r(\begin{bmatrix}<br>A&amp;O\C&amp;B<br>\end{bmatrix})<br>≤r(A)+r(B)+r(C)<br>$$</p><p>$$<br>设A,B为同型矩阵,则r(A+B)≤r([A,B])≤r(A)+r(B)\<br>$$</p><p>$$<br>设A是m×n矩阵,B是n×s矩阵,则r(AB)≥r(A)+r(B)-n\<br>如果AB&#x3D;0,则r(A)+r(B)\leq n(A的列数)<br>$$</p><p>$$<br>设A是m×n实矩阵,则r(A)&#x3D;r(A^T)&#x3D;r(AA^T)&#x3D;r(A^TA).<br>$$</p><p>$$<br>设n阶矩阵A满足A^2-(k_1+k_2)A+k_1k_2E&#x3D;O,k_1≠k_2,则r(A-k_1E)+r(A-k_2,E)&#x3D;n<br>$$</p><p>$$<br>设A是m×n矩阵，则Ax&#x3D;0的基础解系所含向量的个数s&#x3D;n-r(A)<br>$$</p><p>$$<br>方程组A_{m×n}x&#x3D;0与B_{s×n}x&#x3D;0同解,则r(A)&#x3D;r(B)&#x3D;r(A&#x2F;B)<br>$$</p><p>$$<br>若A相似于\Lambda,则n_i&#x3D;n-r(\lambda_iE-A)，其中\lambda_i是n_i重特征根<br>$$</p><p>$$<br>若A相似于\Lambda,则r(A)等于非零特征值的个数，重根按重数算<br>$$</p><p><strong>AB&#x3D;O</strong><br>$$<br>AB&#x3D;O,且B\neq O,则表示齐次方程组Ax&#x3D;0有非零解,所以|A|&#x3D;0\AB&#x3D;O,且B&#x3D; O,则表示齐次方程组Ax&#x3D;0只有零解,所以|A|不一定&#x3D;0\<br>若AB\neq O,则A\neq O,B\neq O<br>$$</p><h1 id="第三章-线性方程组"><a href="#第三章-线性方程组" class="headerlink" title="第三章 线性方程组"></a>第三章 线性方程组</h1><h2 id="1-具体型方程组"><a href="#1-具体型方程组" class="headerlink" title="1 具体型方程组"></a>1 具体型方程组</h2><h3 id="1-1-线性方程组理论"><a href="#1-1-线性方程组理论" class="headerlink" title="1.1 线性方程组理论"></a>1.1 线性方程组理论</h3><p><strong>基础解系</strong></p><p>满足的三个条件：是解，线性无关，$s&#x3D;n-r(A)$</p><p><strong>齐次线性方程组解的判定</strong>：<br>$$<br>r(A)&#x3D;n,只有零解<br>\r(A)&lt;n,有非零解<br>$$<br><strong>非齐次方程组解的判定：</strong><br>$$<br>r(A)&#x3D;r([A&amp;b])&#x3D;n,方程组有唯一解\<br>r(A)&#x3D;r([A&amp;b])&lt;n,方程组有无穷多解\<br>r(A)\neq r([A&amp;b]),方程组无解<br>$$<br><strong>齐次和非齐次通解的形式：</strong><br>$$<br>Ax&#x3D;0:\xi&#x3D;k_1\xi_1+…+k_s\xi_s\Ax&#x3D;\beta:\xi&#x3D;k_1\xi_1+…+k_s\xi_s+\eta\<br>对非齐次: \eta,\eta+\xi_1,\eta+\xi_2,….,\eta+\xi_{n-r}是Ax&#x3D;b的n-r+1个线性无关的解，任一解可以由这些解线性表示<br>$$</p><h3 id="1-2-解线性方程组"><a href="#1-2-解线性方程组" class="headerlink" title="1.2 解线性方程组"></a>1.2 解线性方程组</h3><p><strong>基本方法：</strong></p><p>用初等行变换将齐次方程组的系数矩阵，或非齐次方程组的增广矩阵化为行阶梯矩阵，求出系数矩阵的基础解系为齐次方程的通解，基础解系的k倍加上常数列则为非齐次方程组的通解</p><p><strong>方程个数&#x3D;未知数个数的方程组</strong></p><p>若方程组的系数矩阵中含参数λ，且系数行列式等于f（λ），则 </p><ul><li>$|A|≠0$——方程组有唯一解$f(λ)≠0$，此时可用克拉默法则求解</li><li>$|A|&#x3D;0——f(λ)&#x3D;0$，求出所有零点后，逐个代入方程组、再求解</li><li>注意这个知识点的变体形式：含参数的向量之间的线性关系</li></ul><h3 id="1-3-公共解与同解问题"><a href="#1-3-公共解与同解问题" class="headerlink" title="1.3 公共解与同解问题"></a>1.3 公共解与同解问题</h3><p><strong>公共解</strong></p><ul><li>已知两方程的系数矩阵，联立求解</li><li>已知一方程的系数矩阵和一方程的解系，代入通解求解</li><li>已知两方程的解系，令解系相等</li></ul><p><strong>同解</strong></p><p>$Ax&#x3D;0,Bx&#x3D;0$是同解方程组<br>$\leftrightarrow$互相把解代入满足方程组<br>$\leftrightarrow r(A)&#x3D;r(B)$<br>$\leftrightarrow r(A)&#x3D;r(B)&#x3D;r([\frac{A}{B}])$</p><h2 id="2-抽象型线性方程组"><a href="#2-抽象型线性方程组" class="headerlink" title="2 抽象型线性方程组"></a>2 抽象型线性方程组</h2><p><strong>解的判定和解的结构同具体型</strong></p><h3 id="2-1-解与系数的关系"><a href="#2-1-解与系数的关系" class="headerlink" title="2.1 解与系数的关系"></a>2.1 解与系数的关系</h3><p>若齐次线性方程组，有解$\beta[b_1,b_2,…,b_n]^T$，则$\alpha_i\beta&#x3D;0$，即系数矩阵A的行向量与Ax&#x3D;0的解向量正交</p><h2 id="3-线性方程组的几何意义"><a href="#3-线性方程组的几何意义" class="headerlink" title="3 线性方程组的几何意义"></a>3 线性方程组的几何意义</h2><p>3阶矩阵$A&#x3D;\begin{vmatrix}<br>  a_1 &amp; b_1 &amp; c_1 \<br>  a_2 &amp; b_2 &amp; c_2 \<br>  a_3 &amp;b_3&amp;c_3\<br>\end{vmatrix}$表示平面的法向量，$\overline A&#x3D;\begin{vmatrix}<br>  a_1 &amp; b_1 &amp; c_1 &amp;d_1\<br>  a_2 &amp; b_2 &amp; c_2 &amp;d_2\<br>  a_3 &amp;b_3&amp;c_3&amp;d_3\<br>\end{vmatrix}$，其中d的表示空间中过该平面的一点，用于确定该平面的位置</p><h1 id="第四章-向量组"><a href="#第四章-向量组" class="headerlink" title="第四章 向量组"></a>第四章 向量组</h1><h2 id="1-定理"><a href="#1-定理" class="headerlink" title="1 定理"></a>1 定理</h2><p><strong>线性相关的充要条件：</strong>向量组中至少有一个向量可由其余n-1个向量线性表示</p><p>一个数量多的向量组可以由数量少的向量组线性表示，则多的向量组线性相关，以少表多，多的相关</p><p>高维可以表示低维，低维不能表示高维</p><p>两向量组中被表出的向量组的秩不大</p><p><strong>如果$n&lt;m$，即方程个数小于未知数个数，则齐次线性方程组（*）求解时必有自由未知量， 即必有非零解。因此，任何n+1个n维向量都是线性相关的</strong><br><strong>所以在n维空间中，任何一个线性无关的向量组最多只能含n个向量</strong></p><p>部分相关，整体相关；整体无关，部分无关<br>原来无关，延长（升维）无关；原来有关，缩短（降维）有关关</p><h2 id="2-具体型向量关系"><a href="#2-具体型向量关系" class="headerlink" title="2 具体型向量关系"></a>2 具体型向量关系</h2><p><strong>求极大线性无关组</strong></p><p>步骤：构造向量组的行列式，化成阶梯型，找出一个秩为r的子矩阵</p><h2 id="3-抽象型向量关系"><a href="#3-抽象型向量关系" class="headerlink" title="3 抽象型向量关系"></a>3 抽象型向量关系</h2><p><strong>定义法</strong></p><p><strong>用秩求解</strong></p><h2 id="4-向量组等价"><a href="#4-向量组等价" class="headerlink" title="4 向量组等价"></a>4 向量组等价</h2><p><strong>定义</strong>：两个同维向量组，可以互相线性表示</p><p>等价命题：</p><ul><li>两个向量组秩相同，且可单方向线性表示</li><li>三个向量组的三秩相同</li></ul><h2 id="5-向量空间"><a href="#5-向量空间" class="headerlink" title="5 向量空间"></a>5 向量空间</h2><p>向量组是向量空间的基向量，线性表示的方程为表示空间中任意向量的方程，有序数组$x_1,x_2,…x_r$为向量在基向量下的坐标，所以向量空间可由$V&#x3D;\lbrace\xi&#x3D;x_1\alpha_1+x_2\alpha_2+…+x_r\alpha_r|x_1,x_2,…,x_r\in R\rbrace$</p><p><strong>过渡矩阵</strong>（必考）<br>$$<br>V的两个基\<br>[\eta_1,\eta_2,…\eta_n]&#x3D;[\xi_1,\xi_2,…\xi_n]C\<br>则称C由基\xi_1,\xi_2,…\xi_n到基\eta_1,\eta_2,…\eta_n的过渡矩阵<br>$$</p><h1 id="第五章-特征值与特征向量"><a href="#第五章-特征值与特征向量" class="headerlink" title="第五章 特征值与特征向量"></a>第五章 特征值与特征向量</h1><h2 id="1-特征值相关"><a href="#1-特征值相关" class="headerlink" title="1 特征值相关"></a>1 特征值相关</h2><p>$$<br>\lambda_0是A的特征值\leftrightarrow|\lambda_0E-A|&#x3D;0\<br>\lambda_0不是A的特征值\leftrightarrow|\lambda_0E-A|\neq 0(矩阵可逆，满秩)<br>若|aA+bE|&#x3D;0,a\neq 0,-\frac{b}{a}是A的特征值<br>$$</p><p>$$<br>A^T,A属于不同特征值的特征向量正交\alpha^T\beta&#x3D;0<br>$$</p><p>$$<br>f(x)为多项式，若矩阵A满足f(A)&#x3D;O，\lambda是A的任一特征值，则\lambda满足f(\lambda)&#x3D;0\<br>解得的λ的值只表示范围<br>$$</p><h2 id="2-特征向量相关"><a href="#2-特征向量相关" class="headerlink" title="2 特征向量相关"></a>2 特征向量相关</h2><ul><li>k重特征值$\lambda$至多只有k个线性无关的特征向量</li><li>属于相同特征值的特征向量的线性组合一定是该特征值的特征向量</li><li>属于不同特征值的特征向量的线性组合一定不是任何特征值的特征向量</li><li>设n阶矩阵A，B满足AB&#x3D;BA，且A有n个互不相同的特征值，则A的特征向量都是B的特征向量</li></ul><p>$$<br>A为普通矩阵\<br>\lambda_1\neq\lambda_2\Rightarrow \xi_1,\xi_2线性无关\<br>\lambda_1&#x3D;\lambda_2\Rightarrow \xi_1\xi_2可能线性相关,也可能线性无关<br>$$</p><p>$$<br>A为实对称矩阵\<br>\lambda_1\neq\lambda_2\Rightarrow \xi_1⊥\xi_2\<br>\lambda_1&#x3D;\lambda_2\Rightarrow \xi_1\xi_2线性无关<br>$$</p><h1 id="第六章-相似理论"><a href="#第六章-相似理论" class="headerlink" title="第六章 相似理论"></a>第六章 相似理论</h1><h2 id="1-相似对角化"><a href="#1-相似对角化" class="headerlink" title="1 相似对角化"></a>1 相似对角化</h2><p><strong>充要条件</strong><br>$$<br>n阶矩阵A有n个线性无关的特征向量\Leftrightarrow A\sim\Lambda\<br>n_i&#x3D;n-r(\lambda_iE-A)\Leftrightarrow A\sim\Lambda 其中n_i表示A线性无关的特征向量的个数<br>$$<br><strong>充分条件</strong><br>$$<br>A是实对称矩阵\Rightarrow A\sim\Lambda\<br>A有n个互异特征值\Rightarrow A\sim\Lambda\<br>A^2-k_1k_2A+k_1k_2E&#x3D;0;k_1\neq k_2\Rightarrow A\sim\Lambda\<br>r(A)&#x3D;1;tr(A)\neq 0\Rightarrow A\sim\Lambda\<br>$$<br><strong>必要条件</strong><br>$$<br>A\sim\Lambda\Rightarrow r(A)&#x3D;非零特征值的个数&#x3D;r(\Lambda)<br>$$<br><strong>否定条件</strong><br>$$<br>A\neq O,A^k&#x3D;O\Rightarrow A不可相似对角化\<br>A的特征值全为k，但A\neq kE\Rightarrow A不可相似对角化<br>$$</p><h2 id="2-A相似于B"><a href="#2-A相似于B" class="headerlink" title="2 A相似于B"></a>2 A相似于B</h2><p><strong>五个性质</strong></p><ul><li>$|A|&#x3D;|B|$</li><li>$r(A)&#x3D;r(B)$</li><li>$tr(A)&#x3D;tr(B)$</li><li>$\lambda_A&#x3D;\lambda_B;|\lambda E-A|&#x3D;|\lambda E-B|$</li><li>属于$\lambda_A$的线性无关的特征向量的个数等于属于$\lambda_B$的线性无关的特征向量的个数，$r(\lambda E-A)&#x3D;r(\lambda E-B)$</li></ul><p><strong>重要结论</strong></p><ul><li>$A\sim B\Rightarrow A^T\sim B^{T},A^{-1}\sim B^{-1},A^<em>\sim B^</em>$</li><li>$A\sim B\Rightarrow f(A)\sim f(B)$</li><li>$A\sim \Lambda\Rightarrow f(A)&#x3D;Pf(\Lambda)P^{-1}$</li><li>$A\sim B\Rightarrow $ A的有关f(A)，A逆，A伴随的线性组合与B的相应线性组合相似</li><li>$A\sim B,B\sim C\Rightarrow A\sim C$传递性</li><li>$A\sim \Lambda,B\sim \Lambda\Rightarrow A\sim B$</li></ul><h2 id="3-实对称矩阵与正交矩阵"><a href="#3-实对称矩阵与正交矩阵" class="headerlink" title="3 实对称矩阵与正交矩阵"></a>3 实对称矩阵与正交矩阵</h2><h3 id="3-1-实对称矩阵"><a href="#3-1-实对称矩阵" class="headerlink" title="3.1 实对称矩阵"></a>3.1 实对称矩阵</h3><ul><li>特征值均为实数，特征向量均为实向量</li><li>不同特征值对应的特征向量正交</li><li>可用正交矩阵相似对角化</li><li>A为n阶实对称矩阵$\Rightarrow$A有n个正交的特征向量</li></ul><h3 id="3-2-正交矩阵"><a href="#3-2-正交矩阵" class="headerlink" title="3.2 正交矩阵"></a>3.2 正交矩阵</h3><p><strong>若A为正交矩阵</strong><br>$$<br>A^TA&#x3D;E\Leftrightarrow A^{-1}&#x3D;A^T\\Leftrightarrow A由规范正交基组成（组成A的每一行&#x2F;列均为两两正交的单位向量\<br>\Leftrightarrow A^T是正交矩阵\\Leftrightarrow A^{-1}是正交矩阵\\Leftrightarrow A^*是正交矩阵\\Leftrightarrow -A是正交矩阵<br>$$<br>若A，B为同阶正交矩阵，则AB为正交矩阵，A+B不一定为正交矩阵</p><p>若A为正交矩阵，则其特征值取值范围为{-1,1}，但是只有-1和1</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;u&gt;整理自张宇线代九讲&lt;/u&gt;&lt;/p&gt;
&lt;h1 id=&quot;一-行列式&quot;&gt;&lt;a href=&quot;#一-行列式&quot; class=&quot;headerlink&quot; title=&quot;一 行列式&quot;&gt;&lt;/a&gt;一 行列式&lt;/h1&gt;&lt;h2 id=&quot;1-行列式性质&quot;&gt;&lt;a href=&quot;#1-行列式性质&quot; c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://xxsy613.github.io/2023/10/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://xxsy613.github.io/2023/10/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-10-08T14:28:47.716Z</published>
    <updated>2023-10-30T07:42:50.321Z</updated>
    
    <content type="html"><![CDATA[<p>整理自<a href="https://www.cnblogs.com/wkfvawl/p/14407427.html%E4%BB%85%E7%A7%81%E7%94%A8">https://www.cnblogs.com/wkfvawl/p/14407427.html仅私用</a></p><h1 id="第一章-计算机系统概述"><a href="#第一章-计算机系统概述" class="headerlink" title="第一章 计算机系统概述"></a>第一章 计算机系统概述</h1><p><img src="https://img2020.cnblogs.com/blog/1358881/202101/1358881-20210131202554260-1557827476.png" alt="img"></p><h2 id="1-操作系统的目标和功能"><a href="#1-操作系统的目标和功能" class="headerlink" title="1.操作系统的目标和功能"></a>1.操作系统的目标和功能</h2><p><strong>1.操作系统是计算机资源的管理者</strong></p><ul><li><strong>处理机管理</strong>（进程控制、进程同步、进程通信、死锁处理、处理机调度）</li><li><strong>存储器管理</strong>（提高内存利用率，内存的分配与回收、地址映射、内存保护与共享、内存扩充）</li><li><strong>文件管理</strong>（计算机中的信息都是以文件的形式存在的）</li><li><strong>设备管理</strong>（完成用户的I&#x2F;O请求，方便用户使用设备、并提高设备的利用率）</li></ul><p><strong>2.操作系统为用户提供使用计算机硬件系统的接口</strong></p><ul><li><strong>命令接口</strong>（用户通过控制台或终端输入操作命令，向系统提供各种服务要求）</li><li><strong>程序接口</strong>（由 系统调用 组成，用户在程序中使用这些系统调用来请求操作系统为其提供服务）</li><li><strong>图形接口</strong> 最常见的 图形用户界面GUI （最终还是通过调用程序接口实现的）</li></ul><p><strong>3.操作系统用作扩充机器</strong><br>没有任何软件支持的计算机称为<strong>裸机</strong>，实际呈现在用户面前的计算机系统是经过若干层软件改造的计算机。操作系统将裸机改造成功能更强、使用更方便的机器。我们将覆盖了软件的机器称为扩充机器或虚拟机。</p><h2 id="2-操作系统的运行机制"><a href="#2-操作系统的运行机制" class="headerlink" title="2.操作系统的运行机制"></a>2.操作系统的运行机制</h2><p><strong>1.内核程序和应用程序(内核态和用户态)</strong><br>在计算机系统中，通常CPU执行两种不同性质的程序：一种是操作系统内核程序；另一种是用户自编程序或系统外层的应用程序。内核程序是应用程序的”管理者”。“管理程序“可以执行一些特权指令，而”被管理程序“出于安全考虑不能执行这些指令。所谓特权指令，是指计算机中不允许用户直接使用的指令，如：I&#x2F;O指令、置中断指令，存取用于内存保护的寄存器，送程序状态字到程序状态字寄存器等指令。<br>操作系统在具体实现上划分了<strong>用户态（目态）</strong>和<strong>核心态（管态）</strong>，以严格区分两类程序。<br><strong>2.层次式结构</strong><br>操作系统的各项功能分别被设置在不同的层次上。一些与硬件关联较紧密的模块，诸如时钟管理、中断管理、设备驱动等处于最底层。其次是运行频率较高的程序，诸如进程管理、存储管理和设备管理等。 上面的这两部分内容构成了操作系统的内核，这部分内容的指令操作工作在核心态。<br><strong>3.内核</strong><br>内核是计算机上配置的底层软件，是计算机功能的延伸，包括以下4个方面的内容：<br>1）<strong>时钟管理</strong> 时钟的第一功能是计时，操作系统需要通过时钟管理，向用户提供标准的系统时间。其次，通过时钟中断的管理，可以实现进程的切换。在分时操作系统中，采用时间片轮转调度的实现；在实时系统中，按截至时间控制运行的实现；在批处理系统中，通过时钟管理来衡量一个作业的运行程度等。<br>2）<strong>中断机制</strong> 引入中断技术的初衷是提高多道程序运行环境中CPU的利用率，主要针对外部设备。后来逐步得到发展，形成了多种类型，成为操作系统各项操作的基础。如，键盘或鼠标信息的输入、进程的管理和调度、系统功能的调用、设备驱动、文件访问等。都依赖于中断机制。可以说，现代操作系统是靠中断驱动的软件。中断机制中，只有一小部分功能属于内核，负责保护和恢复中断现场的信息，转移控制权到相关的处理程序。这样可以减少中断的处理时间，提高系统的并行处理能力。<br>3）<strong>原语</strong> 操作系统底层是一些可被调用的公用小程序，它们各自完成一个规定的操作，其特点是：</p><ul><li>它们处于操作系统的最底层，是最接近硬件的部分。</li><li>这些程序的运行具有原子性，其操作只能一气呵成</li><li>这些程序的运行时间都较短，而且调用频繁。</li></ul><p>定义原语的直接方法是关闭中断，让它的所有动作不可分割地进行完再打开中断。<br>4）<strong>系统控制的数据结构及处理</strong> 系统中用来登记状态信息的数据结构很多，比如：作业控制块、进程控制块、设备控制块、各类链表等。为了实现有效的管理，系统需要一些基本的操作，常见的操作有以下三种：</p><ul><li><strong>进程管理</strong>：进程状态管理、进程调度和分配、创建和撤销进程控制块等。</li><li><strong>存储器管理</strong>：存储器的空间分配和回收、内存信息保护程序、代码对换程序等。</li><li><strong>设备管理</strong>：缓冲区管理、设备分配和回收等。</li></ul><h2 id="3-中断和异常"><a href="#3-中断和异常" class="headerlink" title="3.中断和异常"></a>3.中断和异常</h2><p><strong>1.中断的引入——为了支持CPU和设备之间的并行操作</strong></p><p>中断也称外中断，指来自CPU执行指令以外的事件的发生，如设备发出的I&#x2F;O结束中断、时钟中断<br>等。这一类中断通常是与当前执行的指令无关的事件。<br><strong>2.异常的引入——表示CPU执行指令本身时出现的问题</strong><br>异常也称内中断、例外或陷入，指源自CPU执行指令内部的事件，如程序的非法操作码、地址越界、算术溢出、缺页异常等。对异常的处理一般要依赖与当前程序的运行现场，不能被屏蔽。<br><strong>3.中断和异常的联系与区别</strong></p><p><img src="https://img2020.cnblogs.com/blog/1358881/202101/1358881-20210131203424936-732097698.png" alt="img"></p><p><strong>4.中断执行的流程</strong></p><p><strong><img src="https://img2020.cnblogs.com/blog/1358881/202101/1358881-20210131203515309-1558716556.png" alt="img"></strong></p><p>以上是多重中断的流程，其中，1~3步是由硬件（中断隐指令）完成的；4-9步是由中断服务程序<br>完成的。</p><h2 id="4-系统调用"><a href="#4-系统调用" class="headerlink" title="4.系统调用"></a>4.系统调用</h2><p>计算机系统的各种硬件资源是有限，为了更好的管理这些资源，进程是不允许直接操作的，所有对这些资源的访问都必须有操作系统控制。也就是说操作系统是使用这些资源的唯一入口，而这个入口就是操作系统提供的系统调用。一般地，系统调用都是通过中断实现的，比如，linux下中断号0x80就是进行系统调用的。<br>操作系统为用户态进程与硬件设备进行交互提供了一组接口——系统调用:1.把用户从底层的硬件编程中解放了出来;2.极大地提高了系统的安全性使用户程序具有可移植性；用户程序与具体硬件已经被抽象接口所替代。<br>系统调用流程图如下</p><p><img src="https://img2020.cnblogs.com/blog/1358881/202101/1358881-20210131203937554-856937188.png" alt="img"></p><h2 id="5-大内核和微内核"><a href="#5-大内核和微内核" class="headerlink" title="5.大内核和微内核"></a>5.大内核和微内核</h2><p><strong>1.大内核</strong><br>大内核是将操作系统功能作为一个紧密结合的整体放到内核。由于各模块共享信息，因此有很高的性能。<br><strong>2.微内核</strong><br>由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。<br>在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。</p><p>因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。</p><p><img src="https://img2020.cnblogs.com/blog/1358881/202102/1358881-20210216110019787-622445921.png" alt="img"></p><h1 id="第二章-进程管理"><a href="#第二章-进程管理" class="headerlink" title="第二章 进程管理"></a>第二章 进程管理</h1><p><img src="https://img2020.cnblogs.com/blog/1358881/202102/1358881-20210216110302082-1321686745.png" alt="img"></p><h2 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1.进程与线程"></a>1.进程与线程</h2><p><strong>1.进程的概念与定义</strong><br>在多道程序环境下，允许多个进程并发执行，此时他们将失去封闭性，并具有间断性及不可再现性的特征。为此引入了进程的概念，以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性。<strong>进程是程序的运行过程，是系统进行资源分配和调度的一个独立单位。</strong></p><p><strong>2.线程的概念和定义</strong><br>早期，在OS中能拥有资源和独立运行的基本单位是进程，然而随着计算机技术的发展，进程出现了很多弊端，一是由于进程是资源拥有者，创建、撤消与切换存在较大的时空开销，因此需要引入轻型进程；二是由于对称多处理机（SMP）出现，可以满足多个运行单位，而多个进程并行开销过大。<strong>线程是操作系统能够进行运算调度的最小单位。</strong>它被包含在进程之中，是进程中的实际运作单位。<strong>一条线程指的是进程中一个单一顺序的控制流，每条线程执行不同的任务。</strong></p><p><strong>3.进程和线程的区别</strong></p><ul><li>进程（Process）是系统进行资源分配和调度的基本单位，线程（Thread）是CPU调度和分派的基本单位；</li><li>线程依赖于进程而存在，一个进程至少有一个线程；</li><li>进程有自己的独立地址空间，线程共享所属进程的地址空间；</li><li>进程是拥有系统资源的一个独立单位，而线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，和其他线程共享本进程的相关资源如内存、I&#x2F;O、cpu等；</li><li>在进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作，可见，进程切换的开销远大于线程切换的开销；</li><li>线程之间的通信更方便，同一进程下的线程共享全局变量等数据，而进程之间的通信需要以进程间通信(IPC)的方式进行；</li><li>多线程程序只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其它进程造成影响，因为进程有自己的独立地址空间，因此多进程更加健壮</li></ul><p><strong>4.进程和程序的区别</strong></p><ul><li>程序是永存的；进程是暂时的，是程序在数据集上的一次执行，有创建有撤销，存在是暂时的；</li><li>程序是静态的观念，进程是动态的观念；</li><li>进程具有并发性，而程序没有；</li><li>进程是竞争计算机资源的基本单位，程序不是。</li><li>进程和程序不是一一对应的： 一个程序可对应多个进程即多个进程可执行同一程序； 一个进程可以执行一个或几个程序</li></ul><h2 id="2-进程的通信方式"><a href="#2-进程的通信方式" class="headerlink" title="2.进程的通信方式"></a>2.进程的通信方式</h2><p><strong>1.共享内存</strong><br>顾名思义，共享内存就是两个进程同时共享一块内存，然后在这块内存上的数据可以共同修改和读取，达到通信的目的。<br><strong>2.无名管道</strong><br>无名管道是半双工的通信方式；并且只能在具有亲缘关系的进程之间使用（亲缘关系是指进程间的父子关系，兄弟关系等），具有亲缘关系的进程在创建时同时拥有一个无名管道的句柄，可以进行读写；无名管道不存在磁盘节点，只存在与内存中用完即销毁。<br><strong>3.命名管道</strong><br>命名管道也是半双工的通信方式；可以在不具有亲缘关系的进程间通信；有名管道存在磁盘节点，有对应的FIFO文件，凡是可以访问该路径的文件的进程均可以进行通信。<br><strong>4.消息队列</strong><br>消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。<br><strong>5.套接字</strong><br>套接字是网络编程的api，通过套接字可以不同的机器间的进程进行通信，常用于客户端进程和服务器进程的通信。<br><strong>6.信号</strong><br>信号是Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。一个键盘中断或者一个错误条件（比如进程试图访问它的虚拟内存中不存在的位置等）都有可能产生一个信号。Shell也使用信号向它的子进程发送作业控制信号。</p><h2 id="3-进程的5种状态及转换过程"><a href="#3-进程的5种状态及转换过程" class="headerlink" title="3.进程的5种状态及转换过程"></a>3.进程的5种状态及转换过程</h2><p><img src="https://img2020.cnblogs.com/blog/1358881/202102/1358881-20210216112304409-947781658.png" alt="img"></p><h2 id="4-进程的调度算法"><a href="#4-进程的调度算法" class="headerlink" title="4.进程的调度算法"></a>4.进程的调度算法</h2><p><strong>1.先来先服务 first-come first-serverd（FCFS）</strong><br>按照请求的顺序进行调度。非抢占式，开销小，无饥饿问题，响应时间不确定（可能很慢）；对短进程不利，对IO密集型进程不利。<br><strong>2.最短作业优先 shortest job first（SJF）</strong><br>按估计运行时间最短的顺序进行调度。非抢占式，吞吐量高，开销可能较大，可能导致饥饿问题；对短进程提供好的响应时间，对长进程不利<br><strong>3.优先级调度算法</strong><br>为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。<br><strong>4.时间片轮转</strong><br>将所有就绪进程按 FCFS 的原则排成一个队列，用完时间片的进程排到队列最后。抢占式（时间片用完时），开销小，无饥饿问题，为短进程提供好的响应时间；若时间片小，进程切换频繁，吞吐量低；若时间片太长，实时性得不到保证。<br><strong>5.最高响应比优先</strong><br>响应比 &#x3D; 1+ 等待时间&#x2F;处理时间。同时考虑了等待时间的长短和估计需要的执行时间长短，很好的平衡了长短进程。非抢占，吞吐量高，开销可能较大，提供好的响应时间，无饥饿问题。<br><strong>6.多级反馈队列调度算法</strong><br>设置多个就绪队列1、2、3…，优先级递减，时间片递增。只有等到优先级更高的队列为空时才会调度当前队列中的进程。如果进程用完了当前队列的时间片还未执行完，则会被移到下一队列。抢占式（时间片用完时），开销可能较大，对IO型进程有利，可能会出现饥饿问题。</p><h2 id="5-同步和互斥"><a href="#5-同步和互斥" class="headerlink" title="5.同步和互斥"></a>5.同步和互斥</h2><p><strong>1.同步</strong><br>多个进程因为合作而使得进程的执行有一定的先后顺序。比如某个进程需要另一个进程提供的消息，获得消息之前进入阻塞态；<br><strong>2.互斥</strong><br>多个进程在同一时刻只有一个进程能进入临界区<br><strong>3.同步机制的4个准则</strong></p><ul><li>空闲让进：当无进程处于临界区，可允许一个请求进入临界区的进程立即进入自己的临界区</li><li>忙则等待：当已有进程进入自己的临界区，所有企图进入临界区的进程必须等待</li><li>有限等待：对要求访问临界资源的进程，应保证该进程能在有限时间内进入自己的临界区</li><li>让权等待：当进程不能进入自己的临界区，应释放处理机</li></ul><h2 id="6-进程同步相关概念"><a href="#6-进程同步相关概念" class="headerlink" title="6.进程同步相关概念"></a>6.进程同步相关概念</h2><p>为什么需要进程同步：进程有时候会和其他进程共享一些资源，比如内存、数据库等。当多个进程同时读写同一份共享资源的时候，可能会发生冲突。因此需要进程的同步，多个进程按顺序访问资源。<br><strong>互斥量 Mutex：</strong>互斥量是内核对象，只有拥有互斥对象的线程才有访问互斥资源的权限。因为互斥对象只有一个，所以可以保证互斥资源不会被多个线程同时访问；当前拥有互斥对象的线程处理完任务后必须将互斥对象交出，以便其他线程访问该资源；<br><strong>信号量 Semaphore：</strong>信号量是内核对象，它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。信号量对象保存了最大资源计数和当前可用资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就减1，只要当前可用资源计数大于0，就可以发出信号量信号，如果为0，则将线程放入一个队列中等待。线程处理完共享资源后，应在离开的同时通过 ReleaseSemaphore 函数将当前可用资源数加1。如果信号量的取值只能为0或1，那么信号量就成为了互斥量；<br><strong>事件 Event：</strong>允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。事件分为手动重置事件和自动重置事件。手动重置事件被设置为激发状态后，会唤醒所有等待的线程，而且一直保持为激发状态，直到程序重新把它设置为未激发状态。自动重置事件被设置为激发状态后，会唤醒一个等待中的线程，然后自动恢复为未激发状态。<br><strong>临界区 Critical Section：</strong>指的是访问资源的那段代码，任意时刻只允许一个线程对临界资源进行访问。拥有临界区对象的线程可以访问该临界资源，其它试图访问该资源的线程将被挂起，直到临界区对象被释放。</p><h2 id="7-死锁"><a href="#7-死锁" class="headerlink" title="7.死锁"></a>7.死锁</h2><p><strong>1.死锁的定义</strong><br>是指两个或两个以上的进程在执行过程中，<strong>因争夺资源而造成的一种互相等待的现象</strong>，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。<br><strong>2.死锁原因</strong></p><ul><li>系统资源不足（对不可剥夺资源的竞争）</li><li>进程推进顺序不当（P1拥有A申请B，P2拥有B申请A）</li></ul><p><strong>3.产生死锁的必要条件</strong></p><ul><li>互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。</li><li>请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li><li>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放</li><li>环路等待条件：指在发生死锁时，必然存在一个进程资源的环形链。</li></ul><p><strong>4.处理死锁的基本方法</strong></p><ul><li><strong>预防死锁：</strong>这是一种较简单和直观的事先预防的方法。方法是通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或者几个，来预防发生死锁。预防死锁是一种较易实现的方法，已被广泛使用。但是由于所施加的限制条件往往太严格，可能会导致系统资源利用率和系统吞吐量降低。</li><li><strong>避免死锁：</strong>该方法同样是属于事先预防的策略，但它并不须事先采取各种限制措施去破坏产生死锁的的四个必要条件，而是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。</li><li><strong>检测死锁：</strong>这种方法并不须事先采取任何限制性措施，也不必检查系统是否已经进入不安全区，此方法允许系统在运行过程中发生死锁。但可通过系统所设置的检测机构，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源，然后采取适当措施，从系统中将已发生的死锁清除掉。</li><li><strong>解除死锁：</strong>这是与检测死锁相配套的一种措施。当检测到系统中已发生死锁时，须将进程从死锁状态中解脱出来。常用的实施方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。</li></ul><h2 id="8-饥饿"><a href="#8-饥饿" class="headerlink" title="8.饥饿"></a>8.饥饿</h2><p>等待时间给进程推进和响应带来明显影响时成为进程饥饿。<br>饥饿并不代表系统已经死锁，但至少有一个程序的执行被无限期地推迟。<br><strong>与死锁差别：</strong></p><ul><li>进入饥饿的进程可以只有一个，但是死锁必须大于等于两个；</li><li>处于饥饿状态的进程可以是一个就绪进程，但是死锁状态的进程必定是阻塞进程。</li></ul><h2 id="9-银行家算法"><a href="#9-银行家算法" class="headerlink" title="9.银行家算法"></a>9.银行家算法</h2><p>主要思想是避免系统进入不安全状态，在每次进行资源分配时，它首先检查系统是否有足够的资源满足要求，如果有，则先试行分配，并对分配后的新状态进行安全性检查。如果新状态安全，则正式分配上述资源，否则拒绝分配上述资源。这样就保证系统始终处于安全状态，从而避免死锁现象的发生。</p><h2 id="10-死锁定理"><a href="#10-死锁定理" class="headerlink" title="10.死锁定理"></a>10.死锁定理</h2><p>如果资源分配图是可以完全简化的（能消去所有的边），则没有死锁</p><h1 id="第三章-内存管理"><a href="#第三章-内存管理" class="headerlink" title="第三章 内存管理"></a>第三章 内存管理</h1><p><img src="https://img2020.cnblogs.com/blog/1358881/202102/1358881-20210216115945604-1204739333.png" alt="img"></p><h2 id="1-存储器管理的功能"><a href="#1-存储器管理的功能" class="headerlink" title="1.存储器管理的功能"></a>1.存储器管理的功能</h2><p>存储管理的主要任务是为多道程序的运行提供良好的环境，方便用户使用存储器，提高存储器的利用率以及从逻辑上扩充存储器，故应具有以下功能：</p><ul><li>内存的分配和回收：实施内存的分配，回收系统或用户释放的内存空间。</li><li>地址变换：提供地址变换功能，将逻辑地址转换成物理地址。</li><li>扩充内存：借助于虚拟存储技术活其他自动覆盖技术，为用户提供比内存空间大的地址空间，从逻辑上扩充内存。</li><li>存储保护：保证进入内存的各道作业都在自己的存储空间内运行，互不干扰。</li></ul><h2 id="2-将用户程序变为可在内存中执行的程序的步骤"><a href="#2-将用户程序变为可在内存中执行的程序的步骤" class="headerlink" title="2.将用户程序变为可在内存中执行的程序的步骤"></a>2.将用户程序变为可在内存中执行的程序的步骤</h2><ul><li>编译：由编译程序将用户源代码编译成若干目标模块</li><li>汇编：产生二进制目标文件</li><li>链接：产生可执行文件，由链接程序将编译后形成的一组目标模块及所需的库函数链接在一起，形成一个完整的装入模块，形成逻辑地址</li><li>装入：将逻辑地址转换为物理地址，由装入程序将装入模块装入内存中运行。</li></ul><p><img src="https://img2020.cnblogs.com/blog/1358881/202102/1358881-20210216192459401-156747795.png" alt="img"></p><h2 id="3-程序的链接方式"><a href="#3-程序的链接方式" class="headerlink" title="3.程序的链接方式"></a>3.程序的链接方式</h2><ul><li>静态链接：在程序运行之前，先把各个目标模块及所需库链接为一个完整的可执行程序，以后不再拆开。</li><li>装入时动态链接：将应用程序编译后所得到的一组目标模块在装入内存时采用***边装入边链接***的链接方式。</li><li>运行时动态链接：知道程序运行过程中需要一些模块时，才对这些模块进行链接。</li></ul><h2 id="4-程序的装入方式"><a href="#4-程序的装入方式" class="headerlink" title="4.程序的装入方式"></a>4.程序的装入方式</h2><p>凡是分区固定的都会产生内部碎片，分区不固定的会产生外部碎片</p><table><thead><tr><th>装入方式</th><th>所属步骤</th><th></th></tr></thead><tbody><tr><td>静态装入</td><td>编制阶段计算好物理地址</td><td></td></tr><tr><td>可重定位装入</td><td>装入时把逻辑地址转为物理地址，不可改变</td><td></td></tr><tr><td>动态重定位装入</td><td>执行时再决定装入的地址并装入，装入后可能会换出</td><td></td></tr></tbody></table><ul><li><strong>绝对装入</strong>：在编译时就知道程序将要驻留在内存的物理地址，编译程序产生含有物理地址的目标代码，不适合多道程序设计。</li><li><strong>可重定位装入</strong>：根据内存当前情况，将装入模块装入到内存的适当位置，地址变换通常在装入时一次完成，之后不再改变，也称静态重定位。当操作系统为程序分配一个以某地址为起始地址的连续主存区域后，重定位时将程序中指令或操作数的逻辑地址加上这个起始地址就得到了物理地址。</li><li><strong>动态运行装入</strong>：允许程序运行时在内存中移动位置，把装入模块装入到内存后的所有地址都是相对地址，在程序执行过程中每当访问到相应指令或数据时，才将要 访问的程序或数据的相对地址转换为物理地址。动态重定位的实现要依靠硬件地址变换机构。</li></ul><h2 id="5-覆盖技术和交换技术"><a href="#5-覆盖技术和交换技术" class="headerlink" title="5.覆盖技术和交换技术"></a>5.覆盖技术和交换技术</h2><p><strong>1.覆盖技术：</strong><br>把一个大的程序划分为一系列覆盖，每个覆盖是一个相对独立的程序单位，把程序执行时并不要求同时装入内存的覆盖组成一组，成为覆盖段，这个覆盖段分配到同一个存储区域，这个存储区域成为覆盖区，它与覆盖段一一对应。覆盖段的大小由覆盖段中最大的覆盖来确定。（为了解决内存容量太小的问题，打破了必须将一个程序全部信息装入内存后才能运行的限制）<br><strong>2.交换技术：</strong><br>把暂时不用的某个程序及数据部分从内存移到外存中去，以便腾出必要的内存空间；或者把指定的程序或数据从外存读到相应的内存中，并将控制权交给他，让其在系统上运行的一种内存扩充技术。处理器的中级调度就是采用交换技术。<br><strong>3.区别：</strong></p><ul><li>与覆盖技术相比，交换技术不要求程序员给出的 程序段之间的覆盖结构；</li><li>交换技术主要在进程和作业之间进行，覆盖技术主要在同一个进程或作业中进行；交换技术主要在进程和作业之间进行，覆盖技术主要在同一个进程或作业中进行；</li><li>覆盖技术只能覆盖于覆盖程序段无关的程序段，交换进程由换出和换入两个过程组成。覆盖技术只能覆盖于覆盖程序段无关的程序段，交换进程由换出和换入两个过程组成。</li></ul><h2 id="6-内存连续分配管理方式"><a href="#6-内存连续分配管理方式" class="headerlink" title="6.内存连续分配管理方式"></a>6.内存连续分配管理方式</h2><p><strong>1.单一连续分配</strong><br>内存在此方式下分为系统区和用户区，系统区仅提供给操作系统使用，通常在低地址部分；用户区是为用户提供的、除系统区之外的内存空间。这种方式无需进行内存保护。<br>这种方式的优点是简单、无外部碎片，可以釆用覆盖技术，不需要额外的技术支持。缺点是只能用于单用户、单任务的操作系统中，有内部碎片，存储器的利用率极低。<br><strong>2.固定分区分配</strong><br>固定分区分配是最简单的一种多道程序存储管理方式，它将用户内存空间划分为若干个固定大小的区域，每个分区只装入一道作业。当有空闲分区时，便可以再从外存的后备作业队列中,选择适当大小的作业装入该分区，如此循环。固定分区分配在划分分区时，有两种不同的方法。<br>(1) 分区大小相等：用于利用一台计算机去控制多个相同对象的场合，缺乏灵活性。<br>(2) 分区大小不等：划分为含有多个较小的分区、适量的中等分区及少量的大分区。<br><strong>3.动态分区分配</strong><br>动态分区分配又称为可变分区分配，是一种动态划分内存的分区方法。这种分区方法不预先将内存划分，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统中分区的大小和数目是可变的。<br><strong>4.动态分区分配算法</strong><br>在进程装入或换入主存时，如果内存中有多个足够大的空闲块，操作系统必须确定分配哪个内存块给进程使用，这就是动态分区的分配策略，考虑以下几种算法：</p><ul><li>首次适应(First Fit)算法：空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。</li><li>最佳适应(Best Fit)算法：空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区。</li><li>最坏适应(Worst Fit)算法：又称最大适应(Largest Fit)算法，空闲分区以容量递减的次序链接。找到第一个能满足要求的空闲分区，也就是挑选出最大的分区。</li><li>邻近适应(Next Fit)算法：又称循环首次适应算法，由首次适应算法演变而成。不同之处是分配内存时从上次查找结束的位置开始继续查找。</li></ul><h2 id="7-基本分页和请求分页内存管理方式"><a href="#7-基本分页和请求分页内存管理方式" class="headerlink" title="7.基本分页和请求分页内存管理方式"></a>7.基本分页和请求分页内存管理方式</h2><ul><li><p>在系统中设置一个页表寄存器，它存放着页表在内存中的始址和长度。在进程未执行时，页表的始址和页表长度存放在本进程的PCB中，当调度到某进程时，才将这两个数据装入页表寄存器中。每个进程有一张属于自己的页表</p></li><li><table><thead><tr><th>名称</th><th>意义</th></tr></thead><tbody><tr><td>页，页面</td><td>将用户进程的地址空间分成与页框大小相等的区域，划分逻辑空间</td></tr><tr><td>页框，页帧，物理块，内存块，物理页面</td><td>将内存空间划分为大小相等的区域，划分物理空间</td></tr><tr><td>页号</td><td>页的编号</td></tr><tr><td>页内偏移量</td><td>页内地址</td></tr><tr><td>页面大小</td><td>指一个页面占有多大的存储空间，决定页内偏移量</td></tr><tr><td>页表大小</td><td>页表在内存中占用的大小</td></tr><tr><td>页表长度，页面长度</td><td>表示页表中有多少页表项，用来检测页号是否越界</td></tr><tr><td>页表项长度</td><td>表示每个页表项占多大的存储空间</td></tr><tr><td>块号</td><td>每页在内存中的物理块号</td></tr></tbody></table></li></ul><p><strong>分段，分页管理的区别</strong></p><ul><li><p>页是信息的<u>物理单位</u>。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管 理上的需要，完全是系统行为，对用户是不可见的。</p><p>段是信息的<u>逻辑单位</u>。分页的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻 辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。 页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。</p></li><li><p>分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。</p><p>分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。</p></li><li><p>分段比分页更容易实现信息的共享和保护。不能被修改的代码称为纯代码或可重入代码（不属于临 界资源)，这样的代码是可以共享的。可修改的代码是不能共享的</p></li><li><p>访问一个逻辑地址需要几次访存？</p><p>分页（单级页表）：第一次访存一一查内存中的页表，第二次访存一一访问目标内存单元。总共两次 访存</p><p>分段：第一次访存一一查内存中的段表，第二次访存一一访问目标内存单元。总共两次访存</p><p>与分页系统类似，分段系统中也可以引入决表机构，将近期访问过的段表项放到快表中，这样可以 少一次访问，加快地址变换速度。</p></li></ul><h2 id="8-页面置换算法"><a href="#8-页面置换算法" class="headerlink" title="8.页面置换算法"></a>8.页面置换算法</h2><ul><li><strong>最佳（OPT）置换算法：</strong>从主存中移出永远不再需要的页面；如无这样的页面存在，则选择最长时间不需要访问的页面。于所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。 即被淘汰页面是以后永不使用或最长时间内不再访问的页面。</li><li><strong>先进先出（FIFO）置换算法：</strong>是最简单的页面置换算法。这种算法的基本思想是：当需要淘汰一个页面时，总是选择驻留主存时间最长的页面进行淘汰，即先进入主存的页面先淘汰。其理由是：最早调入主存的页面不再被使用的可能性最大。 即优先淘汰最早进入内存的页面。（往前看）</li><li><strong>最近最久未使用（LRU）算法：</strong>这种算法的基本思想是：利用局部性原理，根据一个作业在执行过程中过去的页面访问历史来推测未来的行为。它认为过去一段时间里不曾被访问过的页面，在最近的将来可能也不会再被访问。所以，这种算法的实质是：当需要淘汰一个页面时，总是选择在最近一段时间内最久不用的页面予以淘汰。 即淘汰最近最长时间未访问过的页面。（往前看）</li><li><strong>时钟(CLOCK)置换算法：</strong>LRU算法的性能接近于OPT,但是实现起来比较困难，且开销大；FIFO算法实现简单，但性能差。所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是CLOCK算法的变体。简单的CLOCK算法是给每一帧关联一个附加位，称为使用位。当某一页首次装入主存时，该帧的使用位设置为1;当该页随后再被访问到时，它的使用位也被置为1。对于页替换算法，用于替换的候选帧集合看做一个循环缓冲区，并且有一个指针与之相关联。当某一页被替换时，该指针被设置成指向缓冲区中的下一帧。当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧。每当遇到一个使用位为1的帧时，操作系统就将该位重新置为0；如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换；如果所有帧的使用位均为1,则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。由于该算法循环地检查各页面的情况，故称为CLOCK算法，又称为最近未用(Not RecentlyUsed, NRU)算法。<ul><li>(u&#x3D;0, m&#x3D;0) 没有使用也没有修改，被逐出的优先级最高；</li><li>(u&#x3D;1, m&#x3D;0) 使用过，但是没有修改过，优先级第二；</li><li>(u&#x3D;0, m&#x3D;1) 没有使用过，但是修改过，优先级第三；</li><li>(u&#x3D;1, m&#x3D;1) 使用过也修改过，优先级第四。</li></ul></li></ul><h2 id="9-页表和快表"><a href="#9-页表和快表" class="headerlink" title="9.页表和快表"></a>9.页表和快表</h2><p>页表指出<strong>逻辑地址中的页号与所占主存块号的对应关系</strong>。</p><p>作用：页式存储管理在用动态重定位方式装入作业时，要利用页表做地址转换工作。<strong>快表就是存放在高速缓冲存储器的部分页表。它起页表相同的作用。</strong>由于采用页表做地址转换，读写内存数据时CPU要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p><h2 id="10-地址翻译的过程"><a href="#10-地址翻译的过程" class="headerlink" title="10.地址翻译的过程"></a>10.地址翻译的过程</h2><p>TLB-&gt;页表（TLB不命中）-&gt;Cache-&gt;主存（Cache不命中）-&gt;外存</p><h1 id="第四章-文件管理"><a href="#第四章-文件管理" class="headerlink" title="第四章 文件管理"></a>第四章 文件管理</h1><p><img src="https://img2020.cnblogs.com/blog/1358881/202102/1358881-20210216200311860-1626798222.png" alt="img"></p><h2 id="1-文件的基本操作"><a href="#1-文件的基本操作" class="headerlink" title="1.文件的基本操作"></a>1.文件的基本操作</h2><p>文件属于抽象数据类型。为了恰当地定义文件，就需要考虑有关文件的操作。操作系统提供系统调用，它对文件进行创建、写、读、定位和截断。<br><strong>①创建文件：</strong>创建文件有两个必要步骤，一是在文件系统中为文件找到空间；二是在目录中为新文件创建条目，该条目记录文件名称、在文件系统中的位置及其他可能信息。<br><strong>②写文件：</strong>为了写文件，执行一个系统调用，指明文件名称和要写入文件的内容。对于给定文件名称，系统搜索目录以查找文件位置。系统必须为该文件维护一个写位置的指针。每当发生写操作，便更新写指针。<br><strong>③读文件：</strong>为了读文件，执行一个系统调用，指明文件名称和要读入文件块的内存位置。同样，需要搜索目录以找到相关目录项，系统维护一个读位置的指针。每当发生读操作时，更新读指针。一个进程通常只对一个文件读或写，所以当前操作位置可作为每个进程当前文件位置指针。<br>由于读和写操作都使用同一指针，节省了空间也降低了系统复杂度。<br><strong>④文件重定位（文件寻址）：</strong>按某条件搜索目录，将当前文件位置设为给定值，并且不会读、写文件。<br><strong>⑤删除文件：</strong>先从目录中找到要删除文件的目录项，使之成为空项，然后回收该文件所占用的存储空间。<br><strong>⑥截断文件：</strong>允许文件所有属性不变，并删除文件内容，即将其长度设为0并释放其空间。<br>这6个基本操作可以组合执行其他文件操作。例如，一个文件的复制，可以创建新文件、 从旧文件读出并写入到新文件。</p><h2 id="2-磁盘调度算法"><a href="#2-磁盘调度算法" class="headerlink" title="2.磁盘调度算法"></a>2.磁盘调度算法</h2><ul><li><strong>1、先来先服务算法（FCFS）First Come First Service：</strong>这是一种比较简单的磁盘调度算法。它根据进程请求访问磁盘的先后次序进行调度。此算法的优点是公平、简单，且每个进程的请求都能依次得到处理，不会出现某一进程的请求长期得不到满足的情况。此算法由于未对寻道进行优化，在对磁盘的访问请求比较多的情况下，此算法将降低设备服务的吞吐量，致使平均寻道时间可能较长，但各进程得到服务的响应时间的变化幅度较小。</li><li><strong>2、最短寻道时间优先算法（SSTF） Shortest Seek Time First：</strong>该算法选择这样的进程，其要求访问的磁道与当前磁头所在的磁道距离最近，以使每次的寻道时间最短，该算法可以得到比较好的吞吐量，但却不能保证平均寻道时间最短。其缺点是对用户的服务请求的响应机会不是均等的，因而导致响应时间的变化幅度很大。在服务请求很多的情况下，对内外边缘磁道的请求将会无限期的被延迟，有些请求的响应时间将不可预期。</li><li><strong>3、扫描算法（SCAN）电梯调度：</strong>扫描算法不仅考虑到欲访问的磁道与当前磁道的距离，更优先考虑的是磁头的当前移动方向。例如，当磁头正在自里向外移动时，扫描算法所选择的下一个访问对象应是其欲访问的磁道既在当前磁道之外，又是距离最近的。这样自里向外地访问，直到再无更外的磁道需要访问才将磁臂换向，自外向里移动。这时，同样也是每次选择这样的进程来调度，即其要访问的磁道，在当前磁道之内，从而避免了饥饿现象的出现。由于这种算法中磁头移动的规律颇似电梯的运行，故又称为电梯调度算法。此算法基本上克服了最短寻道时间优先算法的服务集中于中间磁道和响应时间变化比较大的缺点，而具有最短寻道时间优先算法的优点即吞吐量较大，平均响应时间较小，但由于是摆动式的扫描方法，两侧磁道被访问的频率仍低于中间磁道。</li><li><strong>4、循环扫描算法（CSCAN）：</strong>循环扫描算法是对扫描算法的改进。如果对磁道的访问请求是均匀分布的，当磁头到达磁盘的一端，并反向运动时落在磁头之后的访问请求相对较少。这是由于这些磁道刚被处理，而磁盘另一端的请求密度相当高，且这些访问请求等待的时间较长，为了解决这种情况，循环扫描算法规定磁头单向移动。例如，只自里向外移动，当磁头移到最外的被访问磁道时，磁头立即返回到最里的欲访磁道，即将最小磁道号紧接着最大磁道号构成循环，进行扫描。</li></ul><h2 id="第五章、输入输出管理"><a href="#第五章、输入输出管理" class="headerlink" title="第五章、输入输出管理"></a>第五章、输入输出管理</h2><p><img src="https://img2020.cnblogs.com/blog/1358881/202102/1358881-20210216200842314-313480643.png" alt="img"></p><h2 id="1-I-x2F-O控制方式"><a href="#1-I-x2F-O控制方式" class="headerlink" title="1.I&#x2F;O控制方式"></a>1.I&#x2F;O控制方式</h2><p><strong>1.程序 I&#x2F;O 方式</strong><br>早期的计算机系统中， 没有中断系统，所以CPU和I&#x2F;O设备进行通信，传输数据时CPU速度远快于I&#x2F;O设备，于是CPU需要不断测试I&#x2F;O设备，看其是否完成了传输。</p><p><img src="https://img2020.cnblogs.com/blog/1358881/202102/1358881-20210216201310999-404151886.png" alt="img"><br><strong>2.中断驱动方式</strong><br>当某进程要启动某个 I&#x2F;O 设备工作时，便由 CPU 向相应的设备控制器发出一条 I&#x2F;O 命令，然后立即返回继续执行原来的任务。仅当输完一个数据时，才需 CPU 花费极短的时间去做些中断处理。</p><p>I&#x2F;O软件一般分为四个层次：用户层，与设备无关的软件层（系统调用的处理程序），设备驱动程序，以及中断处理程序。当用户使用设备时，首先在用户程序发起一次系统调用，操作系统的内核接到该调用请求后请求调用处理程序进行处理，再转到相应的设备驱动程序，当设备准备好或所需的数据到达后设备硬件发出中断，将数据按上述调用顺序逆向回传到用户程序中。</p><p>用户程序——系统调用处理程序——设备驱动程序——中断处理程序</p><p><img src="https://img2020.cnblogs.com/blog/1358881/202102/1358881-20210216201353793-845472878.png" alt="img"><br><strong>3.DMA方式（直接存储器访问）</strong><br>通过在I&#x2F;O设备和内存之间<strong>开启一个可以直接传输数据的通路</strong>，采用DMA控制器来控制一个数据块的传输，CPU只需在一个数据块传输开始阶段设置好传输所需的控制信息，并在传输结束阶段做进一步处理。</p><p><img src="https://img2020.cnblogs.com/blog/1358881/202102/1358881-20210216201414645-2101301826.png" alt="img"><br><strong>4.I&#x2F;O通道控制方式</strong><br>虽然DMA方式比起中断方式来已经显著地减少了CPU的干预，即已由以字（节）为单位的干预减少到以数据块为单位的干预。但CPU每发出一条I&#x2F;O指令，也只能去读&#x2F;写一个连续的数据块。而当我们需要一次去读多个数据块且将它们分别传送到不同的内存区域，或者相反时，则需由CPU分别发出多条I&#x2F;O指令及进行多次中断处理才能完成。</p><ul><li>通道控制方式与DMA控制方式类似，也是一种以内存为中心，实现设备与内存直接交换数据的控制方式。</li><li>与DMA控制方式相比，通道方式所需要的CPU干预更少，而且可以做到一个通道控制多台设 备，从而进一步减轻了CPU负担。</li><li>通道本质上是一个简单的处理器，专门负责输入、输出控制，具有执行I&#x2F;O指令的能力，并通过执行通道I&#x2F;O程序来控制I&#x2F;O操作。</li><li>通道的指令系统比较简单，一般只有数据传送指令、设备控制指令等。</li></ul><h3 id="5-Spooling技术"><a href="#5-Spooling技术" class="headerlink" title="5.Spooling技术"></a>5.Spooling技术</h3><p>虚拟性是OS的四大特性之一。如果说可以通过多道程序技术将一台物理CPU虚拟为多台逻辑CPU，从而允许多个用户共享一台主机，那么，<strong>通过SPOOling技术便可将一台物理I&#x2F;O设备虚拟为多台逻辑I&#x2F;O设备，同样允许多个用户共享一台物理I&#x2F;O设备。</strong><br>SPOOLing技术是对脱机输入、输出系统的模拟。相应地，SPOOLing系统必须建立在具有多道程序功能的操作系统上，而且还应有高速随机外存的支持，这通常是采用磁盘存储技术。<br>SPOOLing系统主要有以下三部分：</p><ul><li>输入井和输出井。这是在磁盘上开辟的两个大存储空间。输入井是模拟脱机输入时的磁盘设备，用于暂存I&#x2F;Q设备输入的数据；输出井是模拟脱机输出时的磁盘，用于暂存用户程序的输出数据。</li><li>输入缓冲区和输出缓冲区。为了缓和和CPU和磁盘之间速度不匹配的矛盾，在内存中要开辟两个缓冲区；输入缓冲区和输出缓冲区。输入缓冲区用于暂存由输入设备送来的数据，以后再传送到输入井。输出缓冲区用与暂存从输出井送来的数据，以后在传送给输出设备。</li><li>输入进程SPi 和输入进程SP0。这里利用两个进程来模拟脱机I&#x2F;O时的外围控制机。其中，进程SPi模拟脱机输入时的外围控制机，将用户要求的数据从输入机通过输入缓冲区再送到输入井，当CPU需要输入数据时，直接从输入井读入内存；进程SP0模拟脱机输出时的外围控制机，把用户要求输出的数据从先内存送到输出井，待输出设备空闲时，在将输出井中的数据经过输出缓冲区送到输出设备上。</li></ul><p>SPOOLing技术的特点：</p><ul><li>提高了I&#x2F;O速度。从对低速I&#x2F;O设备进行的I&#x2F;O操作变为对输入井或输出井的操作，如同脱机操作一样，提高了I&#x2F;O速度，缓和了CPU与低速I&#x2F;O设备速度不匹配的矛盾。</li><li>将独占设备改造为共享设备。因为在SPOOLing系统的系统中，实际上并没为任何进程分配设备，而知识在输入井或输出井中为进程分配一个存储区和建立一张I&#x2F;O请求表。这样，便把独占设备改造为共享设备。</li><li>实现了虚拟设备功能。多个进程同时使用一独享设备，而对每一进程而言，都认为自己独占这一设备，从而实现了设备的虚拟分配。不过，该设备是逻辑上的设备。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;整理自&lt;a href=&quot;https://www.cnblogs.com/wkfvawl/p/14407427.html%E4%BB%85%E7%A7%81%E7%94%A8&quot;&gt;https://www.cnblogs.com/wkfvawl/p/14407427.html仅私</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://xxsy613.github.io/2023/09/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://xxsy613.github.io/2023/09/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2023-09-23T01:03:52.932Z</published>
    <updated>2023-10-29T04:29:42.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-数据结构与算法基础"><a href="#一-数据结构与算法基础" class="headerlink" title="一 数据结构与算法基础"></a>一 数据结构与算法基础</h1><h2 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1 时间复杂度"></a>1 时间复杂度</h2><h1 id="二-线性表"><a href="#二-线性表" class="headerlink" title="二 线性表"></a>二 线性表</h1><h2 id="1-顺序存储-顺序表"><a href="#1-顺序存储-顺序表" class="headerlink" title="1 顺序存储 顺序表"></a>1 顺序存储 顺序表</h2><h2 id="2-链式存储"><a href="#2-链式存储" class="headerlink" title="2 链式存储"></a>2 链式存储</h2><h3 id="2-1-单链表"><a href="#2-1-单链表" class="headerlink" title="2.1 单链表"></a>2.1 单链表</h3><h3 id="2-2-双链表"><a href="#2-2-双链表" class="headerlink" title="2.2 双链表"></a>2.2 双链表</h3><h3 id="2-3-循环链表"><a href="#2-3-循环链表" class="headerlink" title="2.3 循环链表"></a>2.3 循环链表</h3><h3 id="2-4-静态链表"><a href="#2-4-静态链表" class="headerlink" title="2.4 静态链表"></a>2.4 静态链表</h3><h3 id="2-5-顺序表和链表的比较"><a href="#2-5-顺序表和链表的比较" class="headerlink" title="2.5 顺序表和链表的比较"></a>2.5 顺序表和链表的比较</h3><p>存取方式：顺序表可以顺序存取，也可以随机存取；链表只能从表头顺序存取元素<br>逻辑结构与物理结构：顺序表逻辑物理都相邻，链表只有逻辑相邻<br>查找，插入和删除操作：链表更适合插入与删除，顺序表适合访问元素</p><h1 id="三-栈、队列和数组"><a href="#三-栈、队列和数组" class="headerlink" title="三 栈、队列和数组"></a>三 栈、队列和数组</h1><h2 id="1-栈"><a href="#1-栈" class="headerlink" title="1 栈"></a>1 栈</h2><p><u>先进后出</u></p><h3 id="1-1-顺序栈"><a href="#1-1-顺序栈" class="headerlink" title="1.1 顺序栈"></a>1.1 顺序栈</h3><h3 id="1-2-链栈"><a href="#1-2-链栈" class="headerlink" title="1.2 链栈"></a>1.2 链栈</h3><h3 id="1-3-共享栈"><a href="#1-3-共享栈" class="headerlink" title="1.3 共享栈"></a>1.3 共享栈</h3><h2 id="2-队列"><a href="#2-队列" class="headerlink" title="2 队列"></a>2 队列</h2><p><u>先进先出</u></p><h3 id="2-1-循环队列"><a href="#2-1-循环队列" class="headerlink" title="2.1 循环队列"></a>2.1 循环队列</h3><p>队满条件：(Q.rear+1)%MaxSIze &#x3D;&#x3D; Q.front<br>队空条件：(Q.front) &#x3D; Q.rear<br>队列中元素的个数：(Q.rear-Q.front+MaxSize)%MaxSIze</p><p>入队操作：队尾指针加1取模<br>出队操作：队头指针加1取模</p><h3 id="2-2-链式队列"><a href="#2-2-链式队列" class="headerlink" title="2.2 链式队列"></a>2.2 链式队列</h3><h3 id="2-3-双端队列"><a href="#2-3-双端队列" class="headerlink" title="2.3 双端队列"></a>2.3 双端队列</h3><h2 id="3-数组"><a href="#3-数组" class="headerlink" title="3 数组"></a>3 数组</h2><h3 id="3-1-一维数组"><a href="#3-1-一维数组" class="headerlink" title="3.1 一维数组"></a>3.1 一维数组</h3><h3 id="3-2-多维数组"><a href="#3-2-多维数组" class="headerlink" title="3.2 多维数组"></a>3.2 多维数组</h3><h1 id="四-串"><a href="#四-串" class="headerlink" title="四 串"></a>四 串</h1><h2 id="1-存储结构"><a href="#1-存储结构" class="headerlink" title="1 存储结构"></a>1 存储结构</h2><h3 id="1-1-定长顺序存储"><a href="#1-1-定长顺序存储" class="headerlink" title="1.1 定长顺序存储"></a>1.1 定长顺序存储</h3><h3 id="1-2-堆分配存储"><a href="#1-2-堆分配存储" class="headerlink" title="1.2 堆分配存储"></a>1.2 堆分配存储</h3><h3 id="1-3-块链存储"><a href="#1-3-块链存储" class="headerlink" title="1.3 块链存储"></a>1.3 块链存储</h3><h2 id="2-模式匹配算法"><a href="#2-模式匹配算法" class="headerlink" title="2 模式匹配算法"></a>2 模式匹配算法</h2><h3 id="2-1-暴力匹配法"><a href="#2-1-暴力匹配法" class="headerlink" title="2.1 暴力匹配法"></a>2.1 暴力匹配法</h3><h3 id="2-2-KMP算法"><a href="#2-2-KMP算法" class="headerlink" title="2.2 KMP算法"></a>2.2 KMP算法</h3><p><em><strong>需要补充</strong></em></p><h3 id="2-3-KMP算法的进一步改进—nextval算法"><a href="#2-3-KMP算法的进一步改进—nextval算法" class="headerlink" title="2.3 KMP算法的进一步改进—nextval算法"></a>2.3 KMP算法的进一步改进—nextval算法</h3><h1 id="五-树与二叉树"><a href="#五-树与二叉树" class="headerlink" title="五 树与二叉树"></a>五 树与二叉树</h1><h2 id="1-二叉树"><a href="#1-二叉树" class="headerlink" title="1 二叉树"></a>1 二叉树</h2><h3 id="1-1-二叉树的主要特性"><a href="#1-1-二叉树的主要特性" class="headerlink" title="1.1 二叉树的主要特性"></a>1.1 二叉树的主要特性</h3><h3 id="1-2-二叉树的存储结构"><a href="#1-2-二叉树的存储结构" class="headerlink" title="1.2 二叉树的存储结构"></a>1.2 二叉树的存储结构</h3><h3 id="1-3-二叉树的遍历"><a href="#1-3-二叉树的遍历" class="headerlink" title="1.3 二叉树的遍历"></a>1.3 二叉树的遍历</h3><p>先序遍历，中序遍历，后序遍历，层次遍历</p><p>只有中序遍历+另外一种遍历方式可以唯一确定一个二叉树</p><h3 id="1-4-线索二叉树"><a href="#1-4-线索二叉树" class="headerlink" title="1.4 线索二叉树"></a>1.4 线索二叉树</h3><h2 id="2-树和森林"><a href="#2-树和森林" class="headerlink" title="2 树和森林"></a>2 树和森林</h2><h3 id="2-1-树的存储结构"><a href="#2-1-树的存储结构" class="headerlink" title="2.1 树的存储结构"></a>2.1 树的存储结构</h3><h3 id="2-2-树和森林的遍历"><a href="#2-2-树和森林的遍历" class="headerlink" title="2.2 树和森林的遍历"></a>2.2 树和森林的遍历</h3><h2 id="3-树与二叉树的应用"><a href="#3-树与二叉树的应用" class="headerlink" title="3 树与二叉树的应用"></a>3 树与二叉树的应用</h2><h3 id="3-1-哈夫曼树和哈夫曼编码"><a href="#3-1-哈夫曼树和哈夫曼编码" class="headerlink" title="3.1 哈夫曼树和哈夫曼编码"></a>3.1 哈夫曼树和哈夫曼编码</h3><h1 id="六-图"><a href="#六-图" class="headerlink" title="六 图"></a>六 图</h1><h2 id="1-图的定义"><a href="#1-图的定义" class="headerlink" title="1 图的定义"></a>1 图的定义</h2><h2 id="2-图结构的存储"><a href="#2-图结构的存储" class="headerlink" title="2 图结构的存储"></a>2 图结构的存储</h2><h3 id="2-1-邻接矩阵法、邻接表法"><a href="#2-1-邻接矩阵法、邻接表法" class="headerlink" title="2.1 邻接矩阵法、邻接表法"></a>2.1 邻接矩阵法、邻接表法</h3><h3 id="2-2-邻接多重表、十字链表"><a href="#2-2-邻接多重表、十字链表" class="headerlink" title="2.2 邻接多重表、十字链表"></a>2.2 邻接多重表、十字链表</h3><h2 id="3-图的遍历"><a href="#3-图的遍历" class="headerlink" title="3 图的遍历"></a>3 图的遍历</h2><h3 id="3-1-深度优先遍历"><a href="#3-1-深度优先遍历" class="headerlink" title="3.1 深度优先遍历"></a>3.1 深度优先遍历</h3><h3 id="3-2-广度优先遍历"><a href="#3-2-广度优先遍历" class="headerlink" title="3.2 广度优先遍历"></a>3.2 广度优先遍历</h3><h2 id="4-图的相关应用"><a href="#4-图的相关应用" class="headerlink" title="4 图的相关应用"></a>4 图的相关应用</h2><h3 id="4-1-最小生成树"><a href="#4-1-最小生成树" class="headerlink" title="4.1 最小生成树"></a>4.1 最小生成树</h3><h4 id="4-1-1-Prim算法"><a href="#4-1-1-Prim算法" class="headerlink" title="4.1.1 Prim算法"></a>4.1.1 Prim算法</h4><h4 id="4-1-2-Kruskal算法"><a href="#4-1-2-Kruskal算法" class="headerlink" title="4.1.2 Kruskal算法"></a>4.1.2 Kruskal算法</h4><h3 id="4-2-最短路径"><a href="#4-2-最短路径" class="headerlink" title="4.2 最短路径"></a>4.2 最短路径</h3><h4 id="4-2-1-Dijkstra算法"><a href="#4-2-1-Dijkstra算法" class="headerlink" title="4.2.1 Dijkstra算法"></a>4.2.1 Dijkstra算法</h4><p>求单源最短路径，用于带权图和无权图，在权值出现负值时可能会失效，时间复杂度为$O(n^2)$</p><h4 id="4-2-2-Floyd算法"><a href="#4-2-2-Floyd算法" class="headerlink" title="4.2.2. Floyd算法"></a>4.2.2. Floyd算法</h4><p>求各顶点间的最短路径，适用于带权图和无权图，时间复杂度为$O(n^3)$</p><h3 id="4-3-拓扑排序"><a href="#4-3-拓扑排序" class="headerlink" title="4.3 拓扑排序"></a>4.3 拓扑排序</h3><h4 id="4-3-1-AOV网"><a href="#4-3-1-AOV网" class="headerlink" title="4.3.1 AOV网"></a>4.3.1 AOV网</h4><h3 id="4-4-关键路径"><a href="#4-4-关键路径" class="headerlink" title="4.4 关键路径"></a>4.4 关键路径</h3><h4 id="4-4-1-AOE网"><a href="#4-4-1-AOE网" class="headerlink" title="4.4.1 AOE网"></a>4.4.1 AOE网</h4><h1 id="八-排序"><a href="#八-排序" class="headerlink" title="八 排序"></a>八 排序</h1><table><thead><tr><th></th><th>稳定性</th><th>时间复杂度</th></tr></thead><tbody><tr><td>直接插入排序</td><td>√</td><td>O(n^2)</td></tr><tr><td>折半插入排序</td><td>√</td><td>O(n^2)</td></tr><tr><td>希尔排序</td><td>×</td><td>O(nlogn) 1.3</td></tr><tr><td>冒泡排序</td><td>√</td><td>O(n^2)</td></tr><tr><td>快速排序</td><td>×</td><td>O(nlogn)</td></tr><tr><td>简单选择排序</td><td>×</td><td>O(n^2)</td></tr><tr><td>堆排序</td><td>×</td><td>O(nlogn)</td></tr><tr><td>归并排序</td><td>√</td><td>O(nlogn)</td></tr><tr><td>基数排序</td><td>√</td><td>O(d(n+rd))</td></tr></tbody></table><h2 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1 插入排序"></a>1 插入排序</h2><h3 id="1-1-直接插入排序"><a href="#1-1-直接插入排序" class="headerlink" title="1.1 直接插入排序"></a>1.1 直接插入排序</h3><h3 id="1-2-折半插入排序"><a href="#1-2-折半插入排序" class="headerlink" title="1.2 折半插入排序"></a>1.2 折半插入排序</h3><h3 id="1-3-希尔排序"><a href="#1-3-希尔排序" class="headerlink" title="1.3 希尔排序"></a>1.3 希尔排序</h3><h2 id="2-交换排序"><a href="#2-交换排序" class="headerlink" title="2 交换排序"></a>2 交换排序</h2><h3 id="2-1-冒泡排序"><a href="#2-1-冒泡排序" class="headerlink" title="2.1 冒泡排序"></a>2.1 冒泡排序</h3><h3 id="2-2-快速排序"><a href="#2-2-快速排序" class="headerlink" title="2.2 快速排序"></a>2.2 快速排序</h3><h2 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3 选择排序"></a>3 选择排序</h2><h3 id="3-1-简单选择排序"><a href="#3-1-简单选择排序" class="headerlink" title="3.1 简单选择排序"></a>3.1 简单选择排序</h3><h3 id="3-2-堆排序"><a href="#3-2-堆排序" class="headerlink" title="3.2 堆排序"></a>3.2 堆排序</h3><h2 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4 归并排序"></a>4 归并排序</h2><h2 id="5-基数排序"><a href="#5-基数排序" class="headerlink" title="5 基数排序"></a>5 基数排序</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-数据结构与算法基础&quot;&gt;&lt;a href=&quot;#一-数据结构与算法基础&quot; class=&quot;headerlink&quot; title=&quot;一 数据结构与算法基础&quot;&gt;&lt;/a&gt;一 数据结构与算法基础&lt;/h1&gt;&lt;h2 id=&quot;1-时间复杂度&quot;&gt;&lt;a href=&quot;#1-时间复杂度&quot; c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://xxsy613.github.io/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <id>http://xxsy613.github.io/2023/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</id>
    <published>2023-09-05T07:54:17.176Z</published>
    <updated>2023-10-28T14:39:09.827Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-数据的表示和运算"><a href="#第二章-数据的表示和运算" class="headerlink" title="第二章 数据的表示和运算"></a>第二章 数据的表示和运算</h1><h2 id="2-2-运算方法和运算电路"><a href="#2-2-运算方法和运算电路" class="headerlink" title="2.2 运算方法和运算电路"></a>2.2 运算方法和运算电路</h2><h3 id="2-2-3-定点数的加减运算"><a href="#2-2-3-定点数的加减运算" class="headerlink" title="2.2.3 定点数的加减运算"></a>2.2.3 定点数的加减运算</h3><p>补码加减法运算电路中用控制端Sub来控制选择加法还是减法运算，值为1做减法，值为0做加法，<strong>控制端Sub又叫低位进位输入位</strong></p><ul><li>低位进位 来自低一位的进位信息</li><li>高位进位 当前位的两个输入值和低位进位值相加产生的结果，三个数相加产生的进位</li></ul><h3 id="2-2-4-定点数的乘法运算"><a href="#2-2-4-定点数的乘法运算" class="headerlink" title="2.2.4 定点数的乘法运算"></a>2.2.4 定点数的乘法运算</h3><ul><li><p><strong>原码一位乘法</strong></p><p>乘数，被乘数的符号位和数值位分开计算，符号位采用异或</p><p>每次判断乘数最后一位的数值，若为1，则部分积加上x，乘数与被乘数同时右移；若为0，则部分积加上0，乘数与被乘数同时右移，重复n次</p><p>右移为逻辑右移</p><p>循环执行n次</p></li><li><p><strong>补码一位乘法（Booth算法）</strong></p><p>乘数，被乘数的符号位和数值位一起计算</p><p>被乘数和部分积取双符号位参与运算，乘数位末加上y n+1辅助位，初值为0</p><p>每次判断y n+1 - y n的值，若为0，则部分积右移一位；若为1，则部分积加上x，右移一位；若为-1，则部分积加上-x，右移一位</p><p>右移为算术右移</p><p>共进行n+1次累加和n次右移操作</p></li><li><p><strong>原码除法运算（不恢复余数法）</strong></p><p>除数，被除数，余数，商，商的符号位和数值位分开计算</p><p>用被除数减去除数，够减，上商，左移，减y；不够减，商上0，左移一位，加y（够减&#x3D;余数为正）</p><p>如果第n+1步余数符号与被除数不同，则加上除数y，得到正确的余数（即恢复余数）</p></li><li><p><strong>补码除法运算（加减交替法）</strong></p><p>符号位参与运算</p><p>第一步根据除数和被除数的符号，如果异号则加上y，如果同号则减去y</p><p>然后根据余数和除数的符号，够减，上商，左移，减y；不够减，商上0，左移，加y（够减&#x3D;余数与除数同号）</p><p>商的末位恒置1</p></li></ul><p>规律：</p><table><thead><tr><th></th><th>初始状态</th><th>符号位规则</th><th>累加规则</th><th>移位规则</th><th>特殊规则</th></tr></thead><tbody><tr><td>原码乘法</td><td>乘数末尾1加x 0加0</td><td>双符号 不参与运算</td><td>乘数末位1加x 0加0</td><td>逻辑右移</td><td>无</td></tr><tr><td>补码乘法</td><td>乘数辅助位末位增加0</td><td>双符号 参与运算</td><td>乘数辅助位-末位1加x -1减x 0加0</td><td>算术右移</td><td>n+1次累加n次右移</td></tr><tr><td>原码除法</td><td>被除数减除数</td><td>单符号 不参与运算</td><td>够减 商1减y 不够减 商0加y</td><td>逻辑左移</td><td>n+1步符号异则加y</td></tr><tr><td>补码除法</td><td>除数被除数同号减异号加</td><td>双符号 参与运算</td><td>余数除数 同号商1减y 异号商0加y</td><td>算术左移</td><td>商末位恒置1</td></tr></tbody></table><h3 id="2-2-5-C语言中的整数类型及类型转换"><a href="#2-2-5-C语言中的整数类型及类型转换" class="headerlink" title="2.2.5 C语言中的整数类型及类型转换"></a>2.2.5 C语言中的整数类型及类型转换</h3><p>注意无符号数没有原码反码补码之分，就是二进制真值，而在c语言中的其他数据皆以补码表示</p><ul><li><p>无符号数转为有符号数</p><p>机器数相同，解释位：最高位视作符号位，然后将数值位从原码转换为补码</p></li><li><p>有符号数转为无符号数</p><p>符号位视作数值位最高位，其他照常</p></li></ul><h2 id="2-3-浮点数的表示与运算"><a href="#2-3-浮点数的表示与运算" class="headerlink" title="2.3 浮点数的表示与运算"></a>2.3 浮点数的表示与运算</h2><h3 id="2-3-1-浮点数的表示"><a href="#2-3-1-浮点数的表示" class="headerlink" title="2.3.1 浮点数的表示"></a>2.3.1 浮点数的表示</h3><p><em><strong>规格化</strong></em></p><ul><li><p>用原码表示的尾数进行规格化<br>$$<br>正数:0.1xxxxx\范围:\frac{1}{2}≦M≦(1-2^{-n})\<br>负数:1.1xxxxx\范围:-(1-2^{-n})≦M≦-\frac{1}{2}<br>$$</p></li><li><p>用补码表示的尾数进行规格化</p><p><strong>规定：保证符号位和数值位最高位异号</strong><br>$$<br>正数:0.1xxxxx\范围:\frac{1}{2}≦M≦(1-2^{-n})\<br>负数:1.0xxxxx\范围:-1≦M≦-(\frac{1}{2}+2^{-n})<br>$$</p></li></ul><p>当基数为4时，原码规格化的尾数最高两位不全为0</p><p><em><strong>IEEE754标准</strong></em></p><p>移码&#x3D;真值+偏置值，一般取偏置值为2^n-1 -1，此偏置值下的8位移码范围为-128<del>127，其中-128为全1，-127为全0，因为其特殊性被用作其他用途，所以**移码范围为-126</del>127**</p><ul><li>当阶码为全0，尾数不全为0时，阶码的真值为-126，此时的尾数的隐藏位（即整数位）为0，表示的为非规格化小数</li><li>当阶码为全0，尾数为全0时，表示的真值为+&#x2F;-0</li><li>当阶码为全1，尾数不全为0时，表示非数值NaN （Not A Number）</li><li>当阶码为全1，尾数为全0时，表示无穷大+&#x2F;- ∞</li></ul><p><em><strong>浮点数对应范围</strong></em><br>$$<br>若尾数占n位（含符号位），阶码占m位（含符号位），均采用补码表示\<br>尾数的范围:[-1,1-2^{-(n-1)}]\<br>阶码的范围:[-2^{n-1},2^{n-1}-1]\<br>$$<br><em><strong>浮点数和定点数的辨析</strong></em></p><table><thead><tr><th><u><em>在字长相同的情况下</em></u></th><th>关系</th><th>原因</th></tr></thead><tbody><tr><td>表示范围</td><td>浮点数&gt;定点数</td><td>阶码的存在</td></tr><tr><td>精度</td><td>浮点数&lt;定点数</td><td>尾数部分有效位数较少</td></tr><tr><td>可表示的数的个数</td><td>浮点数&#x3D;定点数</td><td>n位编码只能表示2^n个数</td></tr></tbody></table><h1 id="第三章-存储系统"><a href="#第三章-存储系统" class="headerlink" title="第三章 存储系统"></a>第三章 存储系统</h1><p><strong>多模块存储器与字位扩展的异同</strong></p><p>字扩展就是单纯的存储地址不够，需要多个存储器串联，而多体并行存储器是为了加大吞吐量，增加一次读取的数据量。<br>两者都可以导致存储空间的变大，但多体并行存储器的存储空间变大是附带的。<br>且两者的作用范围也不同。下图是两技术的应用范围和存储器件之间的关系。</p><img src="https://img-blog.csdnimg.cn/e7699fe121a8473c9438994bfefda551.jpeg#pic_center" alt="在这里插入图片描述" style="zoom:50%;"><p><strong>高速缓存计算Cache行的位数</strong></p><p>计算位数:有效位（1位） +  标记位 + n位LRU(若用LRU算法，2^n路组相联映射) + 脏位(写回法时) + 块内数据位</p><h1 id="第五章-中央处理器"><a href="#第五章-中央处理器" class="headerlink" title="第五章 中央处理器"></a>第五章 中央处理器</h1><p><strong>指令周期：</strong></p><p>FE（Fetch）：取指令周期；IND（In DIrect）间址周期；EX（Executive）执行周期；INT（Interrupt）中断周期</p><p><strong>机器字长，存储字长，指令字长的辨析：</strong></p><ul><li>机器字长：计算机能直接处理的二进制数据的<strong>位数</strong>，机器字长一般等于内部寄存器的大小，它决定了计算机的运算精度。</li><li>指令字长：一个指令字中包含的二进制代码的<strong>位数</strong>。</li><li>存储字长：一个存储单元存储的二进制代码的<strong>长度</strong>。</li></ul><p>它们都必须是字节的整数倍。</p><p>指令字长一般取存储字长的整数倍，若指令字长等于存储字长的2倍，则需要2次访存来取出一条指令，因此取指周期为机器周期的2倍；若指令字长等于存储字长，则取指周期等于机器周期。</p><p>早期的计算机存储字长一般和机器的指令字长与数据字长相等，因此访问一次主存便可取出一条指令或一个数据。随着计算机的发展，指令字长可变，数据字长也可变，但它们必须都是字节的整数倍。</p><p>请注意64位操作系统是指特别为64位架构的计算机而设计的操作系统，它能够利用64位处理器的优势。但64位机器既可以使用64位操作系统，又可以使用32位操作系统。而32位处理器是无法使用64位操作系统的。</p><p><strong>CU（控制单元）</strong>：指令寄存器IR和标志寄存器FR，PSW，ACC，I&#x2F;O设备，主存的输出信号会连接到控制单元CU的输入端，发出命令到总线</p><p><strong>汇编程序员可见的寄存器：</strong>基址寄存器，状态&#x2F;标志寄存器，程序计数器PC，通用寄存器</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第二章-数据的表示和运算&quot;&gt;&lt;a href=&quot;#第二章-数据的表示和运算&quot; class=&quot;headerlink&quot; title=&quot;第二章 数据的表示和运算&quot;&gt;&lt;/a&gt;第二章 数据的表示和运算&lt;/h1&gt;&lt;h2 id=&quot;2-2-运算方法和运算电路&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://xxsy613.github.io/2023/08/21/%E9%AB%98%E6%95%B0%E5%A4%A7%E7%BA%B2/"/>
    <id>http://xxsy613.github.io/2023/08/21/%E9%AB%98%E6%95%B0%E5%A4%A7%E7%BA%B2/</id>
    <published>2023-08-21T08:11:19.905Z</published>
    <updated>2023-10-30T07:50:07.791Z</updated>
    
    <content type="html"><![CDATA[<p><u>整理自武忠祥强化课内容</u></p><h1 id="第一章-函数，极限，连续"><a href="#第一章-函数，极限，连续" class="headerlink" title="第一章 函数，极限，连续"></a>第一章 函数，极限，连续</h1><h2 id="1-函数"><a href="#1-函数" class="headerlink" title="1 函数"></a>1 函数</h2><h3 id="1-1-函数概念与表示法"><a href="#1-1-函数概念与表示法" class="headerlink" title="1.1 函数概念与表示法"></a>1.1 函数概念与表示法</h3><h3 id="1-2-复合函数"><a href="#1-2-复合函数" class="headerlink" title="1.2 复合函数"></a>1.2 复合函数</h3><h3 id="1-3-分段函数"><a href="#1-3-分段函数" class="headerlink" title="1.3 分段函数"></a>1.3 分段函数</h3><p>需要分段的函数：</p><ul><li><p>含有绝对值的函数</p></li><li><p>含有最大值最小值的函数</p></li><li><p>$$<br>含有x→∞，对于e^x和x^a在不同极限得出的值不同<br>$$</p></li></ul><h3 id="1-4-初等函数性质"><a href="#1-4-初等函数性质" class="headerlink" title="1.4 初等函数性质"></a>1.4 初等函数性质</h3><h4 id="1-4-1-奇函数-偶函数-周期函数"><a href="#1-4-1-奇函数-偶函数-周期函数" class="headerlink" title="1.4.1 奇函数 偶函数 周期函数"></a>1.4.1 奇函数 偶函数 周期函数</h4><p>偶函数：奇函数的导数 奇函数的不定积分 偶函数符合奇偶函数 奇函数×奇函数 偶函数×偶函数</p><p>奇函数：偶函数的导数 过原点的偶函数的不定积分 偶函数的导数 奇函数×偶函数 奇函数符合奇函数</p><h3 id="1-4-2-函数的有界性"><a href="#1-4-2-函数的有界性" class="headerlink" title="1.4.2 函数的有界性"></a>1.4.2 函数的有界性</h3><p>有界的证明方法：</p><ul><li>f(x)在[a,b]上连续，则有界</li><li>f(x)在(a,b)上连续，且f(a+)，f(b-)存在，则有界</li><li>f(x)的导数在有限区间I上有界，则有界</li></ul><p>无界函数×有界函数&#x3D;无界函数</p><h4 id="1-4-2-初等函数图形"><a href="#1-4-2-初等函数图形" class="headerlink" title="1.4.2 初等函数图形"></a>1.4.2 初等函数图形</h4><p>需要记忆：arcsinx arccosx arctanx arccotx</p><h4 id="1-5-参数方程表示的函数"><a href="#1-5-参数方程表示的函数" class="headerlink" title="1.5 参数方程表示的函数"></a>1.5 参数方程表示的函数</h4><p>$$<br>双纽线：(x^2+y^2)^2&#x3D;2a^2(x^2-y^2)<br>$$</p><p>$$<br>笛卡尔叶形： x^3+y^3-3axy&#x3D;0(a&gt;0)<br>$$</p><p>曲线关于x对称<br>曲线有渐近线x+y+a&#x3D;0<br>$$<br>心形线：r&#x3D;a（1+cosθ)<br>$$</p><h2 id="2-极限"><a href="#2-极限" class="headerlink" title="2 极限"></a>2 极限</h2><h3 id="2-1-极限，左右极限，存在性"><a href="#2-1-极限，左右极限，存在性" class="headerlink" title="2.1 极限，左右极限，存在性"></a>2.1 极限，左右极限，存在性</h3><p>左右极限存在且相等证明<strong>极限存在</strong></p><h3 id="2-2-极限性质与运算法则"><a href="#2-2-极限性质与运算法则" class="headerlink" title="2.2 极限性质与运算法则"></a>2.2 极限性质与运算法则</h3><ul><li>局部有界限：极限存在可推局部有界，局部无界可推<strong>极限不存在</strong></li><li>局部保号性：极限存在可推保号性</li></ul><h3 id="2-3-极限存在的两个准则"><a href="#2-3-极限存在的两个准则" class="headerlink" title="2.3 极限存在的两个准则"></a>2.3 极限存在的两个准则</h3><ul><li>夹逼定理</li><li>单调有界准则</li></ul><p>用于求解数列、函数极限存在和极限值为多少的问题</p><p>若能判断出数列函数为单调或者有界，则考虑采用单调有界方法做，若无法按单调有界或常规做法来做，用夹逼求极限</p><h3 id="2-4-数列收敛与求数列的极限"><a href="#2-4-数列收敛与求数列的极限" class="headerlink" title="2.4 数列收敛与求数列的极限"></a>2.4 数列收敛与求数列的极限</h3><ul><li><p>a_n &#x3D; f(n)型【f(n)项数固定】</p><p>只需求lim n-&gt;∞ f(n)，若其存在，则{xn}收敛，且其极限值为数列极限</p><p>方法a：可以令n&#x3D;x或n&#x3D;1&#x2F;x，转化为函数极限</p><p>方法b：直接利用极限知识求解</p></li><li><p>a_n&#x3D;f(n)【f(n)项数不固定】</p><p>方法a：夹逼定理</p><p>技巧：看见lim n-&gt;∞ 分母最大&#x2F;分母最小 &#x3D; 1 想到放缩每项分母为最大和最小</p><p>方法b：定积分定义，利用<br>$$<br>\lim_{x\rightarrow+\infty}\frac{1}{n}\sum_{i&#x3D;1}^{n}{f(\frac{1}{n})}&#x3D;\int_{0}^{1}f(x)dx<br>$$</p></li><li><p>有递推式 a_n &#x3D; f(a_n-1)</p><p>此时y &#x3D; a_n ，x&#x3D;a_n-1，构成函数</p><p>方法a：当y&#x3D;f(x)单调递增时，采用单调有界</p><p>方法b：当y&#x3D;f(x)单调递减时，采用<strong>压缩映射</strong> </p><p>思路：<br>$$<br>\lim_{n\rightarrow∞}x_n &#x3D; A<br>$$</p><p>$$<br>|x_{n+1}-A|&lt;|f(x_n)-A|<br>&lt;B|Xn-A|&lt;B^n|X_1-A|\<br>其中 0&lt;&#x3D;B&lt;1<br>$$</p><p>$$<br>|x_{n+1} -A|&lt;B^n|x_1-A| 所以 n\rightarrow∞,|x_{n+1}-A|\rightarrow0\<br>\lim_{n\rightarrow}x_n &#x3D; A\<br>简述：由x_{n+1}-A变为x_n-A，找到一个在0和1之中的一个B，然后用夹逼定理即可证明<br>$$</p></li></ul><h3 id="2-5-两个重要极限"><a href="#2-5-两个重要极限" class="headerlink" title="2.5 两个重要极限"></a>2.5 两个重要极限</h3><p>$$<br>\lim_{x\rightarrow0}\frac{sinx}{x}&#x3D;1<br>$$</p><p>$$<br>\lim_{x\rightarrow∞}(1+\frac{n}{x})^x&#x3D;e^n\<br>\lim_{x\to0}x^x&#x3D;1<br>$$</p><h3 id="2-6-无穷小"><a href="#2-6-无穷小" class="headerlink" title="2.6 无穷小"></a>2.6 无穷小</h3><ol><li>无穷大的倒数是无穷小，但无穷小的倒数不一定是无穷大</li><li>无界变量不一定是无穷大</li><li>0也是x-&gt;x0时的无穷小</li></ol><h3 id="2-7-无穷小比阶"><a href="#2-7-无穷小比阶" class="headerlink" title="2.7 无穷小比阶"></a>2.7 无穷小比阶</h3><p>技巧总结</p><ol><li><p>等价无穷小<br>$$<br>冷门等价无穷小公式\<br>ln(x+\sqrt{1+x^2})—x\<br>(1+x)^n-1—nx<br>$$</p></li><li><p>拉格朗日中值法 适用于复杂的函数情况</p></li><li><p>求导法（洛必达法），适用于原式复杂，但求导后式子简单的情况</p></li><li><p>多种方法复合法<br>情况一：在对β合α比阶时，上下式分别用等价无穷小和拉格朗日中值定理处理，此为简单复合</p><p>情况二：β和α比阶时，出现变上限积分的被积函数为复合函数则要用变量代换将复合函数化为简单函数，再求导</p></li></ol><p>易错点</p><ol><li><strong>轻信等价无穷小，忽视了泰勒展开精度，如遇此类大题，着重注意泰勒精度</strong>，如嫌泰勒麻烦，恰好可用拉格朗日中值，则优先此</li><li>在非比阶式下，直接使用等价无穷小，结果未加1，求导后要加上因求导而下降的阶数</li></ol><h3 id="2-8-求极限常用方法"><a href="#2-8-求极限常用方法" class="headerlink" title="2.8 求极限常用方法"></a>2.8 求极限常用方法</h3><ol><li><p>利用有理运算法则求极限</p><p>拆分函数，极限非零的因子可先求出来</p></li><li><p>利用基本极限求极限</p></li><li><p>利用等价无穷小求极限<br>注意可以用等价无穷小的原则</p><p>乘除可以换，加减需要满足加数和被加数，减数和被减数之间，求分数极限不等于1</p><p>比如tanx-sinx因为lim tanx&#x2F;sinx等于1，所以不能应用等价无穷小</p></li><li><p>利用洛必达法则求极限</p></li><li><p><strong>利用泰勒公式求极限</strong></p><p>泰勒公式展开时如果出现比目标次幂高阶的情况，可以省略掉高阶项，低阶吸高阶</p></li><li><p><strong>利用夹逼准则求极限</strong></p><p>夹逼准则使用时的常见不等式积累：<br>$$<br>\sin x&lt;x&lt;\tan x\<br>\arctan x&lt;x&lt;\arcsin x\<br>e^x &gt;x+1\<br>\ln x &lt;x-1\<br>\frac{x}{1+x}&lt;\ln (1+x)&lt;x\<br>\sqrt{xy}&lt;\frac{x+y}{2}&lt;\sqrt\frac{x^2+y^2}{2}<br>$$</p></li><li><p>利用定积分定义求极限</p><p>时机如上</p></li><li><p>利用单调有界准则求极限</p></li></ol><h3 id="2-9-求极限常见题型"><a href="#2-9-求极限常见题型" class="headerlink" title="2.9 求极限常见题型"></a>2.9 求极限常见题型</h3><ul><li><p>0&#x2F;0</p><p>洛必达法则，等价无穷小，泰勒公式，拉格朗日中值</p></li><li><p>∞&#x2F;∞</p><p>洛必达法则，分子分母同除以分子和分母各项中最高阶的无穷大</p></li><li><p>∞-∞</p><p>通分化为0&#x2F;0（适用于分式差）</p><p>根式有理化（适用于根式差）</p><p>提无穷因子，然后等价替换或变量代换，泰勒公式</p></li><li><p>0×∞</p><p>化为0&#x2F;0或∞&#x2F;∞</p></li><li><p>1^∞</p><p><strong>利用结论</strong></p><p>第一步：写标准型<br>$$<br>原式&#x3D;\lim(1+\alpha)^\beta<br>$$<br>第二步：求极限<br>$$<br>lim\alpha\beta &#x3D; A<br>$$<br>第三部：写结果<br>$$<br>原式&#x3D;e^A<br>$$<br><u>使用结论时必须是式子作为整体的时候才能用，若拆开有两个条件，一个是可拆，二是拆分后各部分的极限存在</u></p><p>若不满足则立即换用通常方法，构造e^ln(……)</p></li><li><p>∞^0  0^0（x^x）</p><p>将其改写成指数函数形式<br>$$<br>lim[f(x)]^{g(x)} &#x3D; lime^{g(x)lnf(x)}<br>$$<br>然后构造e^x-1~x的等价无穷小化繁为简</p></li></ul><h2 id="3-连续"><a href="#3-连续" class="headerlink" title="3 连续"></a>3 连续</h2><h3 id="3-1-函数的连续与左右连续"><a href="#3-1-函数的连续与左右连续" class="headerlink" title="3.1 函数的连续与左右连续"></a>3.1 函数的连续与左右连续</h3><p>复合函数连续性的判断：内函数的值域不含外函数的间断点时连续，是否连续取决于外函数</p><h3 id="3-2-闭区间连续函数性质"><a href="#3-2-闭区间连续函数性质" class="headerlink" title="3.2 闭区间连续函数性质"></a>3.2 闭区间连续函数性质</h3><h3 id="3-3-间断点"><a href="#3-3-间断点" class="headerlink" title="3.3 间断点"></a>3.3 间断点</h3><ul><li>第一类间断点 该点左右极限都存在<ul><li>可去间断点 左右极限相等但不等于该点值</li><li>跳跃间断点 左右极限不相等</li></ul></li><li>第二类间断点 该点左右极限至少有一个不存在<ul><li>无穷间断点 左右极限至少有一个是无穷大</li><li>振荡间断点 来回振荡，极限不存在</li></ul></li></ul><h1 id="第二章-一元函数微分学"><a href="#第二章-一元函数微分学" class="headerlink" title="第二章 一元函数微分学"></a>第二章 一元函数微分学</h1><h2 id="1-导数"><a href="#1-导数" class="headerlink" title="1 导数"></a>1 导数</h2><h3 id="1-1-导数与微分的概念"><a href="#1-1-导数与微分的概念" class="headerlink" title="1.1 导数与微分的概念"></a>1.1 导数与微分的概念</h3><p>导数的定义<br>$$<br>\lim_{x_0\rightarrow0}\frac{y_0-y}{x_0-x}&#x3D;\lim_{x_0\rightarrow0}\frac{f(x+x_0)-f(x)}{x_0}<br>$$</p><h3 id="1-2-可导，可微，连续的关系"><a href="#1-2-可导，可微，连续的关系" class="headerlink" title="1.2 可导，可微，连续的关系"></a>1.2 可导，可微，连续的关系</h3><p>可导，可微 可互推，只能由可导可微推连续，连续不一定可导可微</p><p>可导的条件：求函数在该点的左右导数，如果存在且相等，则函数在该点可导且连续</p><p>连续的条件：求函数在该点的极限，如果存在且等于该点的值，则函数在该点连续</p><h3 id="1-3-极值点，驻点，拐点"><a href="#1-3-极值点，驻点，拐点" class="headerlink" title="1.3 极值点，驻点，拐点"></a>1.3 极值点，驻点，拐点</h3><p>极值点是单调性发生变化的点，是函数的局部最大值或最小值</p><p>驻点是一阶导数为零的点</p><p>拐点是凹凸性变化的点，是二阶导数为零，三阶导数不为零的点，<strong>包含横坐标和纵坐标</strong></p><p><strong>辨析：</strong></p><p>驻点不一定是极值点，极值点不一定是驻点，可导函数（不管是一阶导还是二阶导）的极值点必定是他的驻点</p><p>拐点的横坐标就是极值点</p><p>可导情况下，如果驻点是拐点，则一定不是极值点，不可导情况下则有可能同时为拐点和极值点</p><p><strong>极值点的判断方法：</strong></p><ol><li><p>求驻点，然后根据去心邻域内一阶导的正负性判断极值</p></li><li><p>判断驻点是否为极值点，求二阶导在该驻点的值，如果大于0为极小值，如果小于0为极大值，等于0则不是极值</p></li><li><p>$$<br>若f^{(1)}(x)&#x3D;f^{(2)}(x)&#x3D;….&#x3D;f^{(n-1)}(x)&#x3D;0\<br>且f^{(n)}(x)≠0<br>$$</p><p>当n为偶数时，f(x)在x处有极值，大于零极小，小于零极大；当n为奇数时，f(x)在x处没有极值</p></li></ol><p><strong>拐点的判断方法：</strong></p><p>大体上与极值点的判断方法相同，只是高一阶</p><h3 id="1-4-导数四则运算与复合函数求导"><a href="#1-4-导数四则运算与复合函数求导" class="headerlink" title="1.4 导数四则运算与复合函数求导"></a>1.4 导数四则运算与复合函数求导</h3><h3 id="1-5-函数的渐近线求法"><a href="#1-5-函数的渐近线求法" class="headerlink" title="1.5 函数的渐近线求法"></a>1.5 函数的渐近线求法</h3><p>函数的渐进线类型：垂直渐进线，水平渐进线，斜渐近线</p><p>寻找路线：</p><ol><li>首先找不连续的点，如果此点的左右极限有一个趋于无穷，则为垂直渐近线</li><li>再分别令x趋于正无穷，负无穷，如果极限存在，则有水平渐近线</li><li>最后找斜渐进线，先求lim x-&gt;∞ f(x)&#x2F;x如果极限存在，则渐进线存在，斜率为a，再求lim x-&gt;∞ f(x)-ax，若极限存在且为b，则渐近线斜率为y&#x3D;ax+b</li></ol><h3 id="1-6-初等函数导数公式"><a href="#1-6-初等函数导数公式" class="headerlink" title="1.6 初等函数导数公式"></a>1.6 初等函数导数公式</h3><p>$$<br>(x^x) &#x3D; x^x(lnx+1)<br>$$</p><p>$$<br>微分方程常用 (xe^x)^{(n)} &#x3D; e^x(x+n)<br>$$</p><p>$$<br>分部积分常用 [ln(x+\sqrt{x^2+a})]^{(1)}&#x3D;\frac{1}{\sqrt{x^2+a}}<br>$$</p><h3 id="1-7-求导法及题型"><a href="#1-7-求导法及题型" class="headerlink" title="1.7 求导法及题型"></a>1.7 求导法及题型</h3><p><em><strong>隐函数求导法</strong></em></p><p>等式两边同时对x求导，注意y对x求导时除了按求导法则求导外还要再乘以一个y的导数</p><p><em><strong>参数方程求导法</strong></em><br>$$<br>一阶导数：\frac{dy}{dx}&#x3D;\frac{\dot {y(t)}}{\dot {x(t)}}\<br>二阶导数：\frac{d^2y}{dx^2}&#x3D;\frac{d}{dt}\frac{\dot {y(t)}}{\dot {x(t)}}\frac{1}{\dot {x(t)}}分子分母同除dt<br>$$<br><em><strong>反函数求导法</strong></em><br>$$<br>反函数的一阶导数为：\frac{dx}{dy}&#x3D;\frac{1}{\dot y}\<br>反函数的二阶导数为：\frac{d^2x}{dy^2}&#x3D;\frac{d}{dx}(\frac{1}{\dot y})\frac{dx}{dy}分子分母同除dx<br>$$<br><em><strong>对数求导法</strong></em></p><p>对于幂指函数，连乘，连除，开方，乘方等形式的函数一遍采用对数求导法，即<strong>两边取对数</strong></p><p><em><strong>高阶导数</strong></em></p><ol><li>代公式</li><li>求一阶导数，二阶导数，进而归纳n阶导数</li><li>泰勒公式</li></ol><p><em><strong>包含定积分的复合函数求导及连续性判断</strong></em></p><ol><li>对于定积分内是(x,t)的函数，用换元法求导</li><li>注意判断f(0)&#x3D;0的情况，分类讨论</li><li>证明连续性，对导数取趋近于0的极限，如果与导数等于0时的值相等，即连续</li></ol><h2 id="2-导数应用"><a href="#2-导数应用" class="headerlink" title="2 导数应用"></a>2 导数应用</h2><h3 id="2-1-罗尔定理"><a href="#2-1-罗尔定理" class="headerlink" title="2.1 罗尔定理"></a>2.1 罗尔定理</h3><p>$$<br>连续,可导,f(a)&#x3D;f(b)\rightarrow∃x_0∈(a,b),f^1(x0)&#x3D; 0<br>$$</p><p>用法：需要1.原函数（关键） 2.若干个使函数值相等的点</p><ol><li><p>$$<br>由f^1x,f^nx讨论零点存在性和个数<br>$$</p></li><li><p>$$<br>证明由x,f(x),f^1(x)组成的等式<br>$$</p></li></ol><h3 id="2-2-拉格朗日中值定理"><a href="#2-2-拉格朗日中值定理" class="headerlink" title="2.2 拉格朗日中值定理"></a>2.2 拉格朗日中值定理</h3><p>$$<br>连续可导\rightarrow∃x_0∈(a,b),\frac{f(b)-f(a)}{b-a}&#x3D;f^1(x_0)<br>$$</p><p>用法：</p><ol><li>求极限，利用拉格朗日中值定理去除外层函数，化繁为简</li><li>证明等式，变形式子，找函数差f(b)-f(a)，并确定f^1(x0)是否为参数项</li><li>证明不等式，变形式子，找f^1(x0)，得不等式</li></ol><h3 id="2-3-泰勒展开"><a href="#2-3-泰勒展开" class="headerlink" title="2.3 泰勒展开"></a>2.3 泰勒展开</h3><p>技巧：如何能快速确定精度，展开到几阶</p><ol><li><p>A&#x2F;B型，展开分子分母为同阶</p></li><li><p>A-B型，找幂次最低，分别展开AB，展开到他们的某一项系数不相等为止</p></li><li><p>复合函数双泰勒展开型，看所要求精度和内外层函数展开最低阶为多少</p><p>内层最低阶数高，外层展开到该阶数，精度等于，外层展开阶数×内层最低阶数，则内层展开到该阶数</p><p>外层最低阶数高，内层展开到该阶数，精度等于，外层最低阶数×内层展开阶数，则外层展开到该阶数</p></li></ol><p>如何用：</p><ol><li><p>用于求解极限问题，用多项式代替复杂函数，从而化繁为简（用佩亚诺余项）</p></li><li><p>用于证明不等式&#x2F;等式<br>有端点和f^2(x)想到泰勒展开</p><p>无f^1(x)，且有f(a+b&#x2F;2)想到在中点展开</p></li></ol><h2 id="3-微分中值定理中构造辅助函数的方法"><a href="#3-微分中值定理中构造辅助函数的方法" class="headerlink" title="3 微分中值定理中构造辅助函数的方法"></a>3 微分中值定理中构造辅助函数的方法</h2><ol><li><p><em><strong>积分原函数法</strong></em></p><p>将待证明等式整理到等式一边，令这个式子等于F&#96;(x)，两边积分，得出F(x)</p><p><strong>原函数法特别适合所证式子中包含f(x)和g(x)两个函数的情况。</strong></p></li><li><p><em><strong>微分方程法</strong></em></p><p>将所证明的表达式看成是微分方程  ，从中求解F（y,x）&#x3D;0，然后忽略掉常数项，替换为F(f(x),x)就是我们要找的辅助函数了</p></li><li><p><em><strong>常用表格对照</strong></em></p><p><img src="/Users/moon/Downloads/v2-2d7645a8c95f9e4960c8697be4521cb5_1440w.png" alt="v2-2d7645a8c95f9e4960c8697be4521cb5_1440w"></p></li></ol><h1 id="第三章-一元函数积分学"><a href="#第三章-一元函数积分学" class="headerlink" title="第三章 一元函数积分学"></a>第三章 一元函数积分学</h1><h2 id="1-不定积分"><a href="#1-不定积分" class="headerlink" title="1 不定积分"></a>1 不定积分</h2><h3 id="1-1原函数概念"><a href="#1-1原函数概念" class="headerlink" title="1.1原函数概念"></a>1.1原函数概念</h3><p>性质：原函数推导函数，奇偶对换，周期相同；导函数推原函数，奇变偶不变，周期不继承</p><p><strong>如果一个函数f(x)是一个非零的偶函数，那么在它的所有的原函数中只有一个是奇函数（这一个奇函数就是∫[0→x]f(x)dt），其他的原函数都是非奇非偶函数</strong></p><p><strong>如果一个函数f(x)是以T为周期的周期函数，那么它的原函数减去x•(∫[0→T]f(t)dt)&#x2F;T一定也是以T为周期的周期函数，所以∫[0→T]f(t)dt&#x3D;0时原函数是周期函数</strong></p><h4 id="1-1-1-原函数与定积分存在定理的辨析"><a href="#1-1-1-原函数与定积分存在定理的辨析" class="headerlink" title="1.1.1 原函数与定积分存在定理的辨析"></a>1.1.1 原函数与定积分存在定理的辨析</h4><ul><li>在区间上有原函数不一定可积</li><li>在区间上可积不一定有原函数</li></ul><p><strong>原函数存在定理:</strong></p><ul><li>函数在区间上连续，必有原函数</li><li>振荡间断点有可能存在原函数</li><li>可去间断点，跳跃间断点，无穷间断点，不存在原函数</li></ul><p><strong>定积分存在定理:</strong></p><ul><li>函数在闭区间内连续，则定积分存在</li><li>函数在闭区间内有界，且只有有限个间断点，则定积分存在</li><li>函数在闭区间上单调，则定积分存在</li></ul><h3 id="1-2-不定积分和定积分"><a href="#1-2-不定积分和定积分" class="headerlink" title="1.2 不定积分和定积分"></a>1.2 不定积分和定积分</h3><p>不定积分：求F(x)原函数，C值不定</p><p>定积分：求面积，是个固定的数</p><h3 id="1-3-不定积分基本公式"><a href="#1-3-不定积分基本公式" class="headerlink" title="1.3 不定积分基本公式"></a>1.3 不定积分基本公式</h3><h3 id="1-4-不定积分的性质"><a href="#1-4-不定积分的性质" class="headerlink" title="1.4 不定积分的性质"></a>1.4 不定积分的性质</h3><p>加减可拆性，常数可外挪</p><h3 id="1-5-定积分中值定理"><a href="#1-5-定积分中值定理" class="headerlink" title="1.5 定积分中值定理"></a>1.5 定积分中值定理</h3><p>$$<br>f(x)在[a,b]上连续，则∃\xi∈[a,b]，有\int_{a}^{b}f(x)dx &#x3D;f(\xi)(b-a)<br>$$</p><p>如何用：</p><ul><li><p>求极限（积分上下限之差与分子、分母同阶时使用）</p></li><li><p>积分估值<br>$$<br>\int_{a}^{b}f(x)dx，将f(x)当做常数，即可提出积分号，这个常数为f(\xi)，\int_{a}^{b}f(x)dx&#x3D;f(\xi)\int_{a}^{b}dx &#x3D; (b-a)f(\xi)<br>$$<br>易错点：一定要注意另一个函数不变号，否则不能提出</p></li></ul><h3 id="1-6-1-凑微分法"><a href="#1-6-1-凑微分法" class="headerlink" title="1.6.1 凑微分法"></a>1.6.1 凑微分法</h3><h3 id="1-6-2-换元积分法"><a href="#1-6-2-换元积分法" class="headerlink" title="1.6.2 换元积分法"></a>1.6.2 换元积分法</h3><ol><li><p>有根号+有平方<br>$$<br>\sqrt{a^2-x^2}\rightarrow x&#x3D;asint\<br>\sqrt{a^2+x^2}\rightarrow x&#x3D;atant\<br>\sqrt{x^2-a^2}\rightarrow x&#x3D;asect\<br>$$</p></li><li><p>有根号，无平方项<br>$$<br>t&#x3D;\sqrt{….}<br>$$</p></li><li><p>换掉arctanx，e^x等</p></li><li><p>倒代换，分母x最高次数高于分子2次以上时可用<br>$$<br>t&#x3D;\frac{1}{x}<br>$$</p></li><li><p>指数代换被积函数由a^x形式构成时用</p></li><li><p>三角函数换元法</p></li></ol><p>助记：看见根号，无论用三角代换还是整体代换，目的是消除根号，使积分化难为易；看见分母高次，分子低次，使用倒代换；看到a^x形式，可令其为t，使指数式变成简单的含有形式便于积分</p><h3 id="1-7-分部积分"><a href="#1-7-分部积分" class="headerlink" title="1.7 分部积分"></a>1.7 分部积分</h3><p>$$<br>(uv)^1 &#x3D; u^1v+uv^1\rightarrow uv&#x3D;\int u^1vdx+\int uv^1dx<br>$$</p><p>$$<br>\int udv &#x3D; uv-\int vdu<br>$$</p><p>$$<br>\int f(x)g^{(2)}(x)dx&#x3D;f(x)g^{(1)}(x)-f^{(1)}(x)g(x)+\int f^{(2)}(x)g(x)dx<br>$$</p><p>如何用：<br>$$<br>若\int u^1vdx中v难处理，而v^1好处理，则可以通过分部积分转变，比较常见的难处理的v：反三角函数，对数函数等<br>$$<br>分部积分的优先级：<strong>DETAIL</strong> D表示dv，E指数函数，T三角函数，A代数函数，I反三角函数，L对数函数，越前面的放到里面的优先级越高</p><h3 id="1-8-不定积分解题方法论"><a href="#1-8-不定积分解题方法论" class="headerlink" title="1.8 不定积分解题方法论"></a>1.8 不定积分解题方法论</h3><h4 id="1-8-1-有理函数积分"><a href="#1-8-1-有理函数积分" class="headerlink" title="1.8.1 有理函数积分"></a>1.8.1 有理函数积分</h4><ul><li><p>$$<br>遇到包含(1+x^n)的式子，n位较高阶，想到可以构造成(1+x^{\frac{n}{3}})·(1-x^{\frac{n}{3}}+x^{\frac{2n}{3}})<br>$$</p></li><li><p><strong>遇到分式且包含根号</strong>，优先考虑把根号凑进微分里</p></li><li><p><strong>分式中遇到分母高次，分子低次的情况</strong>，考虑对分子进行加减相同数的操作，目的是使积分式分裂成两个易于积分的分式</p></li></ul><h4 id="1-8-2-三角有理式积分"><a href="#1-8-2-三角有理式积分" class="headerlink" title="1.8.2 三角有理式积分"></a>1.8.2 三角有理式积分</h4><ul><li><p><strong>遇到f(sinx,cosx)的式子</strong>，如果是sinx和cosx为加法关系，优先考虑万能代换，如果为乘法分式关系，优先考虑换元法</p><p>一般方法（万能代换）：<br>$$<br>令tan\frac{x}{2}&#x3D;t\\sin x&#x3D;\frac{2t}{1+t^2}\ \cos x&#x3D;\frac{1-t^2}{1+t^2}\dt&#x3D;\frac{2}{1+t^2}<br>$$<br>特殊方法（三角变换，换元，分部）：<br>$$<br>若R(-\sin x ,\cos x)&#x3D;-R(\sin x,\cos x)，则令u&#x3D;\cos x\<br>若R(\sin x ,-\cos x)&#x3D;-R(\sin x,\cos x)，则令u&#x3D;\sin x\<br>若R(-\sin x ,-\cos x)&#x3D;R(\sin x,\cos x)，则令u&#x3D;\tan x<br>$$</p></li></ul><h4 id="1-8-3-简单无理函数积分"><a href="#1-8-3-简单无理函数积分" class="headerlink" title="1.8.3 简单无理函数积分"></a>1.8.3 简单无理函数积分</h4><ul><li>$$<br>遇到\int R(x,\sqrt{\frac{ax+b}{cx+b}})，令\sqrt{\frac{ax+b}{cx+b}}&#x3D;t，转化为有理函数积分进行运算<br>$$</li></ul><h2 id="2-定积分"><a href="#2-定积分" class="headerlink" title="2 定积分"></a>2 定积分</h2><h3 id="2-1-定积分的几何应用"><a href="#2-1-定积分的几何应用" class="headerlink" title="2.1 定积分的几何应用"></a>2.1 定积分的几何应用</h3><p>技巧：1.定变量 2.找微元 3.得积分</p><p>定积分几何应用第一原理：</p><ul><li>分割（化整为零） 把整体化为n个小的曲边梯形</li><li>近似替代（以直代曲）每个曲边梯形从小矩形面积代替</li><li>求和（化整为零）累加所有小矩形面积</li><li>取极限（整体近似）所有小矩形合并近似为整个大曲边梯形</li></ul><h3 id="2-2-定积分的物理应用"><a href="#2-2-定积分的物理应用" class="headerlink" title="2.2 定积分的物理应用"></a>2.2 定积分的物理应用</h3><h3 id="2-3-定积分的解题方法论"><a href="#2-3-定积分的解题方法论" class="headerlink" title="2.3 定积分的解题方法论"></a>2.3 定积分的解题方法论</h3><h4 id="2-3-1-利用公式"><a href="#2-3-1-利用公式" class="headerlink" title="2.3.1 利用公式"></a>2.3.1 利用公式</h4><p>三角函数点火公式<br>$$<br>\int_{0}^{\frac{\pi}{2}}\sin ^n xdx&#x3D;\int_{0}^{\frac{\pi}{2}}\cos ^n xdx&#x3D;\frac{n-1}{n}·\frac{n-3}{n-2}····\frac{1}{2}·\frac{\pi}{2}—–n为偶数\&#x3D;\frac{n-1}{n}·\frac{n-3}{n-2}····\frac{2}{3}—–n为大于1的奇数<br>$$</p><p>$$<br>\int_{0}^{n\pi}xf(\sin x)dx&#x3D;\frac{n\pi}{2}\int_{0}^{n\pi}f(\sin x)<br>$$</p><p>$$<br>\int_{0}^{2\pi}\cos^2xdx&#x3D;4\int_0^{\frac{\pi}{2}}\sin^2xdx&#x3D;\pi<br>$$</p><h4 id="2-3-2-换元法"><a href="#2-3-2-换元法" class="headerlink" title="2.3.2 换元法"></a>2.3.2 换元法</h4><ul><li><p>$$<br>形如\int_0^{\frac{\pi}{2}}\frac{\sin ^px}{\sin^px+\cos^px}dx和\int_0^{\frac{\pi}{2}}\frac{1}{1+\tan^px}dx\<br>令x&#x3D;\frac{\pi}{2}-t<br>$$</p><p>这种换元法的特点是区间不变，一般可以用<br>$$<br>\int_a^bf(x)dx—x&#x3D;a+b-t—\int_a^bf(a+b-t)dt<br>$$</p></li></ul><h2 id="3-积分进阶"><a href="#3-积分进阶" class="headerlink" title="3 积分进阶"></a>3 积分进阶</h2><h3 id="3-1-变限函数概念与求导"><a href="#3-1-变限函数概念与求导" class="headerlink" title="3.1 变限函数概念与求导"></a>3.1 变限函数概念与求导</h3><p>$$<br>\int_{g_1(x)}^{g_2(x)}f(t)dt &#x3D; \int_{a}^{g_2(x)}f(t)dt-\int_{a}^{g_1(x)}f(t)dt<br>$$</p><p>公式：<br>$$<br>\frac{d}{dx}\int_{g_1(x)}^{g_2(x)}f(x,t)dt &#x3D; \int_{g_1(x)}^{g_2(x)}\frac{d}{dx}f(x,t)dt+f(x,g_2(x))g^{(1)}_2(x)-f(x,g_1(x))g^{(1)}_1(x)\<br>最好用换元法把(x,t)换为u再进行公式带入<br>$$<br>五大题型：</p><ol><li>变限+极限 洛必达求导</li><li>被积函数为分段函数 讨论+拆积分区域</li><li>被积函数为x可拆至∫外的复合函数 ，用公式</li><li>被积函数为x不可拆至∫外的复合函数，用公式</li><li>积分上限函数证明题</li></ol><h3 id="3-2-变上限积分的连续性与可导性判断"><a href="#3-2-变上限积分的连续性与可导性判断" class="headerlink" title="3.2 变上限积分的连续性与可导性判断"></a>3.2 变上限积分的连续性与可导性判断</h3><ul><li>函数可积，原函数必然连续</li><li>函数连续，则原函数必然可导；函数只有可去间断点，原函数必然可导；函数有跳跃间断点，原函数连续但不可导</li></ul><h3 id="3-3-积分不等式"><a href="#3-3-积分不等式" class="headerlink" title="3.3 积分不等式"></a>3.3 积分不等式</h3><p>常用方法：</p><ul><li><p>变量代换</p></li><li><p>积分中值定理</p></li><li><p>变上限积分</p><p>将待求的定积分不等式转化为变上限积分不等式</p></li><li><p>柯西积分不等式<br>$$<br>看到函数的平方和导函数的平方想到柯西不等式：\int_a^bf(x)g(x)dx)^2≦\int_a^bf^2(x)dx\int_a^bg^2(x)dx<br>$$</p></li><li><p>公式：<br>$$<br>看到绝对值就要想起来的不等式：|\int_a^bf(x)dx|≦\int_a^b|f(x)|dx<br>$$</p><p>$$<br>跟最值有关的不等式：m(b-a)≦\int_a^bf(x)dx≦M(b-a)其中m，M为(a,b)上的最小值和最大值<br>$$</p></li></ul><h3 id="3-4-反常积分"><a href="#3-4-反常积分" class="headerlink" title="3.4 反常积分"></a>3.4 反常积分</h3><p>比较法的极限形式：高阶函数收敛则低阶函数收敛，低价函数发散则高阶函数发散</p><h3 id="3-5-求积分函数"><a href="#3-5-求积分函数" class="headerlink" title="3.5 求积分函数"></a>3.5 求积分函数</h3><p>对于包含变上限积分函数的等式，要求积分函数，可两边同时求导；对于包含定积分函数的的等式，可将定积分函数视为常数，然后两边同时积分</p><h1 id="第四章-常微分方程"><a href="#第四章-常微分方程" class="headerlink" title="第四章 常微分方程"></a>第四章 常微分方程</h1><h2 id="1-一阶微分方程"><a href="#1-一阶微分方程" class="headerlink" title="1 一阶微分方程"></a>1 一阶微分方程</h2><ol><li><p>可分离变量的方程 两端积分</p></li><li><p>齐次方程 令u&#x3D;y&#x2F;x</p></li><li><p>线性方程<br>$$<br>一阶线性微分方程\dot y+P(x)y&#x3D;Q(x)\y&#x3D;e^{-\int P(x)dx}[\int Q(x)e^{\int P(x)dx}dx+C]<br>$$</p></li><li><p>伯努利方程 线性方程中Q(x)为高阶形式，令u&#x3D;y^1-n，将原方程化为一阶线性微分方程</p></li><li><p>全微分方程</p></li></ol><h2 id="2-可降价的高阶方程"><a href="#2-可降价的高阶方程" class="headerlink" title="2 可降价的高阶方程"></a>2 可降价的高阶方程</h2><h3 id="2-1-可降阶的高阶方程"><a href="#2-1-可降阶的高阶方程" class="headerlink" title="2.1 可降阶的高阶方程"></a>2.1 可降阶的高阶方程</h3><ol><li><p>$$<br>\ddot y&#x3D;f(x,\dot y)\<br>令\dot y&#x3D;p,\ddot y&#x3D;\dot p<br>$$</p></li><li><p>$$<br>\ddot y&#x3D;f(y,\dot y)\<br>令\dot y&#x3D;p,\ddot y&#x3D;p\frac{dp}{dy}<br>$$</p></li></ol><h3 id="2-2-解的结构"><a href="#2-2-解的结构" class="headerlink" title="2.2 解的结构"></a>2.2 解的结构</h3><p>解的结构有四个定理，分别是：</p><p>齐次方程的两个线性无关的特解可以构成这个方程的通解</p><p>非齐次方程的通解由齐次方程的两个线性无关的特解和非齐次方程的一个特解构成</p><p>如果y1和y2为非齐次方程的两个特解，则他们两之差等于齐次微分方程的解</p><p>两个非齐次方程的特解相加为这两个非齐次方程非齐次项相加后的非齐次方程的特解</p><h3 id="2-3-微分方程的一般形式"><a href="#2-3-微分方程的一般形式" class="headerlink" title="2.3 微分方程的一般形式"></a>2.3 微分方程的一般形式</h3><p>务必熟记</p><h3 id="2-4-解题方法论"><a href="#2-4-解题方法论" class="headerlink" title="2.4 解题方法论"></a>2.4 解题方法论</h3><p><strong>欧拉方程</strong>：<br>$$<br>令x&#x3D;e^t\<br>x^ky^k&#x3D;D(D-1)…(D-k+1)y<br>$$<br><strong>知道解，找非齐次方程</strong>：首先找到两个线性无关的齐次解，就知道了齐次方程的特征方程，然后再用一个非齐次的特解带入即可得到非齐次方程</p><h1 id="第五章-空间几何"><a href="#第五章-空间几何" class="headerlink" title="第五章 空间几何"></a>第五章 空间几何</h1><h2 id="1-空间向量"><a href="#1-空间向量" class="headerlink" title="1 空间向量"></a>1 空间向量</h2><h3 id="1-1-空间直角坐标"><a href="#1-1-空间直角坐标" class="headerlink" title="1.1 空间直角坐标"></a>1.1 空间直角坐标</h3><h3 id="1-2-向量表示与运算"><a href="#1-2-向量表示与运算" class="headerlink" title="1.2 向量表示与运算"></a>1.2 向量表示与运算</h3><h3 id="1-3-向量的数量积与向量积"><a href="#1-3-向量的数量积与向量积" class="headerlink" title="1.3 向量的数量积与向量积"></a>1.3 向量的数量积与向量积</h3><p>数量积：<br>$$<br>a·b&#x3D;|a||b|\cosθ 等于零时 垂直\<br>a·b&#x3D;a_xb_x+a_yb_y+a_zb_z<br>$$<br>向量积：<br>$$<br>|a×b|&#x3D;|a||b|\sinθ等于零时平行<br>$$</p><h3 id="1-4-混合积"><a href="#1-4-混合积" class="headerlink" title="1.4 混合积"></a>1.4 混合积</h3><h3 id="1-5-方向余弦"><a href="#1-5-方向余弦" class="headerlink" title="1.5 方向余弦"></a>1.5 方向余弦</h3><p>$$<br>cos\alpha&#x3D;\frac{a}{\sqrt{a^2+b^2+c^2}}\<br>$$</p><h2 id="2-空间几何"><a href="#2-空间几何" class="headerlink" title="2 空间几何"></a>2 空间几何</h2><h3 id="2-1-平面与空间直线"><a href="#2-1-平面与空间直线" class="headerlink" title="2.1 平面与空间直线"></a>2.1 平面与空间直线</h3><ul><li><p>平面方程</p><p>法向量n&#x3D;(A,B.C)，平面上的点(x0,y0,c0)<br>$$<br>一般式：Ax+By+Cz-(Ax_0+Bx_0+Cx_0)&#x3D;0\<br>点法式：A(x-x_0)+B(y-y_0)+C(z-z_0)&#x3D;0\<br>截距式：\frac{x}{a}+\frac{x}{b}+\frac{x}{c}&#x3D;1<br>$$</p></li><li><p>直线方程<br>$$<br>一般式：\begin{cases}<br>A_1x+B_1x+C_1x+D_1\<br>A_2x+B_2x+C_2x+D_2\<br>\end{cases}\<br>对称式：\frac{x-x_0}{l}&#x3D;\frac{y-y_0}{m}&#x3D;\frac{z-z_0}{n}\<br>参数式：x&#x3D;x_0+lt,y&#x3D;y_0+mt,z&#x3D;z_0+nt<br>$$</p></li></ul><h3 id="2-2-曲面与空间曲线"><a href="#2-2-曲面与空间曲线" class="headerlink" title="2.2 曲面与空间曲线"></a>2.2 曲面与空间曲线</h3><ul><li><p>曲面方程<br>$$<br>一般式:F(x,y,z)&#x3D;0<br>$$</p></li><li><p>空间曲线<br>$$<br>参数式:\begin{cases}<br>x&#x3D;x(t)\y&#x3D;y(t)\z&#x3D;z(t)<br>\end{cases}\<br>一般式:\begin{cases}<br>F(x,y,z)&#x3D;0\<br>G(x,y,z)&#x3D;0<br>\end{cases}<br>$$</p></li><li><p>旋转面</p><p>平面曲线绕平面上一条直线旋转一周所形成的曲面</p></li><li><p>柱面</p><p>平行于定直线并沿定曲线移动的直线L形成的轨迹，方程为关于x,y的二元方程f(x,y)&#x3D;0</p></li><li><p>二次曲面<br>$$<br>椭圆锥面:\frac{x^2}{a^2}+\frac{y^2}{b^2}&#x3D;z^2\<br>椭球面:\frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}&#x3D;1\<br>椭圆抛物面：\frac{x^2}{a^2}+\frac{y^2}{b^2}&#x3D;z<br>$$<br><img src="http://staff.ustc.edu.cn/~rui/ppt/function-pictures/c-surface/tuoyuan-paowu.gif" alt="img" style="zoom:67%;"><img src="http://staff.ustc.edu.cn/~rui/ppt/function-pictures/c-surface/tuo-qiu.gif" alt="img" style="zoom:67%;"><img src="http://staff.ustc.edu.cn/~rui/ppt/function-pictures/c-surface/zuimian.gif" alt="img" style="zoom:67%;"></p></li></ul><h3 id="2-3-曲面与曲线的切线与法线"><a href="#2-3-曲面与曲线的切线与法线" class="headerlink" title="2.3 曲面与曲线的切线与法线"></a>2.3 曲面与曲线的切线与法线</h3><ul><li><p>曲面的切平面与法线<br>$$<br>曲面:F(x,y,z)&#x3D;0\<br>法线:n&#x3D;(\dot F(x),\dot F(y),\dot F(z))\<br>$$</p></li><li><p>曲线的切线与法平面<br>$$<br>曲线:\begin{cases}<br>F(x,y,z)&#x3D;0\<br>G(x,y,z)&#x3D;0<br>\end{cases}<br>\切线:\tau&#x3D;n_1×n_2<br>$$</p></li></ul><h1 id="第五章-多元函数微分学"><a href="#第五章-多元函数微分学" class="headerlink" title="第五章 多元函数微分学"></a>第五章 多元函数微分学</h1><h2 id="1-重极限、连续、偏导数、全微分"><a href="#1-重极限、连续、偏导数、全微分" class="headerlink" title="1 重极限、连续、偏导数、全微分"></a>1 重极限、连续、偏导数、全微分</h2><h3 id="1-1-重极限"><a href="#1-1-重极限" class="headerlink" title="1.1 重极限"></a>1.1 重极限</h3><p><strong>求重极限</strong></p><p>在求重极限中不能运用洛必达法则，但是可以使用夹逼定理和函数有界性等，所以解重极限的一般方法是用下列不等式，然后再用夹逼定理或者函数有界性求极限</p><p>三个方法：</p><ul><li>利用极限性质（四则运算法则，夹逼定理）</li><li>消去分母中极限为零的因子（有理化，等价无穷小）</li><li>利用无穷小量与有界变量之积为无穷小量</li></ul><p>$$<br>f(x)\to0&#x3D;&#x3D;|f(x)|\to0\a^2+b^2≧2ab\|x|+|y|≧|x+y|<br>$$</p><p><strong>证明重极限不存在</strong></p><p>沿两种不同路径得到的极限不同（通常可取过(x0,y0)的直线）</p><p><strong>全微分</strong><br>$$<br>Δz&#x3D;f(x_0+Δx,y_0+Δy)-f(x_0+y_0)&#x3D;AΔx+BΔy+o(\sqrt{(Δx)^2+(Δy)^2})\<br>$$</p><p>可微性判定条件： </p><p>必要条件：可微一定可导，可导不一定可微</p><p><u>充分条件：偏导数连续一定可微，可微不一定偏导数连续</u></p><p>需要知道充分条件的证明方法，用拉格朗日中值定理</p><p>所以判定方法为先判定是否可导，如果不可导一定不可微，再代入定义 判定</p><h2 id="2-偏导数与全微分的计算"><a href="#2-偏导数与全微分的计算" class="headerlink" title="2 偏导数与全微分的计算"></a>2 偏导数与全微分的计算</h2><h3 id="2-1-求具体点的偏导数及全微分"><a href="#2-1-求具体点的偏导数及全微分" class="headerlink" title="2.1 求具体点的偏导数及全微分"></a>2.1 求具体点的偏导数及全微分</h3><p>先代后求</p><h3 id="2-2-求具体表达式的偏导数及全微分"><a href="#2-2-求具体表达式的偏导数及全微分" class="headerlink" title="2.2 求具体表达式的偏导数及全微分"></a>2.2 求具体表达式的偏导数及全微分</h3><p><strong>全微分相关：</strong><br>$$<br>P(x,y)dx+Q(x,y)dy&#x3D;dz\\frac{\partial P}{\partial y}&#x3D;\frac{\partial Q}{\partial x}<br>$$<br>已知全微分，求函数本身：①偏积分：构建两种积分的等价关系 ②凑微分：不好凑的放一起，好凑的放一起</p><h3 id="2-3-求抽象函数的复合函数的偏导数及全微分"><a href="#2-3-求抽象函数的复合函数的偏导数及全微分" class="headerlink" title="2.3 求抽象函数的复合函数的偏导数及全微分"></a>2.3 求抽象函数的复合函数的偏导数及全微分</h3><p>结论1：<br>$$<br>若f(x,y)可微，则f(x,y)是n次齐次函数⇔x\frac{\partial f}{\partial x}+y\frac{\partial f}{\partial y}&#x3D;nf(x,y)<br>$$</p><h3 id="2-4-隐函数求导法"><a href="#2-4-隐函数求导法" class="headerlink" title="2.4 隐函数求导法"></a>2.4 隐函数求导法</h3><p>方法</p><ul><li><p>公式<br>$$<br>\frac{\partial z}{\partial x}&#x3D;-\frac{\dot F_x}{\dot F_z}<br>$$</p></li><li><p>等式两边求导</p></li><li><p>利用微分形式不变性</p></li></ul><h2 id="3-极值与最值"><a href="#3-极值与最值" class="headerlink" title="3 极值与最值"></a>3 极值与最值</h2><h3 id="3-1-无条件极值"><a href="#3-1-无条件极值" class="headerlink" title="3.1 无条件极值"></a>3.1 无条件极值</h3><p>极值判定的必要条件：偏导数等于0</p><p>极值判定的充分条件：偏导数等于0，AC-B^2的正负性</p><h3 id="3-2-条件极值及拉格朗日乘数法"><a href="#3-2-条件极值及拉格朗日乘数法" class="headerlink" title="3.2 条件极值及拉格朗日乘数法"></a>3.2 条件极值及拉格朗日乘数法</h3><p>构造拉格朗日函数<br>$$<br>F(x,y,\lambda)&#x3D;f(x,y)+\lambda\phi(x,y)<br>$$<br>然后求F对x，y，λ求偏导，偏导的值为0，解出的x，y为可能的极值</p><h3 id="3-3-最大最小值"><a href="#3-3-最大最小值" class="headerlink" title="3.3 最大最小值"></a>3.3 最大最小值</h3><h2 id="4-方向导数"><a href="#4-方向导数" class="headerlink" title="4 方向导数"></a>4 方向导数</h2><h3 id="4-1-方向导数的概念及计算"><a href="#4-1-方向导数的概念及计算" class="headerlink" title="4.1 方向导数的概念及计算"></a>4.1 方向导数的概念及计算</h3><p><strong>方向导数的充分条件</strong></p><p>可微或者偏导数连续，可微则方向导数一定存在，但是不可微方向导数也可能存在，方向导数存在不一定可微</p><p><strong>方向导数和偏导数有什么区别</strong></p><ol><li>偏导数是沿平行于x轴&#x2F;y轴方向切开曲面形成那条曲线的导数</li><li>偏导数是函数某维度（x&#x2F;y）的导，方向导数是函数在某点对某一方向的求导</li></ol><p><strong>方向导数的数学表达式怎么理解</strong><br>$$<br>\vec L决定了我们选选xoy平面上哪条射线切割曲面\<br>\vec{L}&#x3D;\left{x_0+cos\alpha,y_0+cos\beta\right}\<br>过哪点？(x_0,y_0)\<br>沿什么方向？(cos\alpha,cos\beta)<br>$$<br><strong>方向导数的定义式怎么理解</strong><br>$$<br>\lim_{t\to0^+}\frac{f(x_0+t\cos\alpha,y_0+t\cos\beta)-f(x_0,y_0)}{t}&#x3D;\left.\frac{\partial f}{\partial \vec L }\right|_{(x_0,y_0)}&#x3D;f^{(1)}_x(x_0,y_0)\cos(\alpha)+f^{(1)}_y(x_0,y_0)\cos(\beta)<br>$$</p><p><strong>方向导数的几何意义</strong></p><p>做同时过L和z轴的平面，平面S垂直于xoy平面，S与函数所表示的曲面的交线为M，M与L的夹角为t，该函数的方向导数为tan t</p><h3 id="4-2-梯度的概念与计算"><a href="#4-2-梯度的概念与计算" class="headerlink" title="4.2 梯度的概念与计算"></a>4.2 梯度的概念与计算</h3><p>公式：<br>$$<br>\frac{\partial g}{\partial L}&#x3D; |\vec {grad f}|·|\vec L|·\cosθ\<br>梯度：\vec{grad}f&#x3D;\left{f^{(1)}_x(x_0,y_0),f^{(1)}_y(x_0,y_0)\right}\<br>多元函数\to向量<br>$$</p><h1 id="第六章-多元函数积分学"><a href="#第六章-多元函数积分学" class="headerlink" title="第六章 多元函数积分学"></a>第六章 多元函数积分学</h1><ul><li>何时可以把曲面式子代入多元积分的被积函数中：①线面积分可以代入 ②重积分不可代入，用了格林公式或者高斯公式之后，线面积分转为了重积分，就不能代入了</li></ul><h2 id="1-二重积分"><a href="#1-二重积分" class="headerlink" title="1 二重积分"></a>1 二重积分</h2><h3 id="1-1-二重积分的性质"><a href="#1-1-二重积分的性质" class="headerlink" title="1.1 二重积分的性质"></a>1.1 二重积分的性质</h3><ul><li><p>不等式性质<br>$$<br>f(x,y)≦g(x,y)\to\iint_Df(x,y)d\sigma≦\iint_Dg(x,y)d\sigma<br>$$</p><p>$$<br>mS≦\iint_Df(x,y)d\sigma≦MS<br>$$</p><p>$$<br>|\iint_Df(x,y)d\sigma|≦\iint_D|f(x,y)|d\sigma<br>$$</p></li><li><p>积分中值定理<br>$$<br>\iint_Df(x,y)d\sigma&#x3D;f(\xi,ƞ)S<br>$$</p></li></ul><h3 id="1-2-二重积分解题方法"><a href="#1-2-二重积分解题方法" class="headerlink" title="1.2 二重积分解题方法"></a>1.2 二重积分解题方法</h3><p><strong>逐次积分</strong></p><ol><li>拆开积分，用于表达式不唯一</li><li>对称简化，积分区域关于x y轴对称，且被积函数关于x y为奇函数 偶函数</li><li>积分次序改变</li><li>坐标互换，出现平方，且用直角坐标搞不定的时候换成极坐标来做</li><li>常见积分值</li></ol><p><strong>对于圆心不在原点的圆：</strong></p><p>平移加极坐标（x-n&#x3D;rcosθ)</p><p><strong>形心公式</strong><br>$$<br>细棒：\overline x&#x3D;\frac{\int_a^bxdx}{b-a}&#x3D;<br>\平面板：\overline x&#x3D;\frac{\iint_Dxd\sigma}{S}<br>$$<br><strong>证明二重积分等于定积分：</strong></p><p>把二重积分换成累次积分，如果还算不了就，换元法，交换次序</p><h2 id="2-三重积分"><a href="#2-三重积分" class="headerlink" title="2 三重积分"></a>2 三重积分</h2><p>$$<br>\iiint_\Omega f(x,y,z)dV<br>$$</p><p><strong>计算方法：</strong></p><ul><li><p>直角坐标（先二后一，先一后二）</p></li><li><p>柱坐标（本质是极坐标与直角坐标的结合）<br>$$<br>\iiint_\Omega f(x,y,z)dV&#x3D;\iiint_\Omega f(r\cos\theta,r\sin\theta,z)rdrd\theta dz\<br>适合用的函数:f(\sqrt{x^2+y^2})\Phi(z)\<br>适合用的\Omega区域:中心为z轴的图形<br>$$</p></li><li><p>球坐标（空间域的极坐标）<br>$$<br>\iiint_\Omega f(x,y,z)dV&#x3D;\iiint_\Omega f(r\sin\phi\cos\theta,r\sin\phi\sin\theta,r\cos\phi)r^2\sin\phi drd\phi d\theta\<br>适合用的函数:f(\sqrt{x^2+y^2+z^2})\<br>适合用的\Omega区域:中心为原点的图形<br>$$</p></li><li><p>奇偶性 同二重积分</p></li><li><p>利用变量的对称性 通常用来求解不适合与球坐标和柱坐标的题目</p></li></ul><p><strong>判断用哪种方法</strong></p><ul><li>适合先二后一的：①被积函数为f(z)的一元函数 ②用z&#x3D;z的平面去截区域的截痕面积好求   先对xy求，最后对z求</li><li>求三重积分的累次积分，需要交换次序，采用降维方法，每次交换只看两个变量，在二维平面上进行交换</li></ul><h2 id="3-曲线积分"><a href="#3-曲线积分" class="headerlink" title="3 曲线积分"></a>3 曲线积分</h2><h3 id="3-1-二类曲线积分运算"><a href="#3-1-二类曲线积分运算" class="headerlink" title="3.1 二类曲线积分运算"></a>3.1 二类曲线积分运算</h3><ol><li><p><strong>对弧长的线积分</strong><br>$$<br>第一类：\int_{L}f(x,y)ds<br>$$<br>关键在于转化ds，通常有3种方法：<br>$$<br>直角坐标+平面曲线：ds&#x3D;\sqrt{(△x)^2+(△y)^2}&#x3D;\sqrt{1+{y^{(1)} }^2}dx\<br>参数式+平面坐标：ds&#x3D;\sqrt{(x^{(1)}(t))^2+(y^{(1)}(t))^2}dt\<br>极坐标+平面曲线： ds&#x3D;\sqrt{ {r^{(1)} }^2+r^2}dθ\<br>空间曲线：ds&#x3D;\sqrt{(x^{(1)}(t))^2+(y^{(1)}(t))^2+(z^{(1)}(t))^2}dt<br>$$</p></li><li><p><strong>对坐标的线积分</strong></p><p>变力沿曲线做工，P(x,y)为力沿x轴的分力所做的功，Q(x,y)为力沿y轴的分力所做的功</p></li></ol><p>$$<br>第二类： \int_LP(x,y)dx+Q(x,y)dy<br>$$</p><p><strong>平面线积分</strong></p><ul><li><p>有参数，可以化为定积分</p></li><li><p>$$<br>x&#x3D;x(t),y&#x3D;y(t)\dx&#x3D;x^{(1)}dt\dy&#x3D;y^{(1)}dt<br>$$</p></li><li><p>化为二重积分，格林公式，万能公式，但是有两点需要注意</p></li><li><p>L是封闭，否则补成封闭曲线</p></li><li><p>被积函数在L围成区域内均存在，否则挖洞</p></li></ul><p><strong>空间线积分</strong></p><ul><li><p>利用原函数解决</p></li><li><p><strong>斯托克斯公式</strong>（空间坐标系中的格林公式）</p></li><li><p>$$<br>\oint P(x,y,z)dx+Q(x,y,z)dy+R(x,y,z)dz \<br>&#x3D;\iint_\Sigma\begin{vmatrix}<br>\cos\alpha&amp;\cos\beta&amp;\cos\gamma\\frac{\partial}{\partial x}&amp;\frac{\partial}{\partial y}&amp;\frac{\partial}{\partial z}\P&amp;Q&amp;R<br>\end{vmatrix}dS<br>\&#x3D;\iint_D(\frac{\partial R}{\partial y}-\frac{\partial Q}{\partial z})dydz+(\frac{\partial R}{\partial x}-\frac{\partial P}{\partial z})dxdz+(\frac{\partial Q}{\partial x}-\frac{\partial P}{\partial y})dxdy<br>$$</p></li><li><p>换元，化为平面线积分，降维的方法</p></li></ul><p>技巧总结：</p><ol><li><p>利用曲线表达式化简被积函数</p></li><li><p>利用奇偶性化简积分，简化计算</p><p>曲线L关于y&#x2F;x轴堆成+函数关于x&#x2F;y成奇&#x2F;偶，可用对称</p></li><li><p>利用轮换对称性简化计算，曲线积分中，各变量换位置，曲线表达不变，则可用轮换对称</p></li><li><p>利用曲线形心公式快速计算<br>$$<br>\bar x &#x3D; \frac{\int_Lxds}{\int_Lds}<br>$$</p></li></ol><h3 id="3-2-格林公式-路径无关"><a href="#3-2-格林公式-路径无关" class="headerlink" title="3.2 格林公式+路径无关"></a>3.2 格林公式+路径无关</h3><p><strong>格林公式</strong>：第二类曲线积分  转化为——  二重积分</p><p>该公式是连接第二类曲线积分与二重积分的桥梁<br>$$<br>\oint P(x,y)dx+Q(x,y)dy &#x3D; \iint_D(\frac{\partial Q}{\partial x}-\frac{\partial P}{\partial y})d\sigma<br>$$<br>公式中，L为逆时针，若L为顺时针，公式右边需加上负号</p><p>前提：①L是封闭，否则补成封闭曲线②被积函数在L围成区域内均存在，否则挖洞</p><p>当不满足上述前提时</p><p>某点处不连续——挖洞</p><p>L不封闭——构造若干条与x,y平行的直线，将L补全成封闭曲线</p><p><strong>路径无关</strong>：<br>$$<br>对于经过A，B任一分段光滑曲线L，都有\oint_LPdx+Qdy &#x3D; 0<br>$$<br>若P，Q在D上具有一阶连续偏导数，则有格林公式，由于L任意性，可得DL任意性，对于D中每一点均有<br>$$<br>\frac{\partial Q}{\partial x}&#x3D;\frac{\partial P}{\partial y}<br>$$<br>怎么用+技巧总结：</p><ul><li>利用原函数解决第二类曲线积分</li><li>构造曲线简化积分运算，改换路径</li></ul><p><strong>线积分与路径无关的判定定理</strong></p><p>设函数在单连通域D上有一阶连续偏导数，则以下四条等价<br>$$<br>1.线积分\int_L Pdx+Qdy与路径无关\<br>2.\oint_LPdx+Qdy&#x3D;0\<br>3.\frac{\partial P}{\partial y}&#x3D;\frac{\partial Q}{\partial x}（常用来判定是否路径无关）\<br>4.P(x,y)dx+Q(x,y)dy&#x3D;dF(x,y)<br>$$</p><p><strong>第二类线积分解题思路：</strong></p><p>先看路径是否为封闭，如果封闭首选格林公式，如果不封闭再看是否路径无关，如果路径无关就用路径无关的方法，如果路径不无关，要么补线用格林公式，要么利用原函数牛顿莱布尼茨公式</p><p><strong>重要结论！！！</strong><br>$$<br>对于线积分\int\frac{ydx-xdy}{x^2+y^2},P&#x3D;\frac{y}{x^2+y^2},Q&#x3D;\frac{-x}{x^2+y^2}\除原点(0,0以外),P,Q有连续一阶偏导数\且\frac{\partial P}{\partial y}&#x3D;\frac{\partial Q}{\partial x},(x,y)\neq(0,0)\\则\沿任何一条不包含原点在内的分段光滑闭曲线的积分为零\<br>沿任何一条包含原点在内的分段光滑闭曲线的积分均相等<br>$$</p><h2 id="4-曲面积分"><a href="#4-曲面积分" class="headerlink" title="4 曲面积分"></a>4 曲面积分</h2><h3 id="4-1-两类曲面积分的运算"><a href="#4-1-两类曲面积分的运算" class="headerlink" title="4.1 两类曲面积分的运算"></a>4.1 两类曲面积分的运算</h3><ol><li><p>$$<br>第一类：\iint_\Sigma f(x,y,z)ds<br>$$</p><p>关键在曲面投影域的计算：<br>$$<br>ds&#x3D;\sqrt{1+\dot Z_x^2+\dot Z_t^2}dxdy\<br>Z&#x3D;g(x,y)\<br>\Sigma\to D_{xoy}\<br>最终可得：\iint_\Sigma f(x,y,z)ds&#x3D;\iint_{Dxy}f(x,y,Z(x,y))\sqrt{1+\dot Z_x^2+\dot Z_t^2}dxdy<br>$$</p></li><li><p>$$<br>第二类：\iint_\Sigma P(x,y,z)dydz+Q(x,y,z)dxdz+R(x,y,z)dxdy<br>$$</p><p>方法是将曲面投影（有方向）</p><p><strong>待补充</strong></p></li></ol><p><strong>技巧总结</strong></p><ul><li><p>把曲面方程带入被积函数中简化运算</p></li><li><p>利用奇偶性简化运算</p></li><li><p>利用轮换对称性简化计算</p></li></ul><p><strong>高斯公式计算第二类曲面积分</strong><br>$$<br>\oiint_\Sigma Pdydz+Qdzdx+Rdxdy&#x3D;\iiint_\Omega(\frac{\partial P}{\partial x}+\frac{\partial Q}{\partial y}+\frac{\partial R}{\partial z})dv<br>$$</p><h1 id="第七章-无穷级数"><a href="#第七章-无穷级数" class="headerlink" title="第七章 无穷级数"></a>第七章 无穷级数</h1><h2 id="1-常数项级数"><a href="#1-常数项级数" class="headerlink" title="1 常数项级数"></a>1 常数项级数</h2><h3 id="1-1-级数基本性质"><a href="#1-1-级数基本性质" class="headerlink" title="1.1 级数基本性质"></a>1.1 级数基本性质</h3><ol><li><p>$$<br>若\sum_{n&#x3D;1}^\infty u_n收敛于S，则\sum_{n&#x3D;1}^\infty ku_n也收敛，其和为kS<br>$$</p></li><li><p>$$<br>若\sum_{n&#x3D;1}^\infty u_n,\sum_{n&#x3D;1}^\infty v_n收敛于S，则\sum_{n&#x3D;1}^\infty (u_n+v_n)收敛于S+\sigma<br>$$</p></li><li><p>$$<br>在级数中去掉加上改变 有限项，不会改变级数的敛散性<br>$$</p></li><li><p>$$<br>级数加括号以后收敛，原级数不一定收敛\级数加括号以后发散，原级数一定发散<br>$$</p></li><li><p>$$<br>级数收敛的必要条件：若级数\sum_{n&#x3D;1}^\infty u_n收敛则\lim_{n\to\infty}u_n&#x3D;0<br>$$</p></li></ol><h3 id="1-2-判断正项级数敛散性的方法"><a href="#1-2-判断正项级数敛散性的方法" class="headerlink" title="1.2 判断正项级数敛散性的方法"></a>1.2 判断正项级数敛散性的方法</h3><ol><li><p>比较判别法</p></li><li><p>比较法极限形式（充分条件，不能反推）<br>$$<br>\sum_{n&#x3D;1}^\infty\frac{1}{n^p},当p&gt;1收敛，p&lt;&#x3D;1发散\<br>\sum_{n&#x3D;1}^\infty aq^n,当q&gt;&#x3D;1发散，q&lt;1收敛<br>$$</p></li><li><p>比值法<br>$$<br>若\lim_{n\to\infty}\frac{u_{n+1}}{u_n}&#x3D;\alpha,则\sum_{n&#x3D;1}^\infty&#x3D;u_n\\alpha&gt;1发散\<br>\alpha&lt;1收敛\\alpha&#x3D;1不一定<br>$$</p></li><li><p>根值法<br>$$<br>若\lim_{n\to\infty}\sqrt[n]{u^n}&#x3D;\alpha,则\sum_{n&#x3D;1}^\infty&#x3D;u_n\\alpha&gt;1发散\<br>\alpha&lt;1收敛\\alpha&#x3D;1不一定<br>$$<br>使用场景（比值根值）：<br>$$<br>a^n（根值）,n!（比值）,n^n（根值）<br>$$</p></li><li><p>积分判别法<br>$$<br>设f(x)是[1,\infty)上单调减，非负的连续函数，且a_n&#x3D;f(n)，则\sum_{n&#x3D;1}^\infty a_n与\int_1^{+\infty}f(x)dx同敛散<br>$$<br>使用场景:<br>$$<br>\sum_{n&#x3D;1}^\infty \frac{1}{n^p},\sum_{n&#x3D;2}^\infty\frac{1}{n\ln^pn}<br>$$</p></li></ol><p>遇到正项级数的思维路线：先看是否适用积分判别法的使用场景，再看比值根值法的使用场景，最后考虑比较法</p><h3 id="1-3-交错级数"><a href="#1-3-交错级数" class="headerlink" title="1.3 交错级数"></a>1.3 交错级数</h3><p>莱布尼茨准则<br>$$<br>u_n单调减,\lim_{n\to\infty}u_n&#x3D;0则\sum_{n&#x3D;1}^\infty(-1)^{n-1}u_n收敛<br>$$</p><h3 id="1-4-任意性级数"><a href="#1-4-任意性级数" class="headerlink" title="1.4 任意性级数"></a>1.4 任意性级数</h3><ul><li><p>绝对收敛 数列的绝对值收敛，则数列一定收敛，<u>一般情况下绝对值级数发散不能推原级数发散，但是如果用比值法或者根值法推出来绝对值级数发散，那么可以直接视为原级数发散</u></p></li><li><p>条件收敛 数列收敛，数列的绝对值发散</p></li><li><p>绝对收敛+-条件收敛&#x3D;条件收敛</p><p>绝对收敛+-绝对收敛&#x3D;绝对收敛</p><p>条件收敛+-条件收敛&#x3D;绝对收敛或条件收敛</p></li></ul><h3 id="1-5-常用解题方法论"><a href="#1-5-常用解题方法论" class="headerlink" title="1.5 常用解题方法论"></a>1.5 常用解题方法论</h3><ul><li><p>$$<br>遇到\lim u_n·f(n)&#x3D;a，让求u_n的敛散性，转化为\lim\frac{u_n}{f(x)}的形式，则u_n和f(n)同敛散<br>$$</p></li><li><p>$$<br>\sum_{n&#x3D;1}^\infty |u_n|收敛则\sum_{n&#x3D;1}^\infty u_n^2收敛<br>$$</p></li></ul><h2 id="2-幂级数"><a href="#2-幂级数" class="headerlink" title="2 幂级数"></a>2 幂级数</h2><h3 id="2-1-收敛半径，收敛区间，收敛域"><a href="#2-1-收敛半径，收敛区间，收敛域" class="headerlink" title="2.1 收敛半径，收敛区间，收敛域"></a>2.1 收敛半径，收敛区间，收敛域</h3><ul><li><p><strong>阿贝尔定理</strong><br>$$<br>\sum_{n&#x3D;0}^\infty a_nx^n在点x&#x3D;x_0处条件收敛，则x_0为幂级数收敛区间的一个端点<br>$$</p></li><li><p>$$<br>\lim_{n\to\infty}|\frac{a_{n+1}}{a_n}|&#x3D;ρ,R&#x3D;\frac{1}{ρ}\\lim_{n\to\infty}\sqrt[n]{|a_n|}&#x3D;ρ,R&#x3D;\frac{1}{ρ}\对于只有偶次项或者奇次项的幂级数求收敛半径时R&#x3D;\sqrt{\frac{1}{ρ}}<br>$$</p></li></ul><h3 id="2-2-幂级数的性质"><a href="#2-2-幂级数的性质" class="headerlink" title="2.2 幂级数的性质"></a>2.2 幂级数的性质</h3><ul><li><p>有理运算性质<br>$$<br>\sum_{n&#x3D;0}^\infty a_nx^n·\sum_{n&#x3D;0}^\infty b_nx^n&#x3D;\sum_{n&#x3D;0}^\infty c_nx^n\c_n&#x3D;a_0b_n+a_1b_{n-1}+a_2b_{n-2}+….+a_nb_0<br>$$</p></li><li><p>分析性质</p><p>和函数连续，可导，可积，收敛半径不变</p></li></ul><h3 id="2-3-函数的幂级数展开"><a href="#2-3-函数的幂级数展开" class="headerlink" title="2.3 函数的幂级数展开"></a>2.3 函数的幂级数展开</h3><ul><li>一般用间接法：把f(x)求导，导函数化为幂级数，再把幂级数积分，转化的过程中有可能出现项数丢失的现象，记得补上</li><li><strong>求高阶导数（n阶导数</strong>），用幂级数展开构建a_n与f^n(x)的等式关系</li></ul><h3 id="2-4-级数求和（重难点）"><a href="#2-4-级数求和（重难点）" class="headerlink" title="2.4 级数求和（重难点）"></a>2.4 级数求和（重难点）</h3><p>思路与函数的幂级数展开相反</p><ul><li><p><strong>常用级数</strong><br>$$<br>\sum_{n&#x3D;0}^\infty \frac{x^n}{n}&#x3D;-\ln(1-x)\<br>\sum_{n&#x3D;0}^\infty \frac{(-1)^{n-1}x^{2n-1}}{2n-1}&#x3D; \arctan x<br>$$</p></li><li><p><strong>求常数项级数的和</strong>：把常数项级数求和转换成幂级数求和在特定x值上的值</p></li><li><p><strong>注意</strong> 在求和的过程中，如果级数并不是从第一项开始的，那么就要减去缺失的那两项，比如原式从第二项开始，再转化为和函数之后还要减去第零项和第一项的值</p></li><li><p><strong>注意</strong> 对和函数S(x)求导时，每求一次导，级数的起始值加1<br>$$<br>S(x)&#x3D;\sum_{n&#x3D;0}^\infty a_nx^n\\dot{S(x)}&#x3D;\sum_{n&#x3D;1}^\infty na_nx^{n-1}<br>$$</p></li><li><p>通过求导，来构建关于S(x)的微分方程，进而求S(x)</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;u&gt;整理自武忠祥强化课内容&lt;/u&gt;&lt;/p&gt;
&lt;h1 id=&quot;第一章-函数，极限，连续&quot;&gt;&lt;a href=&quot;#第一章-函数，极限，连续&quot; class=&quot;headerlink&quot; title=&quot;第一章 函数，极限，连续&quot;&gt;&lt;/a&gt;第一章 函数，极限，连续&lt;/h1&gt;&lt;h2 id=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>值得纪念的一天</title>
    <link href="http://xxsy613.github.io/2022/11/02/%E5%80%BC%E5%BE%97%E7%BA%AA%E5%BF%B5%E7%9A%84%E4%B8%80%E5%A4%A9/"/>
    <id>http://xxsy613.github.io/2022/11/02/%E5%80%BC%E5%BE%97%E7%BA%AA%E5%BF%B5%E7%9A%84%E4%B8%80%E5%A4%A9/</id>
    <published>2022-11-01T16:40:23.000Z</published>
    <updated>2022-11-01T16:52:20.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="令人感叹"><a href="#令人感叹" class="headerlink" title="令人感叹"></a>令人感叹</h1><p>今天是值得纪念的一天，我慢慢回忆吧</p><p>之前因为自己的拖延症完全放弃了许老师那边的项目，实在是很羞愧，但好在情绪来得快去得也快，没有了项目的重压我也变得轻松了许多。但今天晚上接到了我爸打来的电话，质问我为什么退出许老师的课题组，我才想起来这件事情的严重性，他跟我谈了很久。</p><p>之前在和我妈的一次电话中，她偶然提到考研方向，一瞬间重新点燃了我高考想考法医的梦想，我爸针对这点跟我聊了很久，细数了相比法医，计算机的优势，就业范围宽，上升空间大，薪资高，可以蹭关系等等，以及，质问我学了三年计算机尚且不如别人，凭什么觉得仅靠一年的时间就可以超过医科大学四年以来的努力，确实，我说法医是我的梦想，其实百分之九十九都因为向往非自然死亡里石原里美那种法医生涯，现实中比我想的要残酷太多，说法医是我的梦想实在侮辱了法医这两个字，唉。</p><p>然后跟我谈了许老师那边的机会有多么重要，希望我能把握住，我爸真的很懂人心，我的一点小心思被他看的底朝天，我破防了，几年都没有哭的如此伤心过，我觉得我对不起我的家人老师学长，白嫖了他们的成就…..</p><p>我爸安慰了我，唉，从来没有觉得他这么温柔过，他说了一句话让我好好记住“在任何时刻一个好的心态永远比你取得的成绩更重要”，是的，失败了可以再来，放弃了等同就是认可自己的失败，从此将一蹶不振，好鸡汤，但是很契合我现在的处境，总之先记下来吧。</p><p>还有一件事，我分手了</p><p>很难想象在短短四个小时我经历了这么多事情，我爸在聊天的途中质问我你既然不愿意跟女朋友结婚为什么还要跟她谈恋爱，我想，确实，要不今天就把事情说破吧。</p><p>于是从不想跟她结婚说起，一直掰扯了俩个小时，中间她一直在怀疑我是不是不喜欢她了，我含糊其次，虽然嘴上说想分手，但是真到了分手关头又舍不得。</p><p>但是随着掰扯的越来越久，我想既然今天已经说到这份上了，索性一鼓作气，就这样分手吧，反复的吸气呼气，我知道我即将说出一个可以改变很多事情的一句话，我反复下定决心，直球的说出了分手吧三个字，一旦说出来就停不下来了，连说了四五遍，害，我可真是畜生，我确实不那么喜欢她了，谈久了，感情淡了，再正常不过，令我意外，令我难受的是，她还依旧喜欢着我，或者说爱着我，爱这个字分量太重，我打字的手都有点承受不住的颤抖，我配不上她的爱，这么说起来很矫情，但是我觉得我配不上，哈，不止我觉得，我妈都时常问我那小姑娘是看上了我哪点，我也很纳闷。</p><p>衷心的希望她能遇到更好的，衷心的希望。</p><p>现在她肯定在哭吧，哭的很大声，也许在找她的朋友们哭诉，她的朋友们一边安慰一边骂我，多骂点，我确实不是个东西。</p><p>————纪念517天的感情结束</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;令人感叹&quot;&gt;&lt;a href=&quot;#令人感叹&quot; class=&quot;headerlink&quot; title=&quot;令人感叹&quot;&gt;&lt;/a&gt;令人感叹&lt;/h1&gt;&lt;p&gt;今天是值得纪念的一天，我慢慢回忆吧&lt;/p&gt;
&lt;p&gt;之前因为自己的拖延症完全放弃了许老师那边的项目，实在是很羞愧，但好在情绪来</summary>
      
    
    
    
    
    <category term="随笔" scheme="http://xxsy613.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>日记02</title>
    <link href="http://xxsy613.github.io/2022/10/07/%E6%97%A5%E8%AE%B002/"/>
    <id>http://xxsy613.github.io/2022/10/07/%E6%97%A5%E8%AE%B002/</id>
    <published>2022-10-07T15:23:23.000Z</published>
    <updated>2022-10-17T16:25:13.743Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="b319e6756f6da244b2214cf9084b39865b0989c7b0e58ad26f643c0c8edf4e73">4c933d62af66d405b3fd675908595b7bc5dd9624dd774d1c3d2c9ab13af7c77fcb58240f590c50efa1c39712dc7eca978a0981e7f4d95a1f7840be2f91ee2d7b8acfd32036c3843f4021bc99ea74796847a4b9adc3982123027f66c58618d71cfb4dea77e284325212746274db2b7b12bb8ec481393aacdf12c02ea21ba2e0a500ef4dec554fa7dc31495684041367402f965f8035a1b389c4b8515d2b6d9c28c5beaf2a3dd0229f3d3c4e29610761fbec6badb14091a5351a5a66953606eee8fc031d3042abb2718b4f74c676dadc921c4e4a86c4e57e80e7c36222424a42abc6a42a366f41a294f1852bddd3ada68a16ffc1fca5f34a0e4157c69f7d745b298c30d642b86a2822d62d03de9f923ea34bb48789272d0481acacc292861ddae533223a38c19a5d610f2f48814a9855cb77d2fae479f89c425d0cfa54eabc18f8f0f26fb6c9593c475e921cd8e64225431a6d587c821e6de2a8fa3fdb43c643d685f6407f16ec36e4a661abb26a18a59633bd1de628be6b7e618f7bd070153b72a1a2368526a2458353058e9a72e2b398db984fa77e8a4fe7b38bd6e221f66499e2d482b6b362fb1e92a11ce72523e26aea61d2098d9305b5b9d1bbac24492fdba3fae1d4cf51eb14312be2fbcebbc20591580c64a1c67bb37e66abdfdb0afda15f636bc6efef679cb8c3d68cd0eb1f15830de86121fbe38164cd11942691afb3f6717aa74e0e55c7f921efa01751f9aef7324fac826ebb3ec185edbfc36842fd492da65d9de236975c79e7fb9fac36731460463569a79b0535d774b699e06a5c94612e1f3d527b97ccb15ff80a2ae2cb5300bdfe10e1227603a9153b263689f91e8a5ada0bf41b1af171bcf2e6012263d7c37c56038b82e02e9ebf00fdd34a0182e9bdf1dd72a25576f015cd86babd7a5fa8a2c2e053b29b795e62442fadc301145d00a30faf20b778151792cbb14a9a6ae9f43f71dc608ada442f0e9b7689938a8dcc01cf563163fcfe87dd9a8c5245251de7175d4acb19bc6ebf602e154bfacf1b12253908c19fa9aeb3ad60fe8e4d53b9046c7fedb9107e29bd9f433c0e3f99e810c4814046a2b22b785ae913b56e2f7568d7f9af9bdcf1a2f3baf2ee86a2addbd195b7eb7310b2d685fd69d9cdb832087e7f6a55f389a3857fb20d69836290bcd04cebf67b090cf6adf59d71f48fd94a70aae6d3387d110239f2567322e3e7fd4dd38dc8651e8ac91667c21ec133a0b17ebe07fe0a6a17746a6b249b12254f724ad812a513a871878c26ea3b8a8c14e90d6806cb00ee826f1e2876a32b21637eea1ed6df35217ba90ea4f849020195900cf4e1553ca51cabdd51a3d919b48ec7fce03977ba48c82ee6f9e870b1a501f1667b004cc6dc94045baafc139a05aa13e39ee111e15b7cdc10c996692cae844d5c596aea76bad8d00bf9528317e02a9c7ea9387c5f5e2b728289af49e4f02e7b30c77f4fcc9718569e8bebd8e4fb74134391a5bbf0f1f81032d710d180e855bf484a9658a9226faf91b260eb7ad02d74955187b31b95e59892ab1f698a5701461f9a2f337fa35cd6c3d73d9c144481478a17c2338fcce9f3cdc3ab7b4af623989e90ad73dd93b2804c8182b54904761dd10fa72786075d1df22645fa1f3843dfc9483bcd150ed55908edb4cbf1ef1cdb61af063dc484300ae064d818aa8e40b531fc5450a997eb2fa0f2f05c971d554ef25cd0559416a206cc81fae738aa29201e925b7552f1f71b274943f0577c77e1c251bab5c313f222a2290ef7a8063ee90bfa6ac1fb02d6158842c3156074aeef94b31fa022fe71b00ca5f9b56abb7ef029b2d6dc41480d95f54ef1e1b2050c84c43389131f6b81c8344bafd1c9d952a61b3fc220765743a09ab08510f113b2d3c8f8ca306405cdc84bb12b84a6b9d1808f1d2dd4f2f4bb677d7d16dfbd3a1805a3015bbf719b91cd07d7aee03cfa08969d07ef34545691abfb1015cc6cc5eea5ad070710aafe389f97b174e5e5afd7274db3b1d8b49040696ca4ea52985d3fc5440481ce4767a8fb77257ef6449c7a972486687efa9e3f75c2750b1a9be912355b57f74951b2028f05571005c72ef977b4a9f8f4708025dd31810812364294e75509002c63492947f08d9fbafa0e65c75b01a0eb489582d6f1a86113a875ad56ccc5eb594ffb27c0efa46aaf8ad8c950f4b04974fad7534723bdbef573ca2388b33c166b16bc0e86a58e53ce3eef83cef02b7d60f3cbf2f63fbb86ba70d1f1e5983cb82d56670bfee47e921148826c0f26f3c7fd30b759e9946abed15b1bd879a78d0bc626097c5428e7cafaec5a3378f35cc4491f8fabf23ef63d0f5b12bf091528692fa904b97bb4ca1418a37af61db214b75b3955bec8ff61036285e19846a5021bfe388e561bd4afa1ee5778bd3b6307dc1bc212d477d290bd99d14b878f687c84ee6b48550c56cc1c3b076051eb0c8c0f725b742055f00368f8bc15189f546c6d00627112f383cd11e1b735047011726e6310e88ee461f6050d3350cc0ee56a1fd0f6fd19d9a422794519f280dfb073ddb6c058ab718825de0c5522f88e0834a04d4a38a235e5dd1382f4a1c78113f6c29e5e0d5ee80eecf14a7f1e90dcbc084c8ffbcda33da5e026e26f2d23182cf933eb16a1859426135e74bebe776a2de64a0a879e14e95406ee9918f07330c196329e83796d318c00ce31d34bc3aaf5518f9a14bfc23aca18d5c3f0734326ddf6c60f12c038bba66572169f250f7cd8965fbcf9e8d45c6721fcc76391dee8603a455188b5b626da568567300cd017e8206d31861fa7d9a0836d0e61e294e32e85939bc5d7e1b3af5c6d6c56c20242736e641f3d7ac5dc96d745df560b3a69b5ba7cafc52cc44159695983a8660ed1a8864754fa27fa493b09f93f92ab86a1770ee9936c444694c91718e4161baf78c1b8d0c86bc2f1b80ddc65a709e1ff83f8df6744eedc430087ab53a021d3aab33f4c0818549bbfe231ec738e1a5bffe14203c679093a0e6a52e44a58a167fcf75852b0198a91c02ed8144317b5fbc37aac5b606c41be50e53a1ad4b6e56808dbf72243d5a1ebbe6e21890e59f430f7f5e4e87d951617eaff1c42fff14c746d2ad5a447eb53c6dcd1a84a093445d40c7d0e6562a0b886ad2991ac05bec9472e1760913255dac855b985003bb0b485ef0dbf887bb7ad22f2568af1f4baa966e20aac7a914f9c36232e9be7fba2e7578e34ca745806c8aaa9ee62be3ad2db9f5ebdf800bc0a1c543aaad126f6225b4931ac3dcb38c8ead6d862f3065a86dd2ad57c95670d2a5be66537b488438efc5b1d3c9cb2dbb1be6e78f82d3c39c8d39f02200f976181c3d58f420d22ef1a001c89a1e67c6e58b824cf6c4ee37057c2d3add33cdb244e62453f4730bda48486c5e2c510dfb7030182592caa431720b6f49a46cf3c323c144456f1f7e9a48ec91c3fe7bb63c3685f01c1a190790bb160aa30050b3eceb4517c942661c9565f711f7c1997c35829a0a6e42c318b5ab986ec5784e438202e18926dcfea9580b3805152353b0a63d6dc2514fa17518ccfbf073714fc156ddcaf94216bf736090a97db2c5cf6a8f9c0d6d10d96982708332f8658f45b91577a270c8e1a79bcc601add0d4396989c7c968ef986631b777fa795889b0af06434406f25b491d3010f07f9d0567648e2a5a93efa1ccbcff55650a90a04547671869ee0e07094b3f3b035f517032aa1025d1c85e41367135dc40a5c8cf5fc8fb5cf00e7ed3144e4251fd79f580299bc81b74e42c1755b413d753dfd690f3515f32cb4f1ebc04925b7768d77af03e4ee1b2d67c85c7f141a0aec2746ca2c586262473ed588da5e79efcef0abb37438c7750fe8423c0839368c693327026f20fd952741fc3ac569b38ea9e9d9d87a6f4f073c8052056edca5b6a6a826ed1088f197055aaf04f2c75624236a5acbf801ba7be174dc71f03abe4164e3c0eadb4e556c241caf5e4e797edb607e2edb401b841c47e47c030daa955e6514c09d14ac4fccfce6e9e496bd861b527d0ad1d1b50f3dfc585ae520c1a038bed2b1b1e5b7162878a5075f017588d02bd732ebd05dfc3585341872871be83a40e27d368cb3da296ee52f5428270e1386936b1acc07d7ac6c7c3158f5364ec7a66e29162436d2f9607d47ee1d2ce454cbf93dc4f2218fe0655185aea29787a67917cd0e82774f789e7b2e54a5f25dbd33e2bcad72dcd114af3721990bf44cc05d3963cba46375f734645a8173f11d56a4b34f28cba76e48bf182af9b53721d9be5da2a12940c47f239a204abc8a9e076a8d8f622426887fbc5e08fb4739cd24efb4aa44e61dce188f0df2ad55532ce0b932bdc2a31b6f8385331ba67eae3c986b13a91eafdf2b6dd9d80bca2edef475e3b50f05b3cc20f133a406ec13620451880c3b916dbae80f28a51eaa0e0f12508a5997f9dc7f82b3b8832bb31dbdcd502906efe57f7bed1c106d15c88478a815d0eca19205b2408ec818b2b77acb5f79781266514cf6006bcede3ab8286ae7a9c92c47b1d45cc5c6c41447dd476ef7c87951dd49112453a040378ba2cfcb49bf63effa64b8233513d15fe886ecf05ea5c77107139f4bbd09cfa524bd0880c9702ab06e80595c4b580827fa858a953ba3087b9bcc533d59b6e360b1f93acb2dd26e6c5dada953df88f4894369a72de012aaf55542f235ee5cb98f86c1f0fa93beb325f0bd57f3538bc69356b3882d06475528f5f95a7d2fa1f3972b2031cab798581dcb8e969013cb4e6337d4c85fd94cbdb4fb7546266b46d58ee8b5e89d70ca1e52db9787c23180a61c33eb73fc56df5ac3425265c8632e7b6957bfb691b0459c7c91fe3189d962253096e6e4f9fae5fd58d3e101c5dbb4272b508331cb930f6edc0e3a382aaec11147834920d3e7a9cfd7d312e22bced6efb1b13d843503a9f8b41ddf661f02252b551eb06d767988af6ead9df8642d552680cad0a2f990da24610872fafc33d4844f3fb7b8d555d33e226cd76e0844526c906b19b03d433b541c610c3accf25629a1c975056ad43b778543b885bfdae934f1e17a6d163456da2e47ea2c64903fefb739141be84f4a060a1873118aa7d1ba156a74a68c53d31d9812312fdf00fb4cc30476027761860c88656187a27ac7d9982044a033b07edab3e88ee52ddf10a6d48bf05d77223d2dfaa82dc566e3ce6dc5012e20700c08816824cc6a23558e0297685bce3840ba01df6756c1a01bc21ce77a291fa50f3671b91efb15d4d2b66933ce4f64a1d0277833d71b7b488dc9ec2c5665889b570b17fb3ad942ffd73849ba44573558216627d80585859fb0434643c690fb474ce9938a0a79e9816a721af5423de5d30476f77bed1cecb58e1e39329c52e4809792754f6188d44416f4f41c6fd9e1b201634043cee0ded66334d61f8f1e342c384a1758062d7a92babf714b6232f6fb8c273d7540fcbdfc3cb8a14e43cef265336192be33e87ac93329dde333207e8514bf33b88961ce718f64dc6a2eb46532a46a03fed5db402153fe375682eec282899fffb612a9ef36201ee35441cc4b57c018cc88cc2a51c0860b30b356b3c67444acc451028db414e2030aad4e97e36a5657e260c18e0d1b850346569456a9379fc62b94d0526833ed3950bd054838101f7e0ae98bf2e3f50d558f864522aa9827df9ba3f0d664a6629682f8c1175f58bac785ca0fd3c3fb915510686fcf891421b977ebc1c2fc76438a5e9f40d046dcb253346afff224359f4688784688c57437da72ec0b048bacc689c92b59304fd77d9f4d91fa1768ad6bedc5e997ebf7c788c2394242d1fdc4024f83b835749559a6073d107ffc940ad7f2789c882a6a159b7cdea37bdd4eca8fb3f6211dea4d4b023d75d17562561b300bd56a6cd461ee600409db0cfc9778d457bc91871bd676f4a408c3eafee7ff5f7686ed809d34d49b226cefe770e32aa0c0a7bfa6891314d76786568ea67d31384ed0f6e6338247d341dc0af2972d4ae15568f87c0742f33f07e7b64d753f4856e5834a382e1f4eaea242fbb9338047b9dab7722b0f68f8ad865057495690a13ed3ec6eb737d7706f333c66103623580d58a2f858b72fa699ef19f7b3dd760de07a23118a0b26f0099a225244a71241037d0d0958973536b0ebe94596a4d6a8589b789e9f57752aafe744f66dce46559dd80b8c3b5e9188a188547e0786d9ab1e84e839fd28a15df99efad9e23835acf5d1a5ca1ffa258d653fa6c9c3f63566d28296b1189ad1611458a3df1eea7dec90513de6e8e61f27b941c9eb3d3da36affd56b2ad26481af97129a6547200759da58f3452908f64f4392354ca30ba896322f114f571b3b034421b3757f2991fc2ec1ce5ae4f4600369f9e7f727b302714bd24592d3208856ef9b4075b241417497ec671abd59a1f6e5300334b1617f97644bf2dac2a6af981ac52ad1bdca593f34a6822aa82c56958d175dc1d27e3fdcb6d3216a678220e3dd8dba06e818201c97f3a7ab8df9e466b516304463f2cd5f19692a0e7dc75dc156ca971327bf0bfc7e5682106cff01614cca15594c9acf8acd8b77b3dc46a0ceba6e59584729d3eb82eb1d36ff9beddf9d65d3e150470b6c0403c44123bd2ba1882545d76ed5e4f9cd1f63426c4799bf378942e6b49ecdbb651ce136a75de914384e27bc893cd8530e25b1fed0faee78013342d84a30bcf5eb665bf7392a274309bab1e8b482298b70bd33b723ae27d179c05acaaaa921ff4b8125d4e7d4b3861f7d9c5f0f14673a559c5a390b61099afdf3bfb117b2016c2ef04def769c0d5c511e13098cb383ab7b42d8c1b2aa6326e33574eb1075f3fd542a28a02e52c92a0df22749c37c4ab01b8c519e0950ce735c017f7d22b3ac5b45acc8be8fcf977f4cc545093aec71850998a8ced70a3f88ec96f8617fb3ec30c0323aa1f24a4d930fb73681a12c24ab6cc818ad7c987d0e74296c2adbcc44e08a5e741d391b11a53d40dd1c171e956f7a76824bdfaacb7546035812ca8dd378924054a381ed8d9e575581cfd679329b85f637d4a24a181590e63c95fb511440aad3394905d8b4de2eb548aafa8ad0380a5bae5df4c04c9bca3f9eff23120c533acde12e5c51423100b9be361bf960a9e0128cbca7aa2692b379916caa820f1e483645a54db708d8ab404fc4ac46f316fd8fa5750cdf495de412757cf9c49522c9f841e3343c84e040b1cba2729a952ba42ed0fa560d85a827cfaa8d8098d8b57f62c4909874411b3d90d38a2642cf165814f32a626812c3818a2c76f8e453d1772f776ce0e3150ff81f64e2826</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">密码plz</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    
    <category term="随笔" scheme="http://xxsy613.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>日记01</title>
    <link href="http://xxsy613.github.io/2022/09/26/%E6%97%A5%E8%AE%B001/"/>
    <id>http://xxsy613.github.io/2022/09/26/%E6%97%A5%E8%AE%B001/</id>
    <published>2022-09-26T06:55:56.000Z</published>
    <updated>2022-10-06T16:22:59.182Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="0f462b3ba895ad9c4e125105e5d679373173a535625a15cdaae4bcd45c42ef76">4c933d62af66d405b3fd675908595b7bc5dd9624dd774d1c3d2c9ab13af7c77fa457380e19869b4d7a9f040d348d82d971a509f28f54cc162a3d6e8b39e5571c5ce7b2a25e27b9648fa71135eb2324e5c4680c13352fb372f4314f875307055a816c1aa46e9bec80b7bfc5a2243c46b563fcd59aa3b7d1f2c478701917049133f245ea24822e0c5e496b25d60045ff011a75cb3ab9b009ab15def61d4eb7b706b9a1cb950a6c7f9c928f57109a5f886f931f3b375d320bcc1edec7d17cf8a5946182519563c1e143ff3e3b9283e87079e36996171f9e8352e98c7f62422682fffe433f2f06dfa4121daa78d036bc05c64842f006e65e1fe5db975df2d846684c2c28309f8ff84431809faab12068b7944a54427df97e90bfc675f919477f1be57a18580ecdecd50d4dc0f6e6e9d74d04421be78378c54b6b679d6b1287c7223065351511c3a8056d4ec7b2b7ca478abb307a2d0d4de62946fb93644ec41695aee0f7c1edd395b5354bdfb8535e24589a77aeaab422cd6263136c79349e9c4982ac4c1005a6e2a3e60aca14e2544cc23110c296c2fb3c6e53a5988e27a199a2afd3b98a492fa58be9721821236807ee368d924eacade6665cf3c419458aa1a95f3fdf41be3aa5e3faf98f2c36d8e7e92c3541d52a84abc6454f287941789a523b4cca58c5a529d08da46a0d139031a17ac8a81c5bd791eb5c32a0734acbcd65b78f015ed0d62324e7e19afdd5ab31c16e60ecb8ed2dabdcb6389aee7d93992a90f7372af2ce42506a6199be75cd196a9d3c1bf6a4ce288381ccb4aed648149fec6c0c147ab192b1bca67c6fd5c4fc5623e2368c8cec68bc1bf049ff5e44d1a0bd252f6c3c1c34e3d931d1749441d11eb03b7da00fa84fb4730d962d17cf69144e923f68d8931763e8e81b343b94461c4d3dc8fe3325a01c0f72f40ada3792f60e68de8554453cad613e97d005965a6777a2f4cc6eb3f5501db43c8676707575c42da6c73d83c17833c985272d8576a4e5415c1a296d0bbb4bc824c20ca8286cf77d7e0edd8fd27fa2c45717bad8cf5cef400cf6af9492504a950d4bf6598ef7e7a42490beafff90f566d0c94ae6e36fdb82c5e283eee8757f8ca32d6d221d55ec82507accfd0c4b72f6cce99c9942f72ad07eee74391272fdacde666a620ed76565cdb3220c59e361ad8e5ece0645b84ccf83b1e25f2fe40f3fe1db7c44ae5ef64528ee1317bdeebbe17b158557d964cf8169b7cebf4e767b47229e7a0cd199e335ef2a68a0f5ad1a7c382fd6284babd5ee30855a82d8eb385cde9c8722696f8e868bc4d18510a3510a3fd848c8292861845887683a665899680ebbfc127f46f93d3ceea98ee5f0778f3f45e2a6496b221a0d5b996d96c4b825e1a80758d33c9f663d244004db0bf7736cf5534ad8fb648b44ff91a2ccf14d57851887ef11c0996022ee3c1d123da26e9d4c438f3ae6f572e811c1864b90769cffc80a701c6ad973b4c50a087c9f59382d65ceaca368e9e94bd6d4124143e437ee00cf7000d1f9dec136e3020d70b4a12df796d1c31217fff0dac96be292ec419b49cebff2aec3e1fafb164b9644320bafb5a90b992287b36188f98142faec2863d1a1600d6fb2d34bef37c48b58f0d9784d84ac2371fb0589be591bee06911748e7bfbc00c81075c1b7eef9b2a1fd44ffc17b2e2e3c71ee9c635883f308ebebf383cc171821026055e15553d1418c50e100bc613f9ab2a62a74e05beb6af526051187dd000630e811cc52841867f7906ae59d5293e06bd1d1ee3eb0066ffced50105b6c8ee5a1227b1a0dd705aa896f392e872d8c02f1ecbad2faffbe7af0d46df730691f91c34aeb972a1d436a7dd34c71e1f651eca0dc95939dd09b612cdeed8f3fe5334ef81bce7ed235ffff0c4fce44f22c6a22ac703440b62ff9acfc5b69506cf22d2b933e722aa66c7bd6f4b9902b91723331007aa23ebe663e57c736bddff8d3d2a64896b52a7d519ca0ede701351f48f17ae081fe28d82b4f105ddafa26d5a0ad53a2a388cdd5b9374a8c2b1b5c17739c6f65d22d856014d699312be72236cc506f222faea1195d6dc7a42ac0ef2dfd1884dfa87f441c7786711f4938b54bef679bd853237a1ec65fcb292261772275196fb7578cb0bdac1172fb719f9d916ca38d5e740ff0009f45b3ebe51774bca6ebc2b521e7016d45ca854185abd2dd2b0743a3a834804373141f204992f62f3dcf24e1d8cbccbf2292143195430504f9108b37f59d6aa3c641dd1d94c249741d21d1b9c1ea98b06abba314188f3689a7cce6fdf52729fdcfefa606833efa5424c0f0fabfb223f651229e7e9415774388769424d9f677139e87e6ba953beff9fcbbe91397ae63c278bdba0866b50cef6c9d5ddf80909d7deb23e76da86a92f2da0eed0845d02417d6838228cbfdda34e9048b07d645d2fd69210c686f00048a76f9029e84dade8955237a1b1353d955429bc096b0215c7526cae507bfdb3ba73b8e9b665dd4ac55436f164cf7b30f2b3aaa0cf6badf92777dffb3b6b422bba67c241e0651665fa7f37ef47d8e629077fc3ed3c53c7474b0f1c542f6eea8e2993dbbc6110842bd4211f8e945269dab30abbfc0e672a77832997f165e44129ebc11acc6cfcf039061591c0f831aacfb358106bf6f2301c3de8847d8c7d89677335dfabb61e55be1b52c1a0317d88c9a7718e459dced1600769fc7a6d204602a6feb57b4ac1b412dbd211aab4a5b2aa2c8c026376a2f27307d948a0256a4aa61656232bcb6d450602761e9b3f66500210d80a1afebfa2da36c87ef88f5e46e9a3c0a6dd97bcf19854b69a500167e14dc84583e00749b9cecd5cf9e24876ca089bc1701219937ec21addcc7376980b60c320a7802da4e45df12dbb4f99fc5acfb641e9f70254821bff37706d6e55e2fec877317e390b436a20295bab48fe6d419c249e0ae8c6c20930c891840f2759a8348c3a781df605b9f37f95cd3bb51104acb579fdb5a0760ac8d283583f571b948f47cec4e159c0b754a0c3ed0f14610170e7a404892bf43e8789bdc752aab0b33be4693d1a9099deae9fea52e9d430229a8eb5e0ffeddb9fbe9ac818445b75257bab7e4708a3f65524dab17367e1b0d78f2c66da3d06ddbf588198dda209292842c9f248ec23b3e4e22dc279456937b6abfe3a9e7c12f724b417c3a339e7fbf7c7ea13954bbffeec73b8a0e66ba552be0c150c9fa35249172e5468de99767c4675bfa1ff4d9660690ba8adf20ede3869a690a8b17630d0cf2bd7079ba6f0e2b832be1e061b393c1033a78143a0a50abab44324d082a833193022789c25af73becf31cd639c96787e1241f9be5826118bff0fa7cfc90c2bfd1ddb441d72875755d18bb421bfcdbc5624d3ced4200ecad5eee430d65b6c972a39c113de6a4030bc0faa7d59c2c4799c5a3ecbec8524426effffa1ed1ec0ff50c96553ec00d21cd33acd66dd7417f20b427ef46b41c68fd898c7ad1a11081bfddeaa0fc0efbb6b1d3f11dc18face71562dbb3043a679712795bc10fc34eee8e892da4fd2f188a9708d494c065ece00473187760f8187bdd119377fce10bc0bbc87138c63fb91dd81117836bda262b49b371e804e2de8a431254ffba923259e779ed656b9c2a7b5cfc7dfcb74d265f5e0a2b6988da1e0f1b4745cbe15b7790d49b9f57c5e37734d6628118566f57e338a10889a37b13819dcf376f5a07031ff9504e50910cc2dd379ef3a1b5b25705b8b77df1303e5edb8b8d2b4c3ec736a5634b037cc027b56b5c80a9ae65fe5e53b90ffd2e412da26df891544b20b011e6acfb1753dabb2df64bd2f27d87482751968b5482d59a97e03ce2558bf3103094f43720a030df80e37b296e2e8f0c8c06aa8be5d85454b8adc92afba6aff99fb14580b8fef354378255736b90ef2aac80317bd8d8388d0cdd70175a04b33d8b48ee29fe046f39540306ff4ed146a06899743807283a9d06cb89095a8cace6c5afc1d62ce3cbf45036b6cc75e997fdf56d0f07a1437b9abd068907f9cc434b1f2494ed54e6d8c602e58acdd995b87d89e97a2b88b03c0820516aecb46cf3ab0ca892701441aedc5f552b5d3017eea6aaf5a123e3703042c1f37b8d1f5706a7914c6148f7c0ee5d92f92f55f6ea4283380cf1694f8cf8ea1c66b8c6a914f688ece33c24288759c3c9d3b8896fe8c4651f8e7dbef9ec3e54cff88f58a3a90c0e58961585e2ea1c246c24e7127fd3af1e2132ceaff46d572fb0feffea371a78407736d7f79a74b3757470bd8c3cd6859da9dc14f0e250db507217580fabe434a37c6514d7a35fbe811b4c1f76893c913b09ffc4b441e49dc1d4fd37fc1f182cdd6b5e4b263d6dca567d7fca0ecb2915e15a80fc390a337c71892e8b2dd98920b37cd8545910e4f2898f5ceb8466567c5a2691b495d0db680c66bb382d2d4548e11e60ad27eb6c16ca70ca3e0c82c8dc42a9bbf5cf53e1f1504ad0412a6d2a00ffe689f0164d027ed068a8a1459a455d3ff95384fd9c1c1ede782659552f7250b35559506a9c9892dfaf9afe7c5b0e05b5a8ab595e20127a6612cc3692fa46731609833f146f77588db3f3afc4f86327f3f21a6fa0bbce026b5a9f2cedf6cafdafa618587fcbd140da76424bfe1a5c5903193315ad071383a1b97f24919f7d54d6bf1014039bb30614a85ac5a65e531dbf41204223524a903b1033b7e7759d243d5f72a291dc51bcccd630f9793790c0cfcaf0450e14c3dc821ec774c2038aab50274ca85111bea0e37e7406e2586ebfc3f56cb163ff378ec4de68aa3d4afb71ae1a616e8a76ef07a08fe10cbd31f76d3b5e5776410a87ab04c6f0c034b2b0ea65b45a6fe4a4e35823a94c9e5cd9ca45e52530b3caf41fa1b1622eded9dcb3e8c54ff203abd4e4eeb8f3b785457b0fc027dca2b5a1cdfe00259ebbdf233bc5057045f2bc42716cf4372c2835e471fb502576b046aceaf2326b8632e530b7fbbf36c98299c15d4b038c07694e505cedf822195d4fdefd6c67daa03d0da3c7acd8d647cdd1d5f53061f967751a96c83ada5def324ea3d26b56751930ae19e80bfda54c1b0a3a92c57c0662deacc36db43b50602cecc1dcc8f3618fe389b9049b633be56749753f9a52cefbd56dd44d5aaf46dc9c9ff9d766932e5e025e34c10d0085eedaa85758a4d270498f32bdeab0cb23ceea7412f673b7201b18b033708c8ae52df6ba4c8d0255a308f6304722b075cf31ac83a0161c3e192e1714c406032dec364f6c6d1485fc2f5e16b207287ecee05b6fda679a846825ceee24e4af1ec869273473b46a619407be21717c18b20253fb5b6e764ecc2ff918d19bd32780e834db152bddb36eabb80e0b9739a7b9069b770d9255a692e8a833c9abd3a0e8f25a48b3240dbb7959156c9a601b31f0abdd6358c68e9b4397bfc91028462d4bf6c0f1b9d60837e69cb5c8eadb8bfba8ba440e4d0ed76caed6c33cbb4716ffe294766c7b7d98c11f979c0fd0e4f672e707d83c9d13372d2aa2024120100e3a0a66aa78fb445d8987f20e377c2e1ed5f332df9ef6f76fc7f585a3baedfaf83ca0af97461c0efb09cf47ed659944a476d6f0611632cfd5a8e77c0d5b29cfd3e4a50c1b75d4bbceab7329f59bcf8dbc8b76bf188636736ee0370bf7ef5000e0c0407364f5966ee0286af9ec7a5283375f84a217534be5996691a8a87f2633434fa3479d90f4c5ccb278e143e64b4ea73a3dcaca0d6f42f52b5a83d01be65471291067aa960ba9be5f755d80325b560ef4cb2529ceba7ca29cb8b8ec443a816608d165a8332d605d131ea0eb6687b7c07aac8a38dc2ceed3b5170ba03da32dc6c21b63f358234f16c9a03cb0ecb22e1a85870c4f6932f95f56b98d72757cedc3f37c69cb8fd19e530cb24cfadd30ba9318ebf0c59f8ab711ac0a797d9d1d75e4006112959e82527958cf43412ea72e443c5e08652199413b6a3b82d74249b9b3e6a26732f81e273e1f218681e29f39a4c6f66c03e7d5696512407c1ea233806bfd4f525f2f6cb1556e1f16698dbe6ea472142f80d117bd3690a4b7b8b6dbe3888bbe3d7e7afe7b4aab83865ee50ae6c53d193c12b74dc8cd5f5896f0bcd9217dd92e343c36f37dcff527eb20652bff462d67b6f602e23a2c30034abc42b6ba55554240043e809a371a1a8150d7108ee848eac12aa4a5a3f7e0b894efbab794168905e84b293a65b86a64fcbd255fbeb9f07cffccc55aca0ed492d9cc3b524ddeee3c28e6e58e3ef166ffdb858c79a7765fa85a5bfe53dabf470c9606014e6c1e03526a835076ebccbb365f3ec3689a925473159e9bac7f495a31b70b2f2a3b085a2166f752e196b7c52202eff1266bc35f7dd4c0b82d35d54ffce3ee421a201741ee517327df1ae334fe223fa1ceab5c7281fb141eae7f84cbb58afff740b30c4aecb072e143109d1263fe640e1e0f3b8632cdb523cdcbe75efaaa051d90beb41c3ecaf113afa3333e879b1fc6c13f9adba3e236687047b105207832b180fc96d86ad313145faa9f29800ee3d8aa3253d1519ca358012c86f02ed6ac3501411b0bef669d531a6670c2fdf862f3d5972c32a73d1cdc6a761a588798f660c11e32893f2e7d5fdfa2eecdc7c8dbe9ac1776f98916969315effe83c9249b56292d1cfa106dd5f9fb072915fd21418beb5c51af47bfc90cea6b77ec0f890a995b1fc3e188518aea37ce4da1276cbc844dbfb52bb7fb4a31ddbae7e170fb31c695b753dfff40e864f9ac801f0b21de04df7b29b4e3fc2c6dbd7df24c11f61feeed07afb076fca7da5142b50a915defea1162225eb6a175db246877ff3021563fc2f4e07f4b6ef19626359e9eef005345f0822a7d19bde3ba486710d33a48bbe2d7f49c67f27d68afa3188e61606fd8cbf87a1a85cd5ddceff7f48f8ec05460d25ad11a65db53850b9b4d471a09096ea1eaf3e20102e07f68fbeb0690517d292416821ace334fea1323719f28b67b144dc7d746756d448a57f193448e16f6ffc05e00073a2eb6854ab9a99f4d297298e61eda96d03b865646e8f5841c3e4866d223e526677c9324f1f42800d80a4d61f889bb3014f70703ab50dab3a62b7d7c97a5d48bff1c8a5cc2e2c477227e6a6cb963dfafa17948b9639768bea12956ec515f5b221da19791dda32b9f771f5cf07f8436c91d7be15747166191006c765672580a55eb64bc716c5c28e2e15ff2c99f3852fc1b01ec6acd7415caf0bf7b191b3b64dd6b4a09f0098d04b4ba558c8d60cd68379362769029dd4dba0c1d256694b6eea0dab3033cfec39d8c754cc080f2e15bf44461e63b134e25fd5ee06a118d318f9c962b02c7efdc49f3e48f280d2aaf6f2ae37a0e88e22dd30714a4539095ddb6758b53bca573a6bd81a1ed4cd190dd9417503cfd3eeb2798f34015b1ce7676450dbc2004b8e1ee7c09fa624705bece974d9630653d98a74f82e6920440571379f00db24fa8e70ba32d8ecea925a834bbdd86a217185944beccd1475958ff6114d371c0d7a26d127b0a80b7e96dfc4320e5419246bcedc805a9a576a974585c07a97172e4a441e72de7a50caa69533f5fd938e7eb43979eaa6ff5875175536fc7f737064a687aec7963fee707b62fba549aa3ed6c8b5c33a5105a55f6409e80863c4480c8cfb55cf56ff3319b7f41cc8a17cd9b8bcb2c67b4385130e73806ed22a7ac32028dfee530a93e560dadedd76c569acff4eebed89f6a47fb1d12ddcd7ae8a3033728fe49543d6fe5084d51a55cb787f143c685d03a4a90123e8bca95163fd862d37aabf764b13c3c96f9fb8a12fd0040fa521bc25780d98d7962233bf63296f4580cd39302e6c81642846ae2332fc884a1c1555fd0adf9cb882924b58350b2d25ce6dc6a85f0062b6a0f12d72e6f2d7b5ba62e1eed290e1d05901612f068ad9fd52dafa28b00e12d99c05f2fca3c43326c1126eb3a7558c7c0e4396494e959f0d6644cdd770ea38c82d22601649ddced867801a5509353ebf92c800adcefd3b0aecab2f5b7f11dbd4f98e9aaa5bb769a27d9627ec1d1344214562620856e79b099d6c72569149d291bc83bd035ce376cf9534ea903e22dff19306ef4b22a675df0aff1d491e889c6637e41c6ec356cdcf34720bfd3e5aff40044dfcb167ef30a912505395eeefa1b28661366a87dddc52959ad14670402c7676fe19edff88461af13035f68edb7fea571add0e9f8a5e4f6ebc5cab012ba50af57cb2c31bbc06740c5627585667d7357be3b763bfde3563a06b2556d42dfb4b15a8b615419ff40c777f6d9785ca289e5fe7270b072b0c3d53e2a50c6672f7e151f72c12abb956d890a213a9570015dc1a16e4d8a9fbff6b655f6bc15887d5d7f31ee4f4e6c8b56f60428a9dbce7a4ca4fa5e7beb3c3d77a0d422af42d47580ca6a0bb07d487e41f12098602ccca50758913b1cbb790f3fe8565dbacf1c764de3720d70e36d5fe37b711bff8dbe5415cefdce0b4755b37e32165118a4b1559b288868a153ea4ece1f5215bd24df47b2b2d949ae60088b72c0b2b8d53d18205c6395a8cf1420e9e374315f8102062525fd7a17001defaf1bf1aa39e509efad7dc0143b1b26261f7836b866b60ef9a2844097f7ab0b245849ab00694b64b0ab22e2c0d73902540013fbf50e3c457743b297b1b909aa11c24cc3bc700e749b030398792320b950ba4e9877085b19415258b209beb843d474c5f1b7b11589fede18c9fb2cb1cf1816b71db71c0e3ba5e7a9cb54b5179a4f6b749899b34e2e6f9bc4699054fdda20e94d2128e5ffc8b32c8778ebda5a2fdafe529b05d9efa67d9780f5a790daeff2d8540e70e9fd68bcecdbc345acca527380882a03dfd87ab74ffc6379815b76c6a9be500f47578117f94c2b208634ebd2fcb8a423ad4c67cda8fd6c032a75251c6152c556e94a593a0d413b83b72b50406a8575d5f57dfa337c09304003c037911e4eba2de4f8cc213379a0a1592cb3aca87c9e0043ed510b7e55eedb5c270781ca6214168e2b4106be216dbee8832b3b7b8e77728bd2b9ec32f04f7e3af54dbfa2542b9b6b1f3bdad1513a08bb316e8259628eb493f50829695b568927aabd1ab75e0018e83f00e6eff21a128f62804e5f474d1b560e790768f0f94465841cf2b411d7b5789fed46e08477a4d1f0a669bbdf1366557eea3cf1b5205eca30b9b5da2a8b3b280ff8f18f441609c8f68cf124cd5f4e0906278b4111be768a1efcdb4effc8c0f75d2fcce2a9050d71d23ac92943cfe896d40b7f323490432acc3bf1cb8d3e0b19ade10441e5862a3c3b5a6c81dc3e9c2de57414580b01a06588cb33b6cbff94370d7b11238296219858db0d04a42e55779760eb7547fa8ffd61c7e501148610cf6043925954d679f1617e8de87eb087957df8dbbb92a58eb676bc0d9384a16c3255b9a4e01fd274fa9b2094f0817cc91fffb614ba076b8f88ee90832072bb2300ff1f3db2f81890d502aa1cf4b1d6510a646c832f4bfe53a1311184739f8a965c8f789804eae9391344f03751a4649daa579a0945ede0cb3a473b1b7335f45806ced5d3dc80c24f14706aa370defbb5cee273357aa129446ec298fa2bc31a7622fa6601ee65ad0f4a3171d7cd12e17d8dc8a567cecebf0de76d7f5875055799c05b59622ab59af379a6a5c835e61f27b28b2a2f94f9c6588d3489503fc8d186f16d1d55f0672a13ba1858b61d158e4d71e9ea0c0dd2e7098eea9d1df516b48feac9824e5cc7fa80cf286f46892f3d39bf703a9e10b70ad6c862cd391e9d7845bf3ae1c18607f10b412ad93a429bd26e092197d353bc19f66d19efe4860e74d6174e64b900792fdf20eb5a23fa22aab4e5a32a510919a068354da37aa0706b231ad35ae3b557feb21110b1a067f15108b17a4716137256c303fbde23d2b8e67af77d73755d60c83cf2e3d3d028b69a0e19fb0c44215e9f47af2a9700257cbf5611b179b9ef875e6078ada936bd02afbc5dd3832d69588e90f4181226d66ea334295d9b78a365550a8d033555ece51a23d6cde7b3245c6042395021cf6e54fed7cf839d68137313c45e4f16201ada33d0c8e13641892d0c10111a6f68b3bf763e6edbefbb500494a33abce19abea1bc4534d34d397c57476e9d668ac75c804143ad23a164dcdb543b9cd125a845deab07c9b1395cdedb83e4625898c4c0726fb81ccad59d600c7198275a57edb33ec90c39305f8fdfb54c37a51ba93c6c199be1e9b21bc1b5ae61fbbe8193bfc198e2a4328c65bdadcb47557cc5359452438801ffc2bd558101068d2f4b192d55a1e1211435f8e3cc686dbe4be1be90fda4bd19640844049f453655e0ec6d4b8dc35d39c7b067295259a0236110000cfd7a86f2b80bede0386964c286c16837bb021023949229142697ab61576efb78434a20e1c223aff8ddc3f9da6ef059fa4d62926b0ee38994504f6b33470fe7e8070471c3e467648c735dd7ff955905f729f821f7b5a7790c19c4e674db33cec0e7eaf81a40ebb26d06335355cec6dab30eef4ab019a03864bc47d0dff1649f7cbc7b16ebb284cbacef39266f6907028696e101db7715b80e1bfe192c951e06c0014ce4c737a183d990ea710fe65b24ad02a83d2e7eb6b35db3b79d49ab033cd3f146ca3db6653c9cbdabbb95dc38d0aa8709959e67c49225d459a2b093e2af656ee232c77ff84d5dc3f3175dca4afe68afc1e7bc0cfb24fb2f9f57e987df0c84795f4a4f5472a06ee97182f0938ad06a254c58a5b7ee5076226639c375fbb719fc0816d18e41b4cf6ffaa90aff21d906daeca62de1d6fcf8f4c764dba65ea7edca37f66abbe23175c071380092a21abaa7ac4154bffd3fd654daf4009b1ba159331638dd3ea60f580f36709fe3c54b0ee25b42868529fc4ee71e858352a9c0a5fa2912ab01c93df5adab25e1a4ef8e18556463657ff8ce7bd02c70d34772814c351f2c54310361ec7997964db0e00636805e7399c6709490fc7e3cd1d443da00e2d37025f0e7189372be996db1c22dea38ae962a49fbe3627ceaf5cb6d3348c327e5b4ceae1f5478cfacc54b9d04cff288aaa5b54a3a588eb7d47eb76067803d944219611a947bb2e738919e1ce65cc8bb1771f5f3cc9d931d0c0d36a9ec179ea9e97ec8ad222f6c0e246eb716830ecd0880d5c5ce95d677681e8fd404b2e07029df25728937c02f4eb6b548d29a120907555efd49963d2a19bcaf947be1c2b38d7fe5531a5d469e1b860ce818176c24e018340ec6905d3285ae7a04f47a584a365c7a3e84f3908de042a2e3dde471f2280bc2913ed1f669e8e2d9398ccfe26b68b83edd0195afa9619b375d6512b7b559a39be255b5ffcf159a62fa2b9f3a9df5e5cde21b88ca405bc22c5febbc2201947b5071221a271a7c310baaa846f678444a5ac68d24508279cbeed62928b0cd5ad7460917ebe58b57901b9630158627f9a25704ff8ba715c26956e888de1c34b4382fd1eb58945ebd3c1f050e5489f6107acd18cee8af79c08c988fe8c3a48aaa86d50c4f1a67328c0a8eec75fe27d3077a75b99b6b932810bfb5dcdd0cd70fa126e643c40189b4c5239b1ad8e152fa6932ba2f81322be2f5faab691a32563d6b3111e346fe029a87d6fdb59666c18652ada1b099b929fd7bb3d3a3b766c4bad098209aed00d366bb923f8e8e6a19d14de600eaf8cbe0018293c911495f384acbf67727acbd8ed26345600ab9a1001e0c5dafb9213cf834b8923c42dfd13a838bcb76942dbfd7b7eef0099ae7212b1adcff7be1eb07f21e19436c1ef84a3e975a807b53ed187c5e3d1775522f7862f56ee60e3c39eae4bf57a5a492c27910612322dd65c81a72ab49511e2aff8fd4b878931563376e16c3830489ba8221b326074cb3b49062228796cb250db4e5078ab78934739b700ddb06948e736b9ba5f7ad40e7b24b53c8c09c710da120f905c33cba11e4c6ee1752a5d6665fd615877fa5dc25a3370b838787cc466433307b6590146f613f06c92486399f187b666ab6e44a231bb0f84ae407cf481ba434c3f5fa1098c055ed4cc6b8273a1f8bc37f981cc0e8c42b1db5c0d3fd3fdfc518112cfc7ee21f10c434a98a3706cbc841d527273bfec7e69f8080733378385e385190bb0ba9b6a9af45a5bd9892d46a4fd61eedb7e4c772a174ecc2205fe06ce4f5db014ff03ae9c4abc1f8a388ac17bf278223b1a62af5c015c2a5f60a7ed41abf7d8b3d6792fdf03f3287fb368990b3f61241234f53ba5f0bc6129e4c7ec4517697d3340caed3d41662c81645b7bd5046516d2f7f59a2f4b1aa01d118e7756775647379cdec140ebfa64287fc71306807f74af60f284e172affb12fdae3d78b72d4ec4a570529ef6d007261ccddf430476b7cf4fa8c5617b7840573f73c34a4eceb7ebd839df95495c17657880d70dfef01e70fdd6dc493e3b575795e1c45ac1ae3699133685a40ad1daa9c71cdd630b610a02910c60f357d4d410c9ebb9d2b9045ee0bf5797df898343bedc6d732c30da4e3d34748beade1f3e45bf624ab1fc7a55e9cd4247c4752aae06a9b7ef37b6724364b1b0437b08ea695aa05af2c6603d90bde19c385c15a7333ecd6dc6871edb6d00be216ca335b26586ff3044e957fb51687108c0190c3cae389c1161407fb730d209e5c79935f06bfe63bfc540efd53dc2762b28f3ed7e158230e9ea0ffb9fe4ec35fd399d57e326ed4568e30a7f40e341e4509f0b8f63a4b09894563edce21a8368739114b05a89d48b164ab9ec084421f3782dcb5396d27db5b6866e0668ac3c9227ebd5002a9927618b73d60943c2453417ac091a8842562509c5d9428adb995a547470e0bae2836b92e75e23ddfeccbe73cf556dcb0f46ad194d890d0fe7104b9a3132c80d74cc3e8758e057f7b33a736fc87928f2b4b27a06c3373c25969507fbcc99a976aeb8e99d66756cef1235779205340422ab20872891692c50be1f3368f3bc95020b60f577acf2728ac25aad42b7ffbd8495693e1f485cd9fb12015b83db9024c78632b1fcb0d3f0b44d4da96da68e65f048a214afdf82a018d5d22aceb887175316b9bf62ee7b52b1655d563d045e54d0c7258e4041d382f099b353d839e655f6c48aaf31a509e1258cc764c3287c751cec97bd75d17dcc5fd4eff96779b0d8465c2d2acc0df639c98495acb57a08280403b8c4229aa096dd50260129d3cf69a1de5e449e4a8c3cf8106548ceb78cd021f3e1d808c986df860e7f411ee9188acb7cca0677b164c0d49866fae2b50519c90ca13bfcb8215a1bb52ced49379b54e76bf9c88727f18fcb056b8c1b47f4a1e05fbaf8502341589d3eaff457be753b8720946375ab5ea57bc9055732cf4ac6f7bc4d2539da674b48932eb0023fb45e930c0c3fd50463b71739b213e5707030b22344189e033dbd4313982be022777da334737e9af905b93a65ce467305df814aeacb528837fae403a916612ada863c38ac8cf39f4c4dc9f9e273975e6c841a309c67fa2536751d1416fc581278e351152d0c2a06937197cc4c4aefb8957bbdb052b36537d7fe924ae395ba1da02d2f5a56f864f7c4cf08fe7992894aee45780adc6d14dfdd2c15963014214baf92ca4e3d0ffb2886d4935a9be6a4bc3723850fc9bfa5017a8f1112bf64fea5c1d7d2dd0357214a9a0d8e479c4621a6212bea9ff4afb5026a73ccdea2510eba8c95615a5831e9596cfc135fb0ac3edc939f0d67fee04a49eba52f3c1d57536b72ff0bd91a72edd8dfbc34c4269017cdeea36bda475fce31abe235eca1d5506a193bbcf35096e0d9f8e6ba192792e615fd5c74cfd1f18673bebe3bf50e8f6ba03ca2b51a9855ed4867b3633adf94739e4e2ddf26d7ab7a3d1f4f02ce37d971925e265703876c473ef0bf3bfdbaa0b7dd7c904203a80c9589ccf596d0e55a53e83b37856ae67d95583c5936d011653bfc3abc7827b39002a36d21ff98f015b374b7036b3042f88abad9398da8ec8fa75a16fafed2040082c5075ed4a3b5bb50ada8e6f8bb119ebbd4ffe945bf0f6041dad274d5efae602197d6f4d350a6047df9f670185d72e6a948c5170df04ea3ad7ea04bd14e2c1407896701960a47730521fed197824032beb0d04ca9414d3d6af53b80a552b033b753fffcac3ed01504797991ece4568c7cefe048ec4adb8009e2595298fc819cfc4dfa52533be464216f209c3190e6338fcfd1db7aeda48df1bd7cc2f273199baf7b2c069af742c9489324c54f2bbf13c69a6c6e54492a897b7a0cdb6caf5915f3713cc585543b05c6855c41e480f5302b57d17c2c5a2222846fa9413bcc11e60e9ec8f9feb9f3b38a37fe1c134beaf57c1e6bd96278c99214b8591d050662720ca832013000b536bb13ca0a2519ee7ecb5de463d4196baea5321fe05315796942f8f4ccdf847dce02553252386ed941de98b443de33ad0e5ef6997b05a477de724ef9d4d1c04101da7224f984d7c260b59ac00bbb5eb10dd024919db3e8cceaaaef39767ac41e38e7b81e5ff163f75306f5878494029389e3640c7cf64d8cf0fe69c7418a545b93b77f0390eff7fc17e27b12fd16d3712b829c54c01bc47d07733faceb46403900a100162ec6865c1875c059c6c952ec39369fa3d5115a5f374ba82060bfdb6c4da4599a72a61f4c7b8eaf4a760464c47c307759648dede32a8c1102428d927a8633bcb82a6bcf94bbdfed2763c2d4df08a11737f80d3a88b8aeef251514cc653f81d56bfb892e1299f0bbf4ee899c983d592f080ec19b56b5ff35e35d2721808c7704162e228c1cb9ad6a415efae8a478915bb36479df4726a0b834e4567bb5a9f6c12152733edfcf0710ea8581e291a905230dd090cc8052bfe24ea2444dfc008829187530e1b05bdf4e2310e9845874fb537f9a052443961331e00c8dc0c9c409d21c0f0989b8f2cf4d4e129cf4d205a2f4628d9ba2777814661840655e1cc8a445eef98c525f47f076753c3a052fcc066c4db6d77cceb97db85e7f292acd9a9b444bf7c98e716a1df428dabc07dc5820f58f6</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">密码plz</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    
    <category term="随笔" scheme="http://xxsy613.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Realm学习笔记</title>
    <link href="http://xxsy613.github.io/2022/09/20/Realm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://xxsy613.github.io/2022/09/20/Realm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-09-20T09:03:36.000Z</published>
    <updated>2022-09-20T09:04:03.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Realm-Swift学习笔记（一）"><a href="#Realm-Swift学习笔记（一）" class="headerlink" title="Realm-Swift学习笔记（一）"></a>Realm-Swift学习笔记（一）</h1><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><h3 id="打开Realm数据库"><a href="#打开Realm数据库" class="headerlink" title="打开Realm数据库"></a>打开Realm数据库</h3><p>初始化realm对象：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> realm <span class="operator">=</span> <span class="keyword">try!</span> <span class="type">Realm</span>()</span><br><span class="line"><span class="keyword">try!</span> realm.write &#123;</span><br><span class="line">  realm.add(<span class="type">Student</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化一个默认的Realm数据库</p><h3 id="配置Realm数据库"><a href="#配置Realm数据库" class="headerlink" title="配置Realm数据库"></a>配置Realm数据库</h3><ul><li>可配置本地Realm数据库在磁盘上的路径</li><li>对于可同步的Realm数据库而言，可以配置管理用户，以及远端的路径</li><li>配置版本迁移</li><li>压缩功能，高效地利用磁盘空间</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">setDefaultRealmForUser</span>(<span class="params">username</span>: <span class="type">String</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> config <span class="operator">=</span> <span class="type">Realm</span>.<span class="type">Configuration</span>()</span><br><span class="line">  config.fileURL <span class="operator">=</span> config.fileURL<span class="operator">!</span>.deletingLastPathComponent().appendingPathComponent(<span class="string">&quot;<span class="subst">\(username)</span>.realm&quot;</span>)</span><br><span class="line">  <span class="type">Realm</span>.<span class="type">Configuration</span>.defaultConfiguration <span class="operator">=</span> config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="操作realm对象"><a href="#操作realm对象" class="headerlink" title="操作realm对象"></a>操作realm对象</h2><h3 id="自动更新对象"><a href="#自动更新对象" class="headerlink" title="自动更新对象"></a>自动更新对象</h3><p>Object实例是底层数据的动态体现，<u>会自动进行更新</u>，修改某个对象的属性，会立即影响到所有指向该对象的其他实例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myStudent <span class="operator">=</span> <span class="type">Student</span>()</span><br><span class="line">myStudent.name <span class="operator">=</span> <span class="string">&quot;yun&quot;</span></span><br><span class="line">myStudent.age <span class="operator">=</span> <span class="number">20</span></span><br><span class="line"><span class="keyword">try!</span> realm.write &#123;</span><br><span class="line">  realm.add(myStudent)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myself <span class="operator">=</span> realm.objects(<span class="type">Student</span>.<span class="keyword">self</span>).filter(<span class="string">&quot;age == 20&quot;</span>).first</span><br><span class="line"><span class="keyword">try!</span> realm.write &#123;</span><br><span class="line">  myself<span class="operator">!</span>.age <span class="operator">=</span> <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;age of mine: <span class="subst">\(myStudent.age)</span>&quot;</span>)  <span class="comment">// age of mine: 18</span></span><br></pre></td></tr></table></figure><h3 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h3><p><u>对象的所有更改操作（增删改查），都必须在写入事务中执行（write闭包）</u>。</p><p>Realm对象的使用方法与其他正常swift对象无异。未添加到Realm数据库之前的Realm对象，称其为未管理对象。写入事务会产生性能消耗，应当尽可能减少写入事务的次数。</p><p><u>写入操作是同步以及阻塞进行的</u>，不会异步执行。写入事务会在beginWrite()执行时自动刷新，因此重复写入并不会产生竞争条件。</p><h3 id="更新对象"><a href="#更新对象" class="headerlink" title="更新对象"></a>更新对象</h3><h4 id="直接更新"><a href="#直接更新" class="headerlink" title="直接更新"></a>直接更新</h4><p>直接设置对象的属性从而完成更新</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try!</span> realm.write &#123;</span><br><span class="line">  myStudent.name <span class="operator">=</span> <span class="string">&quot;xxsy&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="键值编码"><a href="#键值编码" class="headerlink" title="键值编码"></a>键值编码</h4><p>Object，Result，List均允许使用<strong>键值编码（KVC）</strong>。需要批量更新对象时，为集合实现KVC是一个很好的做法，这样就不用承受遍历集合时为每个项目创建访问器所带来的性能消耗。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> students <span class="operator">=</span> realm.objects(<span class="type">Student</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="keyword">try!</span> realm.write &#123;</span><br><span class="line">  students.first<span class="operator">?</span>.setValue(<span class="literal">true</span>, forKetPath: <span class="string">&quot;isFirst&quot;</span>)</span><br><span class="line">  students.setValue(<span class="string">&quot;China&quot;</span>, forKeyPath: <span class="string">&quot;Country&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过主键更新"><a href="#通过主键更新" class="headerlink" title="通过主键更新"></a>通过主键更新</h4><p>如果数据模型类中包含了主键，可以用Realm().add(_:update:)，从而让Realm基于主键来自动更新或者添加对象。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个book对象，其主键与之前存储的book对象相同</span></span><br><span class="line"><span class="keyword">let</span> cheeseBook <span class="operator">=</span> <span class="type">Book</span>()</span><br><span class="line">cheeseBook.title <span class="operator">=</span> <span class="string">&quot;Cheese recipies&quot;</span></span><br><span class="line">cheeseBook.price <span class="operator">=</span> <span class="number">9000</span></span><br><span class="line">cheeseBook.id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="comment">// 更新这个id=1的book</span></span><br><span class="line"><span class="keyword">try!</span> realm.write &#123;</span><br><span class="line">  realm.add(cheeseBook, update: <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这个id &#x3D; 1的Book对象存在于数据库当中，那么该对象只会进行更新，如果不存在的话，那么一个全新的Book对象就会被创建出来，并被添加到数据库当中。</p><p>可以传递一个子集，其中只包含打算更新的值，从而对带有主键的对象进行部分更新：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设主键为&#x27;1&#x27;的&quot;Book&quot;对象已经存在</span></span><br><span class="line"><span class="keyword">try!</span> realm.write &#123;</span><br><span class="line">  realm.create(<span class="type">Book</span>.<span class="keyword">self</span>, value:[<span class="string">&quot;id&quot;</span>:<span class="number">1</span>, <span class="string">&quot;price&quot;</span>: <span class="number">9000.0</span>], update: <span class="literal">true</span>)</span><br><span class="line"> <span class="comment">// book对象的title属性保持不变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有定义主键时不要对对象传递update:true参数。</p><h3 id="删除对象"><a href="#删除对象" class="headerlink" title="删除对象"></a>删除对象</h3><p>在写入事务中，将要删除的对象传递给Realm().delete(_:)方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cheeseBook 存储在Realm数据库中</span></span><br><span class="line"><span class="keyword">try!</span> realm.write &#123;</span><br><span class="line">  realm.delete(cheeseBook)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除所有数据</span></span><br><span class="line"><span class="keyword">try!</span> realm.write &#123;</span><br><span class="line">  realm.deleteAll()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>查询会返回一个Results实例，其中包含一组Object对象。</p><p>查询结果并不是数据的拷贝：<u>修改查询结果会直接修改磁盘上的数据</u></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> students <span class="operator">=</span> realm.objects(<span class="type">Student</span>.<span class="keyword">self</span>)</span><br></pre></td></tr></table></figure><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用断言字符串来查询</span></span><br><span class="line"><span class="keyword">var</span> goodStudents <span class="operator">=</span> realm.objects(<span class="type">Student</span>.<span class="keyword">self</span>).filter(<span class="string">&quot;grade &gt;= 90 AND awards == true&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li><p>比较操作数可以是属性名，也可以是常量。但至少要有一个操作数是属性名；</p></li><li><p>比较操作符 &#x3D;&#x3D;、&lt;&#x3D;、&lt;、&gt;&#x3D;、&gt;、!&#x3D; 和 BETWEEN 支持 Int、Int8、Int16、Int32、Int64、Float、Double 以及 Date 这几种属性类型，例如 age &#x3D;&#x3D; 45；</p></li><li><p>比较是否相同：&#x3D;&#x3D; 和 !&#x3D;，例如，Results().filter(“company &#x3D;&#x3D; %@”, company)；</p></li><li><p>比较操作符 &#x3D;&#x3D; 和 !&#x3D; 支持布尔属性；</p></li><li><p>对于 String 和 Data 属性而言，支持使用 &#x3D;&#x3D;、!&#x3D;、BEGINSWITH、CONTAINS 和 ENDSWITH 操作符，例如 name CONTAINS ‘Ja’；</p></li><li><p>对于 String 属性而言，LIKE 操作符可以用来比较左端属性和右端表达式：? 和 * 可用作通配符，其中 ? 可以匹配任意一个字符，* 匹配 0 个及其以上的字符。例如：value LIKE ‘?bc*’ 可以匹配到诸如 “abcde” 和 “cbc” 之类的字符串；</p></li><li><p>字符串的比较忽略大小写，例如 name CONTAINS[c] ‘Ja’。请注意，只有 “A-Z” 和 “a-z” 之间的字符大小写会被忽略。[c] 修饰符可以与 [d] 修饰符结合使用；</p></li><li><p>字符串的比较忽略变音符号，例如 name BEGINSWITH[d] ‘e’ 能够匹配到 étoile。这个修饰符可以与 [c] 修饰符结合使用。（这个修饰符只能够用于 Realm 所支持的字符串子集：参见当前的限制一节来了解详细信息。）</p></li><li><p>Realm 支持以下组合操作符：“AND”、“OR” 和 “NOT”，例如 name BEGINSWITH ‘J’ AND age &gt;&#x3D; 32；</p></li><li><p>包含操作符：IN，例如 name IN {‘Lisa’, ‘Spike’, ‘Hachi’}；</p></li><li><p>空值比较：&#x3D;&#x3D;、!&#x3D;，例如 Results().filter(“ceo &#x3D;&#x3D; nil”)。请注意，Realm 将 nil 视为一种特殊值，而不是某种缺失值；这与 SQL 不同，nil 等同于自身；</p></li><li><p>ANY 比较，例如 ANY student.age &lt; 21；</p></li><li><p>List 和 Results 属性支持聚集表达式：@count、@min、@max、@sum 和 @avg，例如 realm.objects(Company.self).filter(“employees.@count &gt; 5”) 可用以检索所有拥有 5 名以上雇员的公司。</p></li><li><p>支持子查询，不过存在以下限制：</p><ul><li><p>@count 是唯一一个能在 SUBQUERY 表达式当中使用的操作符；</p></li><li><p>SUBQUERY(…).@count 表达式只能与常量相比较；</p></li><li><p>目前仍不支持关联子查询。</p></li></ul></li></ul><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>Results允许您指定一个排序标准，然后基于关键路径，属性或者多个排序描述符来进行排序。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sortedStudent <span class="operator">=</span> realm.objects(<span class="type">Student</span>.<span class="keyword">self</span>).filter(<span class="string">&quot;grade &gt;= 90&quot;</span>).sorted(byKeyPath: <span class="string">&quot;name&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="链式查询"><a href="#链式查询" class="headerlink" title="链式查询"></a>链式查询</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> goodStudent <span class="operator">=</span> realm.objects(<span class="type">Student</span>.<span class="keyword">self</span>).filter(<span class="string">&quot;grade&gt;=90&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> goodStudentWithAwards <span class="operator">=</span> goodStudent.filter(<span class="string">&quot;awards == true&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="结果的自更新"><a href="#结果的自更新" class="headerlink" title="结果的自更新"></a>结果的自更新</h3><p>Objects实例是底层数据的动态体现，其会自动进行更新</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> puppies <span class="operator">=</span> realm.objects(<span class="type">Dog</span>.<span class="keyword">self</span>).filter(<span class="string">&quot;age &lt; 2&quot;</span>)</span><br><span class="line">puppies.count <span class="comment">// =&gt; 0</span></span><br><span class="line"><span class="keyword">try!</span> realm.write &#123;</span><br><span class="line">    realm.create(<span class="type">Dog</span>.<span class="keyword">self</span>, value: [<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Fido&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line">puppies.count <span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure><h2 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h2><h3 id="本地迁移"><a href="#本地迁移" class="headerlink" title="本地迁移"></a>本地迁移</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此段代码位于 application(application:didFinishLaunchingWithOptions:)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> config <span class="operator">=</span> <span class="type">Realm</span>.<span class="type">Configuration</span>(</span><br><span class="line">    <span class="comment">// 设置新的架构版本。必须大于之前所使用的</span></span><br><span class="line">    <span class="comment">// （如果之前从未设置过架构版本，那么当前的架构版本为 0）</span></span><br><span class="line">    schemaVersion: <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置模块，如果 Realm 的架构版本低于上面所定义的版本，</span></span><br><span class="line">    <span class="comment">// 那么这段代码就会自动调用</span></span><br><span class="line">    migrationBlock: &#123; migration, oldSchemaVersion <span class="keyword">in</span></span><br><span class="line">        <span class="comment">// 我们目前还未执行过迁移，因此 oldSchemaVersion == 0</span></span><br><span class="line">        <span class="keyword">if</span> (oldSchemaVersion <span class="operator">&lt;</span> <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有什么要做的！</span></span><br><span class="line">            <span class="comment">// Realm 会自行检测新增和被移除的属性</span></span><br><span class="line">            <span class="comment">// 然后会自动更新磁盘上的架构</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知 Realm 为默认的 Realm 数据库使用这个新的配置对象</span></span><br><span class="line"><span class="type">Realm</span>.<span class="type">Configuration</span>.defaultConfiguration <span class="operator">=</span> config</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在我们已经通知了 Realm 如何处理架构变化，</span></span><br><span class="line"><span class="comment">// 打开文件将会自动执行迁移</span></span><br><span class="line"><span class="keyword">let</span> realm <span class="operator">=</span> <span class="keyword">try!</span> <span class="type">Realm</span>()</span><br></pre></td></tr></table></figure><h3 id="值的更新"><a href="#值的更新" class="headerlink" title="值的更新"></a>值的更新</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 此段代码位于 application(application:didFinishLaunchingWithOptions:)</span></span><br><span class="line"></span><br><span class="line"><span class="type">Realm</span>.<span class="type">Configuration</span>.defaultConfiguration <span class="operator">=</span> <span class="type">Realm</span>.<span class="type">Configuration</span>(</span><br><span class="line">    schemaVersion: <span class="number">1</span>,</span><br><span class="line">    migrationBlock: &#123; migration, oldSchemaVersion <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> (oldSchemaVersion <span class="operator">&lt;</span> <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// enumerateObjects(ofType:_:) 方法将会遍历</span></span><br><span class="line">            <span class="comment">// 所有存储在 Realm 文件当中的 `Person` 对象</span></span><br><span class="line">            migration.enumerateObjects(ofType: <span class="type">Person</span>.className()) &#123; oldObject, newObject <span class="keyword">in</span></span><br><span class="line">                <span class="comment">// 将两个 name 合并到 fullName 当中</span></span><br><span class="line">                <span class="keyword">let</span> firstName <span class="operator">=</span> oldObject<span class="operator">!</span>[<span class="string">&quot;firstName&quot;</span>] <span class="keyword">as!</span> <span class="type">String</span></span><br><span class="line">                <span class="keyword">let</span> lastName <span class="operator">=</span> oldObject<span class="operator">!</span>[<span class="string">&quot;lastName&quot;</span>] <span class="keyword">as!</span> <span class="type">String</span></span><br><span class="line">                newObject<span class="operator">!</span>[<span class="string">&quot;fullName&quot;</span>] <span class="operator">=</span> <span class="string">&quot;<span class="subst">\(firstName)</span> <span class="subst">\(lastName)</span>&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h3 id="属性重命名"><a href="#属性重命名" class="headerlink" title="属性重命名"></a>属性重命名</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此段代码位于 application(application:didFinishLaunchingWithOptions:)</span></span><br><span class="line"></span><br><span class="line"><span class="type">Realm</span>.<span class="type">Configuration</span>.defaultConfiguration <span class="operator">=</span> <span class="type">Realm</span>.<span class="type">Configuration</span>(</span><br><span class="line">    schemaVersion: <span class="number">1</span>,</span><br><span class="line">    migrationBlock: &#123; migration, oldSchemaVersion <span class="keyword">in</span></span><br><span class="line">        <span class="comment">// 我们目前还未执行过迁移，因此 oldSchemaVersion == 0</span></span><br><span class="line">        <span class="keyword">if</span> (oldSchemaVersion <span class="operator">&lt;</span> <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 重命名操作必须要在 `enumerateObjects(ofType: _:)` 调用之外进行</span></span><br><span class="line">            migration.renameProperty(onType: <span class="type">Person</span>.className(), from: <span class="string">&quot;yearsSinceBirth&quot;</span>, to: <span class="string">&quot;age&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><p>当整个 Realm 数据库发生变化时，就会发送 Realm 通知；如果只有个别对象被修改、添加或者删除，那么就会发送集合通知。</p><h3 id="Realm通知"><a href="#Realm通知" class="headerlink" title="Realm通知"></a>Realm通知</h3><p>通知处理模块可以对整个Realm数据库进行注册。每次涉及到Realm的写入事务提交之后，无论写入事务发生在哪个线程还是进程中，通知处理模块都会被激活。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 Realm 通知</span></span><br><span class="line"><span class="keyword">let</span> token <span class="operator">=</span> realm.observe &#123; notification, realm <span class="keyword">in</span></span><br><span class="line">    viewController.updateUI()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 随后</span></span><br><span class="line">token.invalidate()</span><br></pre></td></tr></table></figure><h3 id="集合通知"><a href="#集合通知" class="headerlink" title="集合通知"></a>集合通知</h3><p>可以通过传递到通知模块当中的RealmCollectionChange参数来访问这些变更。该对象存放了受删除（deletions），插入（insertions）以及修改（modifications）所影响的索引信息。</p><h3 id="对象通知"><a href="#对象通知" class="headerlink" title="对象通知"></a>对象通知</h3><p>Realm支持对象级别的通知。可以在特定的Realm对象上进行通知单注册，对象被删除，修改时获取相应的通知。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StepCounter</span>: <span class="title class_">Object</span> &#123;</span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">dynamic</span> <span class="keyword">var</span> steps <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stepCounter <span class="operator">=</span> <span class="type">StepCounter</span>()</span><br><span class="line"><span class="keyword">let</span> realm <span class="operator">=</span> <span class="keyword">try!</span> <span class="type">Realm</span>()</span><br><span class="line"><span class="keyword">try!</span> realm.write &#123;</span><br><span class="line">    realm.add(stepCounter)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> token : <span class="type">NotificationToken</span>?</span><br><span class="line">token <span class="operator">=</span> stepCounter.observe &#123; change <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> change &#123;</span><br><span class="line">    <span class="keyword">case</span> .change(<span class="keyword">let</span> properties):</span><br><span class="line">        <span class="keyword">for</span> property <span class="keyword">in</span> properties &#123;</span><br><span class="line">            <span class="keyword">if</span> property.name <span class="operator">==</span> <span class="string">&quot;steps&quot;</span> <span class="operator">&amp;&amp;</span> property.newValue <span class="keyword">as!</span> <span class="type">Int</span> <span class="operator">&gt;</span> <span class="number">1000</span> &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Congratulations, you&#x27;ve exceeded 1000 steps.&quot;</span>)</span><br><span class="line">                token <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> .error(<span class="keyword">let</span> error):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;An error occurred: <span class="subst">\(error)</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> .deleted:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The object was deleted.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跨线程使用Realm数据库"><a href="#跨线程使用Realm数据库" class="headerlink" title="跨线程使用Realm数据库"></a>跨线程使用Realm数据库</h2><p>在不同的线程中使用同一个Realm文件，必须每一个线程初始化一个新的Realm实例。</p><p>不支持跨线程共享Realm实例。Realm实例要访问相同的Realm文件还必须使用相同的Realm.Configuration</p><h2 id="Realm数据库中图片的插入，读取"><a href="#Realm数据库中图片的插入，读取" class="headerlink" title="Realm数据库中图片的插入，读取"></a>Realm数据库中图片的插入，读取</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="type">HeadPortrait</span>:<span class="type">Object</span> &#123;</span><br><span class="line">  <span class="keyword">@objc</span> <span class="keyword">dynamic</span> <span class="keyword">var</span> data: <span class="type">Data</span>?</span><br><span class="line">  <span class="keyword">@objc</span> <span class="keyword">dynamic</span> <span class="keyword">var</span> date: <span class="type">Date</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将图片转换为Data</span></span><br><span class="line"><span class="keyword">let</span> imageURL <span class="operator">=</span> <span class="type">Bundle</span>.main.url(forResource: <span class="string">&quot;0&quot;</span>, withExtension: <span class="string">&quot;PNG&quot;</span>)<span class="operator">!</span></span><br><span class="line"><span class="keyword">let</span> imageData <span class="operator">=</span> <span class="keyword">try!</span> <span class="type">Data</span>(contentsOf: imageURL)</span><br><span class="line"><span class="comment">// 将Data数据放到实体对象中</span></span><br><span class="line"><span class="keyword">let</span> portrait <span class="operator">=</span> <span class="type">HeadPortrait</span>()</span><br><span class="line">portrait.data <span class="operator">=</span> imageData</span><br><span class="line"><span class="comment">// 数据持久化操作</span></span><br><span class="line"><span class="keyword">try!</span> realm.write &#123;</span><br><span class="line">  realm.add(portrait)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> portraits <span class="operator">=</span> realm.objects(<span class="type">HeadPortrait</span>.<span class="keyword">self</span>).sorted(byKeyPath: <span class="string">&quot;date&quot;</span>, ascending: <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">if</span> portraits.count <span class="operator">&gt;</span> <span class="number">0</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> imgData <span class="operator">=</span> portraits[<span class="number">0</span>].data &#123;</span><br><span class="line">    <span class="keyword">self</span>.imageView.image <span class="operator">=</span> <span class="type">UIImage</span>(data:imgData)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Realm-Swift学习笔记（一）&quot;&gt;&lt;a href=&quot;#Realm-Swift学习笔记（一）&quot; class=&quot;headerlink&quot; title=&quot;Realm-Swift学习笔记（一）&quot;&gt;&lt;/a&gt;Realm-Swift学习笔记（一）&lt;/h1&gt;&lt;h2 id=&quot;基</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://xxsy613.github.io/2022/09/06/hello-world/"/>
    <id>http://xxsy613.github.io/2022/09/06/hello-world/</id>
    <published>2022-09-06T07:29:04.274Z</published>
    <updated>2022-09-06T07:29:04.274Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
